<HTML><HEAD><!--Revised: 24 Nov 1997 By: Pieter Hintjens-->
<TITLE>The Standard Function Library</TITLE></HEAD>
<BODY BACKGROUND="newstone.gif">
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>
 | <A HREF="/index.htm"> iMatix home page</A><BR>
 | <A HREF="sfldoc.htm">&lt;&lt;</A> | &lt;
 | &gt; | <A HREF="sfldoc.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT>
<IMG SRC="sfl80c.gif" ALT="SFL Logo" WIDTH=80 HEIGHT=60 ALIGN=RIGHT HSPACE=10>
<FONT SIZE=5><B>SFL</B><BR><FONT SIZE=2>Version 2.1
</TABLE>
<HR>

<H1>The Standard Function Library</H1>

<P>The SFL (Standard Function Library) from iMatix is a portable
function library for C/C++ programs.  The SFL is the result of
many years' development, and is provided as free software for the
benefit of the Internet community.

<P>You may want to go straight to the <A HREF="sfldoc.htm#TOC">Table of Contents</A>.

<P>The SFL is written in ANSI C and has been ported to MS-DOS,
Windows, UNIX systems (Linux, IBM AIX, SunOS, HP/UX, Solaris,
NetBSD, FreeBSD, SCO OpenServer, Digital UNIX) and Digital OpenVMS.
It comes with complete sources and documentation in HTML.

<P>The SFL provides about 300 functions that cover these areas:
<UL>
<LI>Compression, encryption, and encoding;
<LI>Datatype conversion and formatting;
<LI>Dates, times, and calendars;
<LI>Directory and environment access;
<LI>User and process groups;
<LI>Inverted bitmap indices;
<LI>Symbol tables;
<LI>Error message files;
<LI>Configuration files;
<LI>String manipulation and searching;
<LI>File access;
<LI>Internet socket access;
<LI>Internet programming (MIME, CGI);
<LI>Server (batch) programming;
<LI>Program tracing.
</UL>

<P>The SFL is free software that you may use and distribute for
private or commercial purposes according to the
<A HREF="sfldoc.htm#license">SFL License Agreement</A>.

<A NAME="TOC">&nbsp;</A>
<H2>Table of Contents</H2>
<MENU>
<LI><A HREF="#TOC1">What Is The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC2">Origins</A></LI>
<LI><A HREF="#TOC3">Objectives</A></LI>
<LI><A HREF="#TOC4">Portability</A></LI>
</MENU>
<LI><A HREF="#TOC5">Installing The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC6">Availability and Distribution</A></LI>
<LI><A HREF="#TOC7">Installation for UNIX Systems</A></LI>
<LI><A HREF="#TOC8">Installation for Digital VMS Systems</A></LI>
<LI><A HREF="#TOC9">Installation for Windows</A></LI>
<LI><A HREF="#TOC10">Installation for MS-DOS</A></LI>
</MENU>
<LI><A HREF="#TOC11">Using The SFL</A></LI>
<MENU>
<LI><A HREF="#TOC12">The Universal Header File - prelude.h</A></LI>
<LI><A HREF="#TOC13">The Library Header File - sfl.h</A></LI>
<LI><A HREF="#TOC14">System Notes</A></LI>
<LI><A HREF="#TOC15">To Do List</A></LI>
</MENU>
<LI><A HREF="#TOC16">Contributors and References</A></LI>
<LI><A HREF="#TOC17">The SFL License Agreement</A></LI>
<LI><A HREF="#TOC18">Universal Header File for C programming</A></LI>
<LI><A HREF="#TOC19">Define SFL version</A></LI>
<LI><A HREF="#TOC20">Large bitstring manipulation functions</A></LI>
<MENU>
<LI><A HREF="#TOC21"><TT>bits_init</TT></A></LI>
<LI><A HREF="#TOC22"><TT>bits_term</TT></A></LI>
<LI><A HREF="#TOC23"><TT>bits_create</TT></A></LI>
<LI><A HREF="#TOC24"><TT>bits_destroy</TT></A></LI>
<LI><A HREF="#TOC25"><TT>bits_set</TT></A></LI>
<LI><A HREF="#TOC26"><TT>bits_clear</TT></A></LI>
<LI><A HREF="#TOC27"><TT>bits_test</TT></A></LI>
<LI><A HREF="#TOC28"><TT>bits_fput</TT></A></LI>
<LI><A HREF="#TOC29"><TT>bits_fget</TT></A></LI>
</MENU>
<LI><A HREF="#TOC30">Compression functions</A></LI>
<MENU>
<LI><A HREF="#TOC31"><TT>compress_block</TT></A></LI>
<LI><A HREF="#TOC32"><TT>expand_block</TT></A></LI>
<LI><A HREF="#TOC33"><TT>compress_rle</TT></A></LI>
<LI><A HREF="#TOC34"><TT>expand_rle</TT></A></LI>
<LI><A HREF="#TOC35"><TT>compress_nulls</TT></A></LI>
<LI><A HREF="#TOC36"><TT>expand_nulls</TT></A></LI>
<LI><A HREF="#TOC37"><TT>compress_bits</TT></A></LI>
<LI><A HREF="#TOC38"><TT>expand_bits</TT></A></LI>
</MENU>
<LI><A HREF="#TOC39">Console output functions</A></LI>
<MENU>
<LI><A HREF="#TOC40"><TT>console_send</TT></A></LI>
<LI><A HREF="#TOC41"><TT>console_enable</TT></A></LI>
<LI><A HREF="#TOC42"><TT>console_disable</TT></A></LI>
<LI><A HREF="#TOC43"><TT>console_set_mode</TT></A></LI>
<LI><A HREF="#TOC44"><TT>console_capture</TT></A></LI>
<LI><A HREF="#TOC45"><TT>coprintf</TT></A></LI>
<LI><A HREF="#TOC46"><TT>coputs</TT></A></LI>
<LI><A HREF="#TOC47"><TT>coputc</TT></A></LI>
</MENU>
<LI><A HREF="#TOC48">Conversion functions</A></LI>
<MENU>
<LI><A HREF="#TOC49"><TT>conv_bool_str</TT></A></LI>
<LI><A HREF="#TOC50"><TT>conv_date_pict</TT></A></LI>
<LI><A HREF="#TOC51"><TT>conv_date_str</TT></A></LI>
<LI><A HREF="#TOC52"><TT>conv_number_str</TT></A></LI>
<LI><A HREF="#TOC53"><TT>conv_str_bool</TT></A></LI>
<LI><A HREF="#TOC54"><TT>conv_str_date</TT></A></LI>
<LI><A HREF="#TOC55"><TT>conv_str_day</TT></A></LI>
<LI><A HREF="#TOC56"><TT>conv_str_number</TT></A></LI>
<LI><A HREF="#TOC57"><TT>conv_str_time</TT></A></LI>
<LI><A HREF="#TOC58"><TT>conv_time_pict</TT></A></LI>
<LI><A HREF="#TOC59"><TT>conv_time_str</TT></A></LI>
</MENU>
<LI><A HREF="#TOC60">Encryption and decryption functions</A></LI>
<MENU>
<LI><A HREF="#TOC61"><TT>crypt_encode</TT></A></LI>
<LI><A HREF="#TOC62"><TT>crypt_decode</TT></A></LI>
<LI><A HREF="#TOC63"><TT>calculate_crc</TT></A></LI>
</MENU>
<LI><A HREF="#TOC64">Date and time functions</A></LI>
<MENU>
<LI><A HREF="#TOC65"><TT>date_now</TT></A></LI>
<LI><A HREF="#TOC66"><TT>time_now</TT></A></LI>
<LI><A HREF="#TOC67"><TT>leap_year</TT></A></LI>
<LI><A HREF="#TOC68"><TT>julian_date</TT></A></LI>
<LI><A HREF="#TOC69"><TT>day_of_week</TT></A></LI>
<LI><A HREF="#TOC70"><TT>next_weekday</TT></A></LI>
<LI><A HREF="#TOC71"><TT>prev_weekday</TT></A></LI>
<LI><A HREF="#TOC72"><TT>week_of_year</TT></A></LI>
<LI><A HREF="#TOC73"><TT>year_quarter</TT></A></LI>
<LI><A HREF="#TOC74"><TT>default_century</TT></A></LI>
<LI><A HREF="#TOC75"><TT>pack_date</TT></A></LI>
<LI><A HREF="#TOC76"><TT>pack_time</TT></A></LI>
<LI><A HREF="#TOC77"><TT>unpack_date</TT></A></LI>
<LI><A HREF="#TOC78"><TT>unpack_time</TT></A></LI>
<LI><A HREF="#TOC79"><TT>date_to_days</TT></A></LI>
<LI><A HREF="#TOC80"><TT>days_to_date</TT></A></LI>
<LI><A HREF="#TOC81"><TT>date_to_timer</TT></A></LI>
<LI><A HREF="#TOC82"><TT>timer_to_date</TT></A></LI>
<LI><A HREF="#TOC83"><TT>timer_to_time</TT></A></LI>
<LI><A HREF="#TOC84"><TT>timer_to_gmdate</TT></A></LI>
<LI><A HREF="#TOC85"><TT>timer_to_gmtime</TT></A></LI>
<LI><A HREF="#TOC86"><TT>time_to_csecs</TT></A></LI>
<LI><A HREF="#TOC87"><TT>csecs_to_time</TT></A></LI>
<LI><A HREF="#TOC88"><TT>future_date</TT></A></LI>
<LI><A HREF="#TOC89"><TT>past_date</TT></A></LI>
<LI><A HREF="#TOC90"><TT>date_diff</TT></A></LI>
<LI><A HREF="#TOC91"><TT>valid_date</TT></A></LI>
<LI><A HREF="#TOC92"><TT>valid_time</TT></A></LI>
<LI><A HREF="#TOC93"><TT>date_is_future</TT></A></LI>
<LI><A HREF="#TOC94"><TT>date_is_past</TT></A></LI>
<LI><A HREF="#TOC95"><TT>timezone_string</TT></A></LI>
<LI><A HREF="#TOC96"><TT>local_to_gmt</TT></A></LI>
<LI><A HREF="#TOC97"><TT>gmt_to_local</TT></A></LI>
</MENU>
<LI><A HREF="#TOC98">External data representation functions</A></LI>
<MENU>
<LI><A HREF="#TOC99"><TT>exdr_write</TT></A></LI>
<LI><A HREF="#TOC100"><TT>exdr_writed</TT></A></LI>
<LI><A HREF="#TOC101"><TT>exdr_read</TT></A></LI>
</MENU>
<LI><A HREF="#TOC102">Fast string searching functions</A></LI>
<MENU>
<LI><A HREF="#TOC103"><TT>strfind</TT></A></LI>
<LI><A HREF="#TOC104"><TT>strfind_r</TT></A></LI>
<LI><A HREF="#TOC105"><TT>strfind_rb</TT></A></LI>
<LI><A HREF="#TOC106"><TT>memfind</TT></A></LI>
<LI><A HREF="#TOC107"><TT>memfind_r</TT></A></LI>
<LI><A HREF="#TOC108"><TT>memfind_rb</TT></A></LI>
<LI><A HREF="#TOC109"><TT>txtfind</TT></A></LI>
</MENU>
<LI><A HREF="#TOC110">File-access functions</A></LI>
<MENU>
<LI><A HREF="#TOC111"><TT>file_open</TT></A></LI>
<LI><A HREF="#TOC112"><TT>file_locate</TT></A></LI>
<LI><A HREF="#TOC113"><TT>file_close</TT></A></LI>
<LI><A HREF="#TOC114"><TT>file_read</TT></A></LI>
<LI><A HREF="#TOC115"><TT>file_readn</TT></A></LI>
<LI><A HREF="#TOC116"><TT>file_write</TT></A></LI>
<LI><A HREF="#TOC117"><TT>file_copy</TT></A></LI>
<LI><A HREF="#TOC118"><TT>file_concat</TT></A></LI>
<LI><A HREF="#TOC119"><TT>file_rename</TT></A></LI>
<LI><A HREF="#TOC120"><TT>file_delete</TT></A></LI>
<LI><A HREF="#TOC121"><TT>file_exists</TT></A></LI>
<LI><A HREF="#TOC122"><TT>file_where</TT></A></LI>
<LI><A HREF="#TOC123"><TT>file_cycle</TT></A></LI>
<LI><A HREF="#TOC124"><TT>file_cycle_needed</TT></A></LI>
<LI><A HREF="#TOC125"><TT>file_has_changed</TT></A></LI>
<LI><A HREF="#TOC126"><TT>safe_to_extend</TT></A></LI>
<LI><A HREF="#TOC127"><TT>default_extension</TT></A></LI>
<LI><A HREF="#TOC128"><TT>fixed_extension</TT></A></LI>
<LI><A HREF="#TOC129"><TT>strip_extension</TT></A></LI>
<LI><A HREF="#TOC130"><TT>strip_file_path</TT></A></LI>
<LI><A HREF="#TOC131"><TT>strip_file_name</TT></A></LI>
<LI><A HREF="#TOC132"><TT>file_is_readable</TT></A></LI>
<LI><A HREF="#TOC133"><TT>file_is_writeable</TT></A></LI>
<LI><A HREF="#TOC134"><TT>file_is_executable</TT></A></LI>
<LI><A HREF="#TOC135"><TT>file_is_program</TT></A></LI>
<LI><A HREF="#TOC136"><TT>file_is_directory</TT></A></LI>
<LI><A HREF="#TOC137"><TT>file_is_legal</TT></A></LI>
<LI><A HREF="#TOC138"><TT>file_exec_name</TT></A></LI>
<LI><A HREF="#TOC139"><TT>get_file_size</TT></A></LI>
<LI><A HREF="#TOC140"><TT>get_file_time</TT></A></LI>
<LI><A HREF="#TOC141"><TT>get_file_lines</TT></A></LI>
<LI><A HREF="#TOC142"><TT>file_slurp</TT></A></LI>
<LI><A HREF="#TOC143"><TT>file_slurpl</TT></A></LI>
<LI><A HREF="#TOC144"><TT>file_set_eoln</TT></A></LI>
<LI><A HREF="#TOC145"><TT>get_tmp_file_name</TT></A></LI>
</MENU>
<LI><A HREF="#TOC146">Initialisation file access functions</A></LI>
<MENU>
<LI><A HREF="#TOC147"><TT>ini_find_section</TT></A></LI>
<LI><A HREF="#TOC148"><TT>ini_scan_section</TT></A></LI>
<LI><A HREF="#TOC149"><TT>ini_dyn_load</TT></A></LI>
<LI><A HREF="#TOC150"><TT>ini_dyn_save</TT></A></LI>
<LI><A HREF="#TOC151"><TT>ini_dyn_changed</TT></A></LI>
<LI><A HREF="#TOC152"><TT>ini_dyn_refresh</TT></A></LI>
<LI><A HREF="#TOC153"><TT>ini_dyn_value</TT></A></LI>
<LI><A HREF="#TOC154"><TT>ini_dyn_values</TT></A></LI>
</MENU>
<LI><A HREF="#TOC155">Multilanguage support</A></LI>
<MENU>
<LI><A HREF="#TOC156"><TT>set_userlang</TT></A></LI>
<LI><A HREF="#TOC157"><TT>set_userlang_str</TT></A></LI>
<LI><A HREF="#TOC158"><TT>get_userlang</TT></A></LI>
<LI><A HREF="#TOC159"><TT>get_userlang_str</TT></A></LI>
<LI><A HREF="#TOC160"><TT>set_accents</TT></A></LI>
<LI><A HREF="#TOC161"><TT>get_accents</TT></A></LI>
<LI><A HREF="#TOC162"><TT>get_units_name</TT></A></LI>
<LI><A HREF="#TOC163"><TT>get_tens_name</TT></A></LI>
<LI><A HREF="#TOC164"><TT>get_day_name</TT></A></LI>
<LI><A HREF="#TOC165"><TT>get_day_abbrev</TT></A></LI>
<LI><A HREF="#TOC166"><TT>get_month_name</TT></A></LI>
<LI><A HREF="#TOC167"><TT>get_month_abbrev</TT></A></LI>
<LI><A HREF="#TOC168"><TT>timestamp_string</TT></A></LI>
</MENU>
<LI><A HREF="#TOC169">Line buffering functions</A></LI>
<MENU>
<LI><A HREF="#TOC170"><TT>linebuf_create</TT></A></LI>
<LI><A HREF="#TOC171"><TT>linebuf_destroy</TT></A></LI>
<LI><A HREF="#TOC172"><TT>linebuf_reset</TT></A></LI>
<LI><A HREF="#TOC173"><TT>linebuf_append</TT></A></LI>
<LI><A HREF="#TOC174"><TT>linebuf_first</TT></A></LI>
<LI><A HREF="#TOC175"><TT>linebuf_next</TT></A></LI>
<LI><A HREF="#TOC176"><TT>linebuf_last</TT></A></LI>
<LI><A HREF="#TOC177"><TT>linebuf_prev</TT></A></LI>
</MENU>
<LI><A HREF="#TOC178">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC179"><TT>list_unlink</TT></A></LI>
<LI><A HREF="#TOC180"><TT>list_relink</TT></A></LI>
<LI><A HREF="#TOC181"><TT>list_add</TT></A></LI>
<LI><A HREF="#TOC182"><TT>list_remove</TT></A></LI>
<LI><A HREF="#TOC183"><TT>list_sort</TT></A></LI>
</MENU>
<LI><A HREF="#TOC184">SMTP mailer function</A></LI>
<MENU>
<LI><A HREF="#TOC185"><TT>smtp_send_mail_ex</TT></A></LI>
<LI><A HREF="#TOC186"><TT>smtp_send_mail</TT></A></LI>
</MENU>
<LI><A HREF="#TOC187">Mathematic functions</A></LI>
<MENU>
<LI><A HREF="#TOC188"><TT>point_in_rect</TT></A></LI>
<LI><A HREF="#TOC189"><TT>point_in_circle</TT></A></LI>
<LI><A HREF="#TOC190"><TT>point_in_poly</TT></A></LI>
</MENU>
<LI><A HREF="#TOC191">Message-file access functions</A></LI>
<MENU>
<LI><A HREF="#TOC192"><TT>open_message_file</TT></A></LI>
<LI><A HREF="#TOC193"><TT>close_message_file</TT></A></LI>
<LI><A HREF="#TOC194"><TT>print_message</TT></A></LI>
<LI><A HREF="#TOC195"><TT>message_text</TT></A></LI>
</MENU>
<LI><A HREF="#TOC196">Memory allocation functions</A></LI>
<MENU>
<LI><A HREF="#TOC197"><TT>mem_alloc_</TT></A></LI>
<LI><A HREF="#TOC198"><TT>mem_realloc_</TT></A></LI>
<LI><A HREF="#TOC199"><TT>mem_strdup_</TT></A></LI>
<LI><A HREF="#TOC200"><TT>mem_strfree_</TT></A></LI>
<LI><A HREF="#TOC201"><TT>mem_free_</TT></A></LI>
<LI><A HREF="#TOC202"><TT>mem_assert_</TT></A></LI>
<LI><A HREF="#TOC203"><TT>mem_checkall_</TT></A></LI>
<LI><A HREF="#TOC204"><TT>mem_check_</TT></A></LI>
<LI><A HREF="#TOC205"><TT>mem_descr_</TT></A></LI>
<LI><A HREF="#TOC206"><TT>mem_new_trans_</TT></A></LI>
<LI><A HREF="#TOC207"><TT>mem_commit_</TT></A></LI>
<LI><A HREF="#TOC208"><TT>mem_rollback_</TT></A></LI>
<LI><A HREF="#TOC209"><TT>mem_size_</TT></A></LI>
<LI><A HREF="#TOC210"><TT>mem_used</TT></A></LI>
<LI><A HREF="#TOC211"><TT>mem_allocs</TT></A></LI>
<LI><A HREF="#TOC212"><TT>mem_frees</TT></A></LI>
<LI><A HREF="#TOC213"><TT>mem_display</TT></A></LI>
<LI><A HREF="#TOC214"><TT>mem_scavenger</TT></A></LI>
</MENU>
<LI><A HREF="#TOC215">MIME support functions</A></LI>
<MENU>
<LI><A HREF="#TOC216"><TT>encode_base64</TT></A></LI>
<LI><A HREF="#TOC217"><TT>decode_base64</TT></A></LI>
<LI><A HREF="#TOC218"><TT>decode_mime_time</TT></A></LI>
<LI><A HREF="#TOC219"><TT>encode_mime_time</TT></A></LI>
</MENU>
<LI><A HREF="#TOC220">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC221"><TT>node_create</TT></A></LI>
<LI><A HREF="#TOC222"><TT>node_destroy</TT></A></LI>
<LI><A HREF="#TOC223"><TT>node_relink_after</TT></A></LI>
<LI><A HREF="#TOC224"><TT>node_relink_before</TT></A></LI>
<LI><A HREF="#TOC225"><TT>node_unlink</TT></A></LI>
<LI><A HREF="#TOC226"><TT>node_relink</TT></A></LI>
</MENU>
<LI><A HREF="#TOC227">Directory access functions</A></LI>
<MENU>
<LI><A HREF="#TOC228"><TT>open_dir</TT></A></LI>
<LI><A HREF="#TOC229"><TT>read_dir</TT></A></LI>
<LI><A HREF="#TOC230"><TT>close_dir</TT></A></LI>
<LI><A HREF="#TOC231"><TT>format_dir</TT></A></LI>
<LI><A HREF="#TOC232"><TT>fix_dir</TT></A></LI>
<LI><A HREF="#TOC233"><TT>free_dir</TT></A></LI>
<LI><A HREF="#TOC234"><TT>load_dir_list</TT></A></LI>
<LI><A HREF="#TOC235"><TT>free_dir_list</TT></A></LI>
<LI><A HREF="#TOC236"><TT>sort_dir_list</TT></A></LI>
<LI><A HREF="#TOC237"><TT>add_dir_list</TT></A></LI>
<LI><A HREF="#TOC238"><TT>resolve_path</TT></A></LI>
<LI><A HREF="#TOC239"><TT>locate_path</TT></A></LI>
<LI><A HREF="#TOC240"><TT>clean_path</TT></A></LI>
<LI><A HREF="#TOC241"><TT>get_curdir</TT></A></LI>
<LI><A HREF="#TOC242"><TT>set_curdir</TT></A></LI>
<LI><A HREF="#TOC243"><TT>file_matches</TT></A></LI>
<LI><A HREF="#TOC244"><TT>make_dir</TT></A></LI>
<LI><A HREF="#TOC245"><TT>remove_dir</TT></A></LI>
</MENU>
<LI><A HREF="#TOC246">Process control functions</A></LI>
<MENU>
<LI><A HREF="#TOC247"><TT>process_create</TT></A></LI>
<LI><A HREF="#TOC248"><TT>process_status</TT></A></LI>
<LI><A HREF="#TOC249"><TT>process_kill</TT></A></LI>
<LI><A HREF="#TOC250"><TT>process_close</TT></A></LI>
<LI><A HREF="#TOC251"><TT>process_server</TT></A></LI>
<LI><A HREF="#TOC252"><TT>process_alarm</TT></A></LI>
<LI><A HREF="#TOC253"><TT>process_esc</TT></A></LI>
<LI><A HREF="#TOC254"><TT>process_unesc</TT></A></LI>
<LI><A HREF="#TOC255"><TT>process_priority</TT></A></LI>
</MENU>
<LI><A HREF="#TOC256">Time-slot functions</A></LI>
<MENU>
<LI><A HREF="#TOC257"><TT>year_range_empty</TT></A></LI>
<LI><A HREF="#TOC258"><TT>year_range_fill</TT></A></LI>
<LI><A HREF="#TOC259"><TT>year_slot_clear</TT></A></LI>
<LI><A HREF="#TOC260"><TT>year_slot_set</TT></A></LI>
<LI><A HREF="#TOC261"><TT>year_slot_filled</TT></A></LI>
<LI><A HREF="#TOC262"><TT>day_range_empty</TT></A></LI>
<LI><A HREF="#TOC263"><TT>day_range_fill</TT></A></LI>
<LI><A HREF="#TOC264"><TT>day_slot_clear</TT></A></LI>
<LI><A HREF="#TOC265"><TT>day_slot_set</TT></A></LI>
<LI><A HREF="#TOC266"><TT>day_slot_filled</TT></A></LI>
<LI><A HREF="#TOC267"><TT>date_to_day</TT></A></LI>
<LI><A HREF="#TOC268"><TT>time_to_min</TT></A></LI>
</MENU>
<LI><A HREF="#TOC269">String-handling functions</A></LI>
<MENU>
<LI><A HREF="#TOC270"><TT>strdupl</TT></A></LI>
<LI><A HREF="#TOC271"><TT>strfree</TT></A></LI>
<LI><A HREF="#TOC272"><TT>strskp</TT></A></LI>
<LI><A HREF="#TOC273"><TT>strcset</TT></A></LI>
<LI><A HREF="#TOC274"><TT>strpad</TT></A></LI>
<LI><A HREF="#TOC275"><TT>strlwc</TT></A></LI>
<LI><A HREF="#TOC276"><TT>strupc</TT></A></LI>
<LI><A HREF="#TOC277"><TT>strcrop</TT></A></LI>
<LI><A HREF="#TOC278"><TT>stropen</TT></A></LI>
<LI><A HREF="#TOC279"><TT>strclose</TT></A></LI>
<LI><A HREF="#TOC280"><TT>strunique</TT></A></LI>
<LI><A HREF="#TOC281"><TT>strmatch</TT></A></LI>
<LI><A HREF="#TOC282"><TT>strprefixed</TT></A></LI>
<LI><A HREF="#TOC283"><TT>strprefix</TT></A></LI>
<LI><A HREF="#TOC284"><TT>strdefix</TT></A></LI>
<LI><A HREF="#TOC285"><TT>strhash</TT></A></LI>
<LI><A HREF="#TOC286"><TT>strconvch</TT></A></LI>
<LI><A HREF="#TOC287"><TT>xstrcat</TT></A></LI>
<LI><A HREF="#TOC288"><TT>xstrcpy</TT></A></LI>
<LI><A HREF="#TOC289"><TT>lexcmp</TT></A></LI>
<LI><A HREF="#TOC290"><TT>lexncmp</TT></A></LI>
<LI><A HREF="#TOC291"><TT>lexwcmp</TT></A></LI>
<LI><A HREF="#TOC292"><TT>soundex</TT></A></LI>
<LI><A HREF="#TOC293"><TT>soundexn</TT></A></LI>
<LI><A HREF="#TOC294"><TT>strt2descr</TT></A></LI>
<LI><A HREF="#TOC295"><TT>descr2strt</TT></A></LI>
<LI><A HREF="#TOC296"><TT>strtfree</TT></A></LI>
<LI><A HREF="#TOC297"><TT>removechars</TT></A></LI>
<LI><A HREF="#TOC298"><TT>replacechrswith</TT></A></LI>
<LI><A HREF="#TOC299"><TT>insertstring</TT></A></LI>
<LI><A HREF="#TOC300"><TT>insertchar</TT></A></LI>
<LI><A HREF="#TOC301"><TT>leftfill</TT></A></LI>
<LI><A HREF="#TOC302"><TT>rightfill</TT></A></LI>
<LI><A HREF="#TOC303"><TT>trim</TT></A></LI>
<LI><A HREF="#TOC304"><TT>ltrim</TT></A></LI>
<LI><A HREF="#TOC305"><TT>searchreplace</TT></A></LI>
<LI><A HREF="#TOC306"><TT>deletestring</TT></A></LI>
<LI><A HREF="#TOC307"><TT>getstrfld</TT></A></LI>
<LI><A HREF="#TOC308"><TT>setstrfld</TT></A></LI>
<LI><A HREF="#TOC309"><TT>getstrfldlen</TT></A></LI>
<LI><A HREF="#TOC310"><TT>findstrinfile</TT></A></LI>
<LI><A HREF="#TOC311"><TT>getequval</TT></A></LI>
<LI><A HREF="#TOC312"><TT>matchtable</TT></A></LI>
<LI><A HREF="#TOC313"><TT>stringreplace</TT></A></LI>
<LI><A HREF="#TOC314"><TT>wordwrapstr</TT></A></LI>
<LI><A HREF="#TOC315"><TT>stricstr</TT></A></LI>
<LI><A HREF="#TOC316"><TT>strtempcmp</TT></A></LI>
<LI><A HREF="#TOC317"><TT>istoken</TT></A></LI>
<LI><A HREF="#TOC318"><TT>eatstr</TT></A></LI>
<LI><A HREF="#TOC319"><TT>eatstrpast</TT></A></LI>
<LI><A HREF="#TOC320"><TT>movestrpast</TT></A></LI>
<LI><A HREF="#TOC321"><TT>eatchar</TT></A></LI>
<LI><A HREF="#TOC322"><TT>isoneoftokens</TT></A></LI>
</MENU>
<LI><A HREF="#TOC323">TCP/IP, UDP/IP socket functions</A></LI>
<MENU>
<LI><A HREF="#TOC324"><TT>sock_init</TT></A></LI>
<LI><A HREF="#TOC325"><TT>sock_term</TT></A></LI>
<LI><A HREF="#TOC326"><TT>passive_TCP</TT></A></LI>
<LI><A HREF="#TOC327"><TT>passive_UDP</TT></A></LI>
<LI><A HREF="#TOC328"><TT>passive_socket</TT></A></LI>
<LI><A HREF="#TOC329"><TT>create_socket</TT></A></LI>
<LI><A HREF="#TOC330"><TT>connect_TCP</TT></A></LI>
<LI><A HREF="#TOC331"><TT>connect_UDP</TT></A></LI>
<LI><A HREF="#TOC332"><TT>connect_TCP_fast</TT></A></LI>
<LI><A HREF="#TOC333"><TT>connect_UDP_fast</TT></A></LI>
<LI><A HREF="#TOC334"><TT>connect_socket</TT></A></LI>
<LI><A HREF="#TOC335"><TT>connect_to_peer</TT></A></LI>
<LI><A HREF="#TOC336"><TT>address_end_point</TT></A></LI>
<LI><A HREF="#TOC337"><TT>build_sockaddr</TT></A></LI>
<LI><A HREF="#TOC338"><TT>socket_localaddr</TT></A></LI>
<LI><A HREF="#TOC339"><TT>socket_peeraddr</TT></A></LI>
<LI><A HREF="#TOC340"><TT>socket_nodelay</TT></A></LI>
<LI><A HREF="#TOC341"><TT>socket_is_alive</TT></A></LI>
<LI><A HREF="#TOC342"><TT>socket_error</TT></A></LI>
<LI><A HREF="#TOC343"><TT>accept_socket</TT></A></LI>
<LI><A HREF="#TOC344"><TT>connect_error</TT></A></LI>
<LI><A HREF="#TOC345"><TT>get_sock_addr</TT></A></LI>
<LI><A HREF="#TOC346"><TT>get_peer_addr</TT></A></LI>
<LI><A HREF="#TOC347"><TT>read_TCP</TT></A></LI>
<LI><A HREF="#TOC348"><TT>write_TCP</TT></A></LI>
<LI><A HREF="#TOC349"><TT>read_UDP</TT></A></LI>
<LI><A HREF="#TOC350"><TT>write_UDP</TT></A></LI>
<LI><A HREF="#TOC351"><TT>close_socket</TT></A></LI>
<LI><A HREF="#TOC352"><TT>sock_select</TT></A></LI>
<LI><A HREF="#TOC353"><TT>get_hostname</TT></A></LI>
<LI><A HREF="#TOC354"><TT>get_hostaddr</TT></A></LI>
<LI><A HREF="#TOC355"><TT>get_hostaddrs</TT></A></LI>
<LI><A HREF="#TOC356"><TT>sock_ntoa</TT></A></LI>
<LI><A HREF="#TOC357"><TT>sockmsg</TT></A></LI>
<LI><A HREF="#TOC358"><TT>winsock_last_error</TT></A></LI>
<LI><A HREF="#TOC359"><TT>socket_is_permitted</TT></A></LI>
<LI><A HREF="#TOC360"><TT>get_host_file</TT></A></LI>
<LI><A HREF="#TOC361"><TT>get_name_server</TT></A></LI>
</MENU>
<LI><A HREF="#TOC362">Symbol-table functions</A></LI>
<MENU>
<LI><A HREF="#TOC363"><TT>sym_create_table_</TT></A></LI>
<LI><A HREF="#TOC364"><TT>sym_delete_table</TT></A></LI>
<LI><A HREF="#TOC365"><TT>sym_empty_table</TT></A></LI>
<LI><A HREF="#TOC366"><TT>sym_merge_tables</TT></A></LI>
<LI><A HREF="#TOC367"><TT>sym_lookup_symbol</TT></A></LI>
<LI><A HREF="#TOC368"><TT>sym_create_symbol_</TT></A></LI>
<LI><A HREF="#TOC369"><TT>sym_assume_symbol_</TT></A></LI>
<LI><A HREF="#TOC370"><TT>sym_delete_symbol</TT></A></LI>
<LI><A HREF="#TOC371"><TT>sym_exec_all</TT></A></LI>
<LI><A HREF="#TOC372"><TT>sym_hash</TT></A></LI>
<LI><A HREF="#TOC373"><TT>sym_get_value</TT></A></LI>
<LI><A HREF="#TOC374"><TT>sym_get_number</TT></A></LI>
<LI><A HREF="#TOC375"><TT>sym_get_boolean</TT></A></LI>
<LI><A HREF="#TOC376"><TT>sym_set_value</TT></A></LI>
<LI><A HREF="#TOC377"><TT>sym_sort_table</TT></A></LI>
<LI><A HREF="#TOC378"><TT>symb2strt_</TT></A></LI>
<LI><A HREF="#TOC379"><TT>strt2symb_</TT></A></LI>
<LI><A HREF="#TOC380"><TT>symb2descr_</TT></A></LI>
<LI><A HREF="#TOC381"><TT>descr2symb_</TT></A></LI>
</MENU>
<LI><A HREF="#TOC382">System-level functions (assertions,...)</A></LI>
<MENU>
<LI><A HREF="#TOC383"><TT>sys_assert</TT></A></LI>
<LI><A HREF="#TOC384"><TT>sys_name</TT></A></LI>
</MENU>
<LI><A HREF="#TOC385">HTTP and CGI Support functions</A></LI>
<MENU>
<LI><A HREF="#TOC386"><TT>http_escape</TT></A></LI>
<LI><A HREF="#TOC387"><TT>http_escape_size</TT></A></LI>
<LI><A HREF="#TOC388"><TT>http_unescape</TT></A></LI>
<LI><A HREF="#TOC389"><TT>http_query2strt</TT></A></LI>
<LI><A HREF="#TOC390"><TT>http_query2symb</TT></A></LI>
<LI><A HREF="#TOC391"><TT>http_query2descr</TT></A></LI>
<LI><A HREF="#TOC392"><TT>http_encode_meta</TT></A></LI>
<LI><A HREF="#TOC393"><TT>cgi_parse_query_vars</TT></A></LI>
<LI><A HREF="#TOC394"><TT>cgi_parse_file_vars</TT></A></LI>
<LI><A HREF="#TOC395"><TT>http_multipart_decode</TT></A></LI>
<LI><A HREF="#TOC396"><TT>is_full_url</TT></A></LI>
<LI><A HREF="#TOC397"><TT>cgi_get_input</TT></A></LI>
<LI><A HREF="#TOC398"><TT>cgi_fld_by_name</TT></A></LI>
<LI><A HREF="#TOC399"><TT>cgi_fld_by_index</TT></A></LI>
<LI><A HREF="#TOC400"><TT>cgi_fld_len_by_index</TT></A></LI>
<LI><A HREF="#TOC401"><TT>displayform</TT></A></LI>
</MENU>
<LI><A HREF="#TOC402">Environment variable functions</A></LI>
<MENU>
<LI><A HREF="#TOC403"><TT>env_get_string</TT></A></LI>
<LI><A HREF="#TOC404"><TT>env_get_number</TT></A></LI>
<LI><A HREF="#TOC405"><TT>env_get_boolean</TT></A></LI>
<LI><A HREF="#TOC406"><TT>env2descr</TT></A></LI>
<LI><A HREF="#TOC407"><TT>descr2env</TT></A></LI>
<LI><A HREF="#TOC408"><TT>env2symb</TT></A></LI>
<LI><A HREF="#TOC409"><TT>symb2env</TT></A></LI>
</MENU>
<LI><A HREF="#TOC410">String token manipulation functions.</A></LI>
<MENU>
<LI><A HREF="#TOC411"><TT>tok_split</TT></A></LI>
<LI><A HREF="#TOC412"><TT>tok_split_rich</TT></A></LI>
<LI><A HREF="#TOC413"><TT>tok_free</TT></A></LI>
<LI><A HREF="#TOC414"><TT>tok_push</TT></A></LI>
<LI><A HREF="#TOC415"><TT>tok_size</TT></A></LI>
<LI><A HREF="#TOC416"><TT>tok_text_size</TT></A></LI>
<LI><A HREF="#TOC417"><TT>tok_subst</TT></A></LI>
</MENU>
<LI><A HREF="#TOC418">Linked-list functions</A></LI>
<MENU>
<LI><A HREF="#TOC419"><TT>tree_init</TT></A></LI>
<LI><A HREF="#TOC420"><TT>tree_insert</TT></A></LI>
<LI><A HREF="#TOC421"><TT>tree_delete</TT></A></LI>
<LI><A HREF="#TOC422"><TT>tree_find</TT></A></LI>
<LI><A HREF="#TOC423"><TT>tree_traverse</TT></A></LI>
<LI><A HREF="#TOC424"><TT>tree_first</TT></A></LI>
<LI><A HREF="#TOC425"><TT>tree_last</TT></A></LI>
<LI><A HREF="#TOC426"><TT>tree_next</TT></A></LI>
<LI><A HREF="#TOC427"><TT>tree_prev</TT></A></LI>
</MENU>
<LI><A HREF="#TOC428">Tracing functions</A></LI>
<MENU>
<LI><A HREF="#TOC429"><TT>enable_trace</TT></A></LI>
<LI><A HREF="#TOC430"><TT>disable_trace</TT></A></LI>
<LI><A HREF="#TOC431"><TT>push_trace</TT></A></LI>
<LI><A HREF="#TOC432"><TT>pop_trace</TT></A></LI>
<LI><A HREF="#TOC433"><TT>set_trace_file</TT></A></LI>
<LI><A HREF="#TOC434"><TT>trace</TT></A></LI>
</MENU>
<LI><A HREF="#TOC435">Process user id (uid) and group id (gid) functions</A></LI>
<MENU>
<LI><A HREF="#TOC436"><TT>get_uid_name</TT></A></LI>
<LI><A HREF="#TOC437"><TT>get_gid_name</TT></A></LI>
<LI><A HREF="#TOC438"><TT>set_uid_user</TT></A></LI>
<LI><A HREF="#TOC439"><TT>set_uid_root</TT></A></LI>
<LI><A HREF="#TOC440"><TT>set_gid_user</TT></A></LI>
<LI><A HREF="#TOC441"><TT>set_gid_root</TT></A></LI>
<LI><A HREF="#TOC442"><TT>set_uid_gid</TT></A></LI>
<LI><A HREF="#TOC443"><TT>get_login</TT></A></LI>
</MENU>
<LI><A HREF="#TOC444">XML (Extensible Markup Language) access functions</A></LI>
<MENU>
<LI><A HREF="#TOC445"><TT>xml_new</TT></A></LI>
<LI><A HREF="#TOC446"><TT>xml_modify_value</TT></A></LI>
<LI><A HREF="#TOC447"><TT>xml_item_name</TT></A></LI>
<LI><A HREF="#TOC448"><TT>xml_item_value</TT></A></LI>
<LI><A HREF="#TOC449"><TT>xml_free</TT></A></LI>
<LI><A HREF="#TOC450"><TT>xml_first_child</TT></A></LI>
<LI><A HREF="#TOC451"><TT>xml_next_sibling</TT></A></LI>
<LI><A HREF="#TOC452"><TT>xml_parent</TT></A></LI>
<LI><A HREF="#TOC453"><TT>xml_put_attr</TT></A></LI>
<LI><A HREF="#TOC454"><TT>xml_attr</TT></A></LI>
<LI><A HREF="#TOC455"><TT>xml_attr_name</TT></A></LI>
<LI><A HREF="#TOC456"><TT>xml_attr_value</TT></A></LI>
<LI><A HREF="#TOC457"><TT>xml_get_attr</TT></A></LI>
<LI><A HREF="#TOC458"><TT>xml_free_attr</TT></A></LI>
<LI><A HREF="#TOC459"><TT>xml_first_attr</TT></A></LI>
<LI><A HREF="#TOC460"><TT>xml_next_attr</TT></A></LI>
<LI><A HREF="#TOC461"><TT>xml_changed</TT></A></LI>
<LI><A HREF="#TOC462"><TT>xml_refresh</TT></A></LI>
<LI><A HREF="#TOC463"><TT>xml_save</TT></A></LI>
<LI><A HREF="#TOC464"><TT>xml_error</TT></A></LI>
<LI><A HREF="#TOC465"><TT>xml_load</TT></A></LI>
</MENU>
</MENU>

<H2><A NAME="TOC1">What Is The SFL</A></H2>

<H3><A NAME="TOC2">Origins</A></H3>

<P>At iMatix we develop portable free and commercial software.
We work in ANSI C to cover the widest range possible.  A major
part of our toolkit has always been our subroutine library.  This
was initially written for MS-DOS in 1991 but has developed into a
more ambitious project since then.

<P>From the outset, we ignored commercial libraries.  Our
software is usually free - as in 'liberated' rather than 'gratis'
- and using a commercial library would have been intolerable.  We
looked for free libraries, but found only specialised and mostly
non-portable collections of functions.  So, we built our own.  We
hope you like it.  We certainly use it all the time.

<H3><A NAME="TOC3">Objectives</A></H3>

<P>When we designed the SFL, we had certain things in mind:
<UL>
<LI>Portability: we are lazy, and don't have much time.  So, we
want to do our editing and testing on the fastest PC possible,
then move the results to a 'real' system (UNIX, VMS, whatever)
recompile, and test.  Obviously, some code cannot be tested fully
on all systems - we don't have sockets under MS-DOS - but this
approach works for most projects.  The SFL <EM>encapsulates</EM>
non-portable aspects so that application programs do not need to
know about specific systems.

<LI>Building servers, i.e. programs that run in the background,
for a long time, without intervention from a user or operator.
Servers have specific needs, and must be extremely robust, since
they must run for long periods.  The SFL provides many functions
that are specifically meant for this type of program.

<LI>Functionality: the classic purpose of any library.  If a
problem has a clean, tested, documented, and portable solution, we
will use that instead of re-inventing it.  The SFL provides a
stable home for code that might otherwise float around in various
projects.

<LI>Discipline: we make our code public, and expect people to read
it.  We actually include the code for each function as part of its
documentation.  This forces us to be crystal clear.

<LI>Hubris: we think our code is so great that it should live for
ever.  So, we take great pains to make it useful, clean,
efficient, and well-packaged, so you'll think so too.
</UL>

<H3><A NAME="TOC4">Portability</A></H3>

<P>The SFL is in use on these systems:
<UL>
<LI>MS-DOS (MSVC, Borland Turbo-C)
<LI>MS-Windows (MSVC)
<LI>Linux (GNU gcc)
<LI>IBM RS/6000 AIX
<LI>Sun SunOS
<LI>Sun Solaris
<LI>HP HP/UX
<LI>Digital UNIX (ex-OSF/1)
<LI>FreeBSD
<LI>NetBSD
<LI>SCO OpenServer
<LI>SCO UnixWare
<LI>Digital OpenVMS
</UL>

<P>Some recent functions may not have been tested or implemented
across all platforms.  Some functions are empty on some platforms.
Since the SFL is continually improving and enlarging, there are
always newer functions that are less tested, and possibly less
than 100% portable.  Our intention is that the transparency of the
SFL makes these functions easy to test and improve.

<H2><A NAME="TOC5">Installing The SFL</A></H2>

<H3><A NAME="TOC6">Availability and Distribution</A></H3>

<P>We supply the SFL as two archives: a source kit and a
documentation kit (in HTML).  These files are available for
download by HTTP from our <A HREF="http://www.imatix.com/">website</A> on a permanent basis.
You need to recompile the SFL for your specific system, using an
ANSI C compiler.  We don't provide binary kits (as yet) for
several reasons:
<UL>
<LI>With one source archive and one documentation archive, the
SFL is easier to distribute.
<LI>The SFL changes rapidly - a source distribution is simpler.
<LI>You can pick and choose the functions you want.
<LI>The sources are the primary source of documentation.
<LI>The license terms are such that the sources must be supplied
or be available in any case.
</UL>

<H4>Getting The Source Archive</H4>

<P>The SFL source archive is supplied as a <A HREF="/pub/sfl/src/sflsrc21.zip">zip file</A>
and a <A HREF="/pub/sfl/src/sflsrc21.tgz">GNU gzip+tar file</A>.  These are the files in
the /pub/sfl/src directory:
<PRE>
<a href="/pub/sfl/src/sflsrc21.tgz">sflsrc21.tgz</a>   308722 98/04/25 10:17:16  Gzip/tar archive
<a href="/pub/sfl/src/sflsrc21.zip">sflsrc21.zip</a>   385323 98/07/25 23:28:32  ZIP archive
</PRE>

<P>If you have trouble accessing the iMatix site, send us an
<A HREF="mailto:info@imatix.com">e-mail</A> and we'll send you the SFL archives by return
e-mail, using the uuencode format.

<H4>Getting The The Documentation Kit</H4>

<P>The SFL documentation is supplied as HTML files, available on-line or
off-line as a <A HREF="/pub/sfl/doc/sfldoc21.zip">single .zip file</A> that you can install on a hard
disk for rapid access, and also as a <A HREF="/pub/sfl/doc/sfldoc21.tgz">GNU gzipped file</A>.
These are the files in the /pub/sfl/doc directory:
<PRE>
<a href="/pub/sfl/doc/sflbig21.tgz">sflbig21.tgz</a>   184689 98/04/25 10:17:22  Gzip/tar archive
<a href="/pub/sfl/doc/sflbig21.zip">sflbig21.zip</a>   190376 98/07/25 23:28:36  ZIP archive
<a href="/pub/sfl/doc/sfldoc21.tgz">sfldoc21.tgz</a>   217445 98/04/25 10:17:18  Gzip/tar archive
<a href="/pub/sfl/doc/sfldoc21.zip">sfldoc21.zip</a>   571527 98/07/25 23:28:36  ZIP archive
</PRE>

<P>We recommend that you unzip or gunzip/detar the archive into a
subdirectory.  Point your browser at the <TT>index.htm</TT> file.
We use relative addressing in all HTML documents, so that links
work just as well on a local hard-disk as on-line on our website.
In a windowing environment is it easy and useful to create an icon
that runs a Web browser on this file.

<HR>
<H3><A NAME="TOC7">Installation for UNIX Systems</A></H3>

<P>To install the SFL on a UNIX system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run the 'build' script to compile the SFL sources and build
the libsfl.a archive file.
<LI>Optionally, install the libsfl.a file in the /usr/lib
directory.
<LI>Optionally, install the SFL header file(s) in the /usr/include
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A HREF="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A HREF="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool:
<PRE>$ mkdir temp
$ mv sflsrc21.zip temp
$ cd temp
$ unzip -a sflsrc21
</PRE>

<P>To decompress the <A HREF="/pub/sfl/src/sflsrc21.tgz">source .tgz file</A> you need GNU
gzip/gunzip and tar:
<PRE>$ mkdir temp
$ mv sflsrc21.tgz temp
$ cd temp
$ gzip -d sflsrc21.tgz
  or
$ gunzip sflsrc21.tgz
$ tar -xvf sflsrc21.tar
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the UNIX system.

<H4>Compiling The SFL Sources</H4>

<P>The SFL source archive includes a script, <TT><B>c</B></TT>,
that you can (and should) use to compile the SFL sources.  This
script invokes the ANSI C compiler to produce an object code file.
It detects the platform and invokes the compiler with the
necessary switches for ANSI C compilation.  On some systems this
is the normal behaviour for the <B>cc</B> command.  On other
systems it is not normal.  You should make the <TT>c</TT> script
executable, (preferrably) install it in a shared directory like
/usr/local/bin, and try it out:
<PRE>$ chmod a+rx c
$ mv c /usr/local/bin
$ c
</PRE>

<P>To compile the SFL sources, use this command:
<PRE>$ chmod +x build
$ build
</PRE>

<P>If you get warnings or error messages, this is usually a bad
sign.  Some compilers issue warnings just because you ask for ANSI
compilation.  If you get any other error messages, please let us
know.

<P>You can use individual SFL files simply by specifying them on
the command line when you compile and link a program.  However,
this is usually a pain.  Therefore, the build script creates a
library file called libsfl.a.  The linker can automatically search
this file for the SFL functions.  To install libsfl.a in the
/usr/lib directory, do this:
<PRE>$ mv libsfl.a /usr/lib
</PRE>

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A HREF="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A HREF="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in
/usr/include.  A typical application program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<P>To link an application program, use the <TT>c -l</TT> command.
This assumes that libsfl.a is installed /usr/lib.

<HR>
<H3><A NAME="TOC8">Installation for Digital VMS Systems</A></H3>

<P>To install the SFL on a Digital VMS system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run the 'build.txt' command file to build the libsfl.olb
library file.
<LI>Optionally, install the libsfl.olb file in the SYS$LIBRARY
directory.
<LI>Optionally, install the SFL header file(s) in the SYS$LIBRARY
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A HREF="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A HREF="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool (note that you need the -a switch):
<PRE>$ create/dir [.temp]
$ ren sflsrc21.zip [.temp]
$ set def [.temp]
$ unzip -a sflsrc21
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the VMS system.

<H4>Compiling The SFL Sources</H4>

<P>To compile the SFL sources, use this command:
<PRE>$ @build.txt
</PRE>

<P>If you get warnings or error messages, this is a bad sign -
please let us know.

<P>The build.txt command file creates a library file called
libsfl.olb.  You can install this in a central directory like
SYS$LIBRARY if you wish.  You'll need system privileges to do
this.

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A HREF="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A HREF="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in
SYS$LIBRARY.  A typical application program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<HR>
<H3><A NAME="TOC9">Installation for Windows</A></H3>

<P>Briefly, either create a static library, and include that in
your project; create a .DLL and call that, or add the files you
want to use to your project and compile them as part of the
application.

<P>With MSVC 4.0, we find it useful to create a main project
for the application in hand, and a subproject for the SFL.  We
build the SFL as a static library.  If you use MFC, you must
compile everything (including MFC) in single-threaded mode, and
use libd.

<P>Under MSVC 1.5x, there is a bug in the project manager that
generates invalid make files: the SFL prelude.h file refers to
various non-Windows include files, within #if statements.  The
MSVC 1.5x project manager includes these in the make file; you
must manually remove them.  One solution is to edit prelude.h;
another is to use a Perl or Awk script to edit the make file
each time you change the project.  You could also move to a
different 16-bit compiler.  Finally, you can create the make
files as empty files in the C include directory.

<HR>
<H3><A NAME="TOC10">Installation for MS-DOS</A></H3>

<P>To install the SFL on a MS-DOS system you need to:
<OL>
<LI>Download the source archive and decompress it.
<LI>Run build.bat to build the libsfl.lib library file.
<LI>Optionally, install the libsfl.lib file in central
directory.
<LI>Optionally, install the SFL header file(s) in a central
directory.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A HREF="/pub/sfl/src/sflsrc21.zip">source .zip file</A>, you need the Infozip
<A HREF="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool, or PKzip version 2.04g or later, or a
compatible unzip program.:
<PRE>C:\DOWNLOAD> md temp
C:\DOWNLOAD> copy sflsrc21.zip temp
C:\DOWNLOAD> del sflsrc21.zip
C:\DOWNLOAD> cd temp
C:\DOWNLOAD> unzip sflsrc21
</PRE>

<H4>Compiling The SFL Sources</H4>

<P>These build scripts are provided for MS-DOS:
<UL>
<LI><TT>build.bat</TT>, for generic MS-DOS.  You will need to
modify this script to adjust the 'c', 'lib', and 'linkup'
commands for your compiler.
<LI><TT>buildms.bat</TT>, for MS Visual C/C++.  This script
assumes that the %INC variable points to the MSVC include
directory.
<LI><TT>buildtc.bat</TT>, for Borland Turbo C/C++.  This script
assumes that the %INC variable points to the Turbo C/C++ include
directory and the %LIB variable points to the Turbo C/C++
library directory.
</UL>

<P>The build scripts create a library file called libsfl.lib.
You can install this, and sfl.h, in a central directory if you
wish.

<H4>Using The SFL In Your Applications</H4>

<P>To use an SFL function in your applications you must include a
header file that defines the structures, prototypes, and types for
the function API.  The SFL provides three types of header
files:
<OL>
<LI>One header file per function group.  These are provided for
reference; you will normally not use these directly.
<LI>A <A HREF="sfldoc.htm#uhf">Universal Header File</A> which encapsulates and
replaces all local header files.  Again, this is provided for
reference; you do not normally use this directly.
<LI>A <A HREF="sfldoc.htm#lhf">Library Header File</A> that contains the Universal
Header File and all the SFL header files in one go.  This is meant
to simplify application programming and installation.
</OL>

<P>We recommend that you install the <TT>sfl.h</TT> file in the
/include directory of your compiler.  A typical application
program starts like this:
<PRE>#include &lt;sfl.h&gt;
</PRE>

<H2><A NAME="TOC11">Using The SFL</A></H2>

<A NAME="uhf">&nbsp;</A>
<H3><A NAME="TOC12">The Universal Header File - prelude.h</A></H3>

<H4>What and Why?</H4>

<P>The Universal Header File a technology that we have developed
to make C applications more easily portable with less effort.  One
of the big difficulties in compiling C code on different platforms
is that header files change their names, locations, and internal
functions from system to system, even on one system over time.

<P>Typically, you may see C programs that start with a rash of
<TT>#ifdef</TT>'s mixed with <TT>#include</TT>'s depending on the
system, compiler, and specific needs of the program.

<P>Since we are basically really lazy, all this unnecessary work
is intolerable.  We would <EM>much</EM> rather make the compiler
work harder.  The systems we develop on (typically MS-DOS with
Turbo-C) are so fast that we can afford to take a really lazy
approach.

<P>So, what we do is this: we include every 'useful' and
'standard' header file that we can think of.  We then include
every 'useful' non-portable file that we've ever needed, in a
clean way, so that application code does not need to 'know' how it
was done.

<P>At the same time we define lots of things that make life
easier.  Generally we don't like macros, since these create
'pseudo languages' that are just more work to learn.  However,
some things (like <TT>#define FOREVER for (;;)</TT>) are so useful
and pretty comonplace, so we stick them in too.

<P>Lastly, we flatten-out the problem called 'what system am I
running on', by providing a set of definitions like
<TT>__UNIX__</TT> and <TT>__UTYPE_SUNOS</TT> that code can use if
it has to.  Again, it can be quite messy to figure-out that we're
compiling on a Brand X, so we need this-and-that header file.  We
hide this so that we can forget about it.

<P>Okay, those are the benefits of this approach.  What are the
costs?  We typically hear these criticisms:
<UL>
<LI>Compilation is a <EM>lot</EM> slower.  True, but when you
create portable applications, you can do 90% of your compiles on a
system that is so fast that this is irrelevant
<LI>Some C programmers may feel they are losing control over which
header files are included, in which order, etc.  True, but it's
the kind of control we don't want.
<LI>We get some comments about 'polluting the namespace'.  We
don't really understand this one.  We try to stay away from
already-defined symbols.
<LI>People don't like the macros we define, like TRUE and FALSE.
This can become a matter of personal choice; we've tried to
provide useful stuff without becoming baroque.
</UL>

<P>We use the Universal Header File in <EM>all</EM> C projects
(not just those based on the SFL).  If it was not for the simple
fact that it has helped us a lot, we'd probably not make it
available.

<H4>Using the Universal Header File</H4>

<P>You should probably read through the <TT>prelude.h</TT> file to
best understand it.  Our usual habit is to comment the code first,
so that it's self-explanatory.  The SFL documentation has a
section on the Universal Header File.  This section is generated
from the code.

<P>When you use the SFL Library Header File (<TT>sfl.h</TT>), you
don't need to include <TT>prelude.h</TT>, since it's already
embedded in <TT>sfl.h</TT>.  This makes application programming
easier (just one header file to include).  If you need to change
<TT>prelude.h</TT>, you can either change <TT>sfl.h</TT> as well,
or rebuild <TT>sfl.h</TT> using the build script.  Better still,
tell us what you want to change, so that we can maintain a single
version of the file.

<A NAME="lhf">&nbsp;</A>
<H3><A NAME="TOC13">The Library Header File - sfl.h</A></H3>

<P>Each module in the SFL consists of a header file and one or
more C source files.  You can choose to include the header files
that you want (this is what the SFL source code does), but this
can quickly become burdensome.  To simplify matters, a single
header file <TT>sfl.h</TT> contains all the individual header
files.  It also contains the Universal Header File.

<H3><A NAME="TOC14">System Notes</A></H3>

<H4>MS-DOS</H4>

<P>Most of the SFL is portable to MS-DOS.  Exceptions are: the
socket i/o functions (sflsock), the user/group ID functions
(sfluid) and the server process functions (sflserv).  These are
all null; you can call any of the functions, but they will return
either an okay feedback (in most cases) or an error feedback (for
the socket functions).  The SFL compiles cleanly with Borland
Turbo C/C++ 1.0 and Microsoft VC++ 4.0; it has not been tested
with Borland C/C++.

<H4>MS-Windows</H4>

<P>Most of the SFL is portable to Windows 3.x, Windows 95, and
Windows NT.  Exceptions are: the user/group ID functions (sfluid)
and the server process functions (sflserv).  These are all null;
you can call any of the functions, but they will return an okay
feedback.  The SFL compiles cleanly with Microsoft VC++ 4.0; it
has not been tested with Borland C/C++.

<H4>Digital VAX</H4>

<P>The SFL is portable to Digital VMS except for the directory
access functions (sfldir), user/group functions (sfluid) and the
server process functions (sflserv).  The sfldir functions will be
implemented at a later date.  The other functions are null; you
can call any of the functions, but they will return an okay
feedback.  The SFL compiles cleanly with Vax C and Dec C and has
been tested with various releases of these compilers.

<H4>Linux</H4>

<P>The SFL is fully portable to Linux and has been tested with GNU
C.  It should give no compiler warning errors.

<H4>Sun OS and Sun Sparc</H4>

<P>The SFL is fully portable to Sun OS.  You may have trouble
finding an ANSI C compiler, especially on Sparc systems.  People
sometimes install GNU C, using the Sun header files and libraries.
This should work, although we have not tested it recently.
Sometimes the Sun ANSI C compiler is called acc, not cc.  You can
use the CCNAME environment variable to point to the right compiler
name.  Some Sun C compilers give warnings when you use the ANSI
compile mode.  You can ignore these warnings.

<P>See also the warning about 'Other UNIX Systems'; some SunOS
installations show this symptom.

<H4>HP/UX</H4>

<P>The SFL is fully portable to HP/UX.  It should give no compiler
warning errors.

<H4>IBM AIX</H4>

<P>The SFL is fully portable to IBM/AIX.  It should give no
compiler warning errors.

<H4>Digital UNIX</H4>

<P>The SFL is fully portable to Digital UNIX.  It should give no
compiler warning errors.  When compiling on an Alpha system, the
word size is 64 bits.

<H4>Other UNIX Systems</H4>

<P>The directory functions can fail on SVr4 if the &lt;dirent.h&gt;
file does not match the C library.  Recompile with CCDEFINES set to
the value "-D _USE_BSD_DIRENT" and they should work a bit better.
Under Solaris with GCC, you should <EM>not</EM> define this macro.

<H4>OS/2</H4>

<P>The SFL was ported to OS/2 by Ewen McNiell around New Year's
Eve 1996.  It runs under EMX.  The SFL distribution kit includes
an OS/2 build script.  The 'c' script runs under OS/2 as well as
UNIX.

<H3><A NAME="TOC15">To Do List</A></H3>

<UL>
<LI>There are many areas that we've just started to look at, or
have ignored completely.  For instance, the encryption functions
are useful but basic.
<LI>We have not conducted exhaustive tests on all platforms, so
while older routines are certainly very well tested and portable,
some of the newer ones are still doubtful.  What we would really
like (sigh) is an automated test suite that checks-out every
function.
<LI>The bitstring functions in SFLBITS are part of an ongoing
project.  We are building an indexing tool that provides the kind
of fast lookup you find in modern search engines.  The basic idea
is really quite simple.  You number each text block (page, file,
paragraph).  Then you read the text and take each word.  The word
corresponds to a bitstring, with one bit corresponding to each
text block.  So, if you have a million text blocks, the bitstring
is a million bits long.  You set the corresponding bit for that
text block to 1, and save the bitmap.  You repeat this for all
words in all blocks of text.  That's the indexing part.  Now, to
do a lookup, you take the bitstrings that correspond to the words
entered.  Each bitstring is effectively a list of text blocks.
You can AND and OR the bitstrings to come-up with a final result.
Find all the 1's, read the text blocks, and that's it.  Of course
the real work is to make the results useful: you have to filter
junk, false matches, etc.  The bitstring functions currently just
do one thing: they let you store and change really long bitmaps
in a compressed form.
</UL>

<H2><A NAME="TOC16">Contributors and References</A></H2>

<UL>
<LI>The main authors of the SFL were:
Pieter Hintjens &lt;ph@imatix.com&gt;,
Pascal Antonnaux &lt;pascal@imatix.com&gt;,
Jonathan Schultz &lt;jonathan@imatix.com&gt;, and
Ewen McNeill &lt;ewen@imatix.com&gt;.
Scott Beasley &lt;jscottb@InfoAve.Com&gt;
<LI>Rob Judd &lt;judd@alphalink.com.au&gt; ported SFL to DJGPP
and added support for DRDOS long filenames.
<LI>J. Scott McKellar &lt;jm407a@multi.sbc.com&gt; suggested
the sflmem scavenger functions, and gave much useful criticism
of the SFL code.
<LI>John Klassa &lt;klassa@ivc1.ivc.com&lt; provided invaluable
help in debugging SFL on SunOS.
<LI>Vance Shipley &gt;vances@motivity.ca&gt; ported SFL to SCO
UnixWare and SCO OpenServer.
<LI>Bruce Walter &lt;walter@fortean.com&gt; ported SFL to Solaris
and FreeBSD.
<LI>Eric Wieling &lt;eric@cronus.ccti.net&gt; provided help in
porting SFL to BSD/OS.
<LI>Julius Kempa &lt;j.kempa@atos-group.de&gt; ported SFL to SINIX.
<LI>The xstrcat() function was based on a snippet from Dr Dobb's
Journal, Nov 1992, p. 155.
<LI>The strhash() function was based on an article in Dr Dobb's
Journal, Apr 1996, p. 26.  The original algorithm was by Peter
Weinberger.
<LI>The strmatch() function was based on an algorithm by Leif
Svalgaard &lt;leif@ibm.net&gt;.
<LI>The LZ compression functions were based on work by Kurt Haenen
&lt;ghgaea8@blekul11&gt;.
<LI>The symbol table functions were based on code provided with
MKS Lex and Yacc for MS-DOS.
<LI>The socket i/o functions were originally based on the book
"Internetworking With TCP/IP Volume III: Client-Server Programming
And Applications BSD Socket Version" by Douglas E. Comer and David
L. Stevens, published 1993 by Prentice-Hall Inc. ISBN
0-13-020272-X
<LI>The encryption functions were based on the cryptosystem
library by Andrew Brown &lt;asb@cs.nott.ac.uk&gt;.
<LI>The date_to_days() and days_to_date() functions were based on
work by Robert G. Tantzen (Collected Algorithms of The CACM number
199), translated into C by Nat Howard.
<LI>The memfind() function was based on work by R. Boyer and S.
Moore, CACM 20 762-72, with improvements by R. N. Horspool, A.
Hume, and D. M. Sunday.
<LI>The point-in-shape functions were based on code in the NCSA
HTTPd server.
<LI>The MIME encoding/decoding functions were based on RFC 1123
and RFC 1521.
<LI>Peter Seebach &lt;seebs@solon.com&gt; provided changes to
the Universal Header File and other components.
<LI>The UNIX 'c' script contains code taken from the libwww
installation script.
<LI>Various Libero users and participants of comp.lang.c helped
with ideas and suggestions.
</UL>

<A NAME="license">&nbsp;</A>

<H2><A NAME="TOC17">The SFL License Agreement</A></H2>

<P>This license agreement covers your use of the iMatix
<EM>STANDARD FUNCTION LIBRARY (SFL)</EM>, its source code,
documentation, and executable files, hereinafter referred to as
<EM>"the Product"</EM>.

<P>The Product is Copyright &#169; 1991-98 iMatix.  You may use it
and distribute it according to this following License Agreement.
If you do not agree with these terms, please remove the Product
from your system.  By incorporating the Product in your work or
distributing the Product to others you implicitly agree to these
license terms.

<H3>Statement Of Copyright</H3>

<P>The Product is, and remains, Copyright &#169; 1991-98 iMatix,
with exception of specific copyrights as noted in the individual
source files.

<H3>Conditions Of Use</H3>

<P>You do not need to provide the source code for the Product as
part of your product.  However, you must do one of these things to
comply with the Product License Agreement:
<OL>
<LI>Provide the source code for Product modules that you use, or

<LI>Make your product freely available according to a license
similar to the GNU General Public License, or the Perl Artistic
License, or
<LI>Add this phrase to the documentation for your product:
<EM>"This product uses parts of the iMatix SFL, Copyright &#169;
1991-98 iMatix &lt;http://www.imatix.com&gt;"</EM>.
</OL>

<H3>Rights Of Usage</H3>

<P>You may freely and at no cost use the Product in any project,
commercial, academic, military, or private, so long as you respect
the License Agreement.  The License Agreement does not affect any
software except the Product.  In particular, any application that
uses the Product does not itself fall under the License Agreement.


<P>You may modify any part of the Product, including sources and
documentation, except this License Agreement, which you may not
modify.

<P>You must clearly indicate any modifications at the start of
each source file.  The user of any modified Product code must know
that the source file is not original.

<P>At your discretion, you may rewrite or reuse any part of the
Product so that your derived code is not obviously part of the
Product.  This derived code does not fall under the Product
License Agreement directly, but you must include a credit at the
start of each source file indicating the original authorship and
source of the code, and a statement of copyright as follows:<BR>
<EM>"Parts copyright (c) 1991-98 iMatix."</EM>

<H3>Rights Of Distribution</H3>

<P>You may freely distribute the Product, or any subset of the
Product, by any means.  The License, in the form of the file
called "LICENSE.TXT" must accompany any such distribution.

<P>You may charge a fee for distributing the Product, for
providing a warranty on the Product, for making modifications to
the Product, or for any other service provided in relation to the
Product.  You are not required to ask our permission for any of
these activities.

<P>At no time will iMatix associate itself with any distribution
of the Product except that supplied from the Internet site
http://www.imatix.com.

<H3>Disclaimer Of Warranty</H3>

<P>The Product is provided as free software, in the hope that it
will be useful.  It is provided "as-is", without warranty of any
kind, either expressed or implied, including, but not limited to,
the implied warranties of merchantability and fitness for a
particular purpose.  The entire risk as to the quality and
performance of the Product is with you.  Should the Product prove
defective, the full cost of repair, servicing, or correction lies
with you.
<H2><A NAME="TOC18">Universal Header File for C programming</A></H2>
<P>Filename: prelude.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 93/03/29 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/06/27
<BR>Copyright: Copyright (c) 1991-98 iMatix
<BR>Version: 1.92 <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>1.90 PH</B>  <TD ALIGN="LEFT">Released with SFL
   1.90 <TR><TD ALIGN="LEFT"><B>1.91 PH</B>  <TD
   ALIGN="LEFT">98/04/27 Added DRDOS LFN and DJGPP support - rj
   <TR><TD ALIGN="LEFT"><B>1.92 PH</B>  <TD ALIGN="LEFT">98/05/18
   Added QNX support (provided by Alessandro Sala) </TABLE>
<H3>Synopsis</H3>
<P>This header file encapsulates many generally-useful include
   files and defines lots of good stuff. The intention of this
   header file is to hide the messy #ifdef's that you typically
   need to make real programs compile &amp; run. To use, specify
   as the first include file in your program. The main
   contributors to this file were: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>PH</B>  <TD ALIGN="LEFT">Pieter Hintjens
   &lt;ph@imatix.com&gt; <TR><TD ALIGN="LEFT"><B>EDM</B>  <TD
   ALIGN="LEFT">Ewen McNeill &lt;ewen@imatix.com&gt; <TR><TD
   ALIGN="LEFT"><B>PA</B>  <TD ALIGN="LEFT">Pascal Antonnaux
   &lt;pascal@imatix.com&gt; <TR><TD ALIGN="LEFT"><B>BW</B>  <TD
   ALIGN="LEFT">Bruce Walter &lt;walter@fortean.com&gt; <TR><TD
   ALIGN="LEFT"><B>RJ</B>  <TD ALIGN="LEFT">Rob Judd
   &lt;judd@alphalink.com.au&gt; </TABLE>
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#sys_assert">sys assert</A><BR>
   (const char *file, unsigned line);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>prelude.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>ASSERT(f)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>DEBUG</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>DOES_SNPRINTF</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>DOES_SOCKETS</B>  </TT>
<TD ALIGN="LEFT">/* System supports BSD sockets */
<TR><TD ALIGN="LEFT"><TT><B>DOES_UID</B>  </TT>
<TD ALIGN="LEFT">/* System supports uid functions */
<TR><TD ALIGN="LEFT"><TT><B>EXIT_FAILURE</B>  </TT>
<TD ALIGN="LEFT">1 /* GCC, sometimes. */
<TR><TD ALIGN="LEFT"><TT><B>EXIT_SUCCESS</B>  </TT>
<TD ALIGN="LEFT">0 /* but not defined on SunOs with */
<TR><TD ALIGN="LEFT"><TT><B>FALSE</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>FOREVER</B>  </TT>
<TD ALIGN="LEFT">for (;;) /* FOREVER { ... } */
<TR><TD ALIGN="LEFT"><TT><B>FORK_CHILD</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>FORK_ERROR</B>  </TT>
<TD ALIGN="LEFT">-1 /* Return codes from fork() */
<TR><TD ALIGN="LEFT"><TT><B>LINE_MAX</B>  </TT>
<TD ALIGN="LEFT">255 /* if not previously #define'd */
<TR><TD ALIGN="LEFT"><TT><B>MSDOS_FILESYSTEM</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>NAMEFOLD</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>O_BINARY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>O_NDELAY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>O_NONBLOCK</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHEND</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHFOLD</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATHSEP</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PATH_MAX</B>  </TT>
<TD ALIGN="LEFT">2048 /* if not previously #define'd */
<TR><TD ALIGN="LEFT"><TT><B>SIGABRT</B>  </TT>
<TD ALIGN="LEFT">22 /* Termination by abort() */
<TR><TD ALIGN="LEFT"><TT><B>SIGALRM</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>SIGILL</B>  </TT>
<TD ALIGN="LEFT">4 /* Illegal instruction */
<TR><TD ALIGN="LEFT"><TT><B>SIGINT</B>  </TT>
<TD ALIGN="LEFT">2 /* Ctrl-C sequence */
<TR><TD ALIGN="LEFT"><TT><B>SIGSEGV</B>  </TT>
<TD ALIGN="LEFT">11 /* Segment violation */
<TR><TD ALIGN="LEFT"><TT><B>SIGTERM</B>  </TT>
<TD ALIGN="LEFT">15 /* Kill signal */
<TR><TD ALIGN="LEFT"><TT><B>TIMEZONE</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>TRUE</B>  </TT>
<TD ALIGN="LEFT">1 /* ANSI standard */
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_HPUX_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_POSIX_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>_INCLUDE_XOPEN_SOURCE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>_PRELUDE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__IS_32BIT__</B>  </TT>
<TD ALIGN="LEFT">/* Else assume 32-bit OS/compiler */
<TR><TD ALIGN="LEFT"><TT><B>__IS_64BIT__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__MSDOS__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__OS2__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__STRICT_ANSI__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UNIX__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_AUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_BSDOS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_DECALPHA</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_FREEBSD</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_GENERIC</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_HPUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_IBMAIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_IRIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_LINUX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_MIPS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_NETBSD</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_NEXT</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_QNX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SCO</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SINIX</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SUNOS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_SUNSOLARIS</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__UTYPE_UNIXWARE</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__VMS_XOPEN</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__VMS__</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__WINDOWS__</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>bit_clr(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) &= ~bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_msk(bit)</B>  </TT>
<TD ALIGN="LEFT">(1 &lt;&lt; (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_set(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) |= bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>bit_tst(x,bit)</B>  </TT>
<TD ALIGN="LEFT">((x) & bit_msk (bit))
<TR><TD ALIGN="LEFT"><TT><B>environ</B>  </TT>
<TD ALIGN="LEFT">_environ
<TR><TD ALIGN="LEFT"><TT><B>local</B>  </TT>
<TD ALIGN="LEFT">static void /* Shorthand for local functions */
<TR><TD ALIGN="LEFT"><TT><B>max(a,b)</B>  </TT>
<TD ALIGN="LEFT">(((a) &gt; (b))? (a): (b))
<TR><TD ALIGN="LEFT"><TT><B>memmove(d,s,l)</B>  </TT>
<TD ALIGN="LEFT">bcopy (s,d,l)
<TR><TD ALIGN="LEFT"><TT><B>min(a,b)</B>  </TT>
<TD ALIGN="LEFT">(((a) &lt; (b))? (a): (b))
<TR><TD ALIGN="LEFT"><TT><B>random(num)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>randomize()</B>  </TT>
<TD ALIGN="LEFT">srand ((unsigned) time (NULL))
<TR><TD ALIGN="LEFT"><TT><B>sleep(a)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>snprintf</B>  </TT>
<TD ALIGN="LEFT">_snprintf
<TR><TD ALIGN="LEFT"><TT><B>strclr(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) = 0)
<TR><TD ALIGN="LEFT"><TT><B>streq(s1,s2)</B>  </TT>
<TD ALIGN="LEFT">(!strcmp ((s1), (s2)))
<TR><TD ALIGN="LEFT"><TT><B>strerror(n)</B>  </TT>
<TD ALIGN="LEFT">sys_errlist [n]
<TR><TD ALIGN="LEFT"><TT><B>strlast(s)</B>  </TT>
<TD ALIGN="LEFT">((s) [strlen (s) - 1])
<TR><TD ALIGN="LEFT"><TT><B>strneq(s1,s2)</B>  </TT>
<TD ALIGN="LEFT">(strcmp ((s1), (s2)))
<TR><TD ALIGN="LEFT"><TT><B>strnull(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) == 0)
<TR><TD ALIGN="LEFT"><TT><B>strterm(s)</B>  </TT>
<TD ALIGN="LEFT">((s) [strlen (s)])
<TR><TD ALIGN="LEFT"><TT><B>strused(s)</B>  </TT>
<TD ALIGN="LEFT">(*(s) != 0)
<TR><TD ALIGN="LEFT"><TT><B>tbllast(x)</B>  </TT>
<TD ALIGN="LEFT">(x [tblsize (x) - 1])
<TR><TD ALIGN="LEFT"><TT><B>tblsize(x)</B>  </TT>
<TD ALIGN="LEFT">(sizeof (x) / sizeof ((x) [0]))
<TR><TD ALIGN="LEFT"><TT><B>until(expr)</B>  </TT>
<TD ALIGN="LEFT">while (!(expr)) /* do { ... } until (expr) */
<TR><TD ALIGN="LEFT"><TT><B>vsnprintf</B>  </TT>
<TD ALIGN="LEFT">_vsnprintf
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>Bool</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>byte</B>  </TT>
<TD ALIGN="LEFT">unsigned char
<TR><TD ALIGN="LEFT"><TT><B>dbyte</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>dword</B>  </TT>
<TD ALIGN="LEFT">unsigned long
<TR><TD ALIGN="LEFT"><TT><B>function</B>  </TT>
<TD ALIGN="LEFT">void (*) (void)
<TR><TD ALIGN="LEFT"><TT><B>gid_t</B>  </TT>
<TD ALIGN="LEFT">int
<TR><TD ALIGN="LEFT"><TT><B>qbyte</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>uid_t</B>  </TT>
<TD ALIGN="LEFT">int
<TR><TD ALIGN="LEFT"><TT><B>word</B>  </TT>
<TD ALIGN="LEFT">unsigned short
</TABLE>
<H2><A NAME="TOC19">Define SFL version</A></H2>
<P>Filename: sflvers.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/11/21 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/10/02
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Defines the SFL_VERSION constant.
<H4>List of Symbol Definitions</H4>
<P>sflvers.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SFL_VERSION</B>  </TT>
<TD ALIGN="LEFT">"2.01" /* Main SFL version */
<TR><TD ALIGN="LEFT"><TT><B>_SFLVERS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H2><A NAME="TOC20">Large bitstring manipulation functions</A></H2>
<P>Filename: sflbits.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/05/14 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides operations to manipulate large bitstrings. The
   bitstrings are compressed. Intended for bit-based index
   techniques, where bitstrings can be millions of bits long.
   These functions are still in development; this is an early
   version that provides basic functionality. Simple tests on
   large bitmaps with random filling show a cost of about 3 bytes
   per bit, after compression. This includes all the indexing
   information.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#bits_init">bits init</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#bits_term">bits term</A><BR>
   (void);
</LI>
<LI>BITS * <A HREF="sfldoc.htm#bits_create">bits create</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#bits_destroy">bits destroy</A><BR>
   (BITS *bits);
</LI>
<LI>int <A HREF="sfldoc.htm#bits_set">bits set</A><BR>
   (BITS *bits, long bit);
</LI>
<LI>int <A HREF="sfldoc.htm#bits_clear">bits clear</A><BR>
   (BITS *bits, long bit);
</LI>
<LI>int <A HREF="sfldoc.htm#bits_test">bits test</A><BR>
   (const BITS *bits, long bit);
</LI>
<LI>int <A HREF="sfldoc.htm#bits_fput">bits fput</A><BR>
   (FILE *file, const BITS *bits);
</LI>
<LI>BITS * <A HREF="sfldoc.htm#bits_fget">bits fget</A><BR>
   (FILE *file);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflbits.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>BIT_DATASIZE</B>  </TT>
<TD ALIGN="LEFT">500 /* Size of block data part */
<TR><TD ALIGN="LEFT"><TT><B>BIT_INDEXSIZE</B>  </TT>
<TD ALIGN="LEFT">BIT_DATASIZE/2 /* Size of block index part */
<TR><TD ALIGN="LEFT"><TT><B>BIT_MAXBITS</B>  </TT>
<TD ALIGN="LEFT">16384000L /* Max. possible bit number */
<TR><TD ALIGN="LEFT"><TT><B>BIT_MAXBLOCKS</B>  </TT>
<TD ALIGN="LEFT">1024 /* Max. size of bitstring */
<TR><TD ALIGN="LEFT"><TT><B>BIT_SECTSIZE</B>  </TT>
<TD ALIGN="LEFT">8192 /* Size of one bitstring section */
<TR><TD ALIGN="LEFT"><TT><B>_SFLBITS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="bits_init">&nbsp;</A>
<H3><A NAME="TOC21"><TT>bits_init</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises bitstring functions. You must call this before
   using any other bitstring functions. Returns 0 if okay, -1 if
   there was an error.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    ASSERT (comp_zero == NULL);

    comp_zero = mem_alloc (BIT_SECTSIZE + 1);
    if (!comp_zero)
        return (-1);                    /*  Could not allocate new block     */

    memset (compressed, BIT_SECTSIZE, 0x00);
    comp_zero_size = <A HREF="sfldoc.htm#compress_bits">compress bits</A> (compressed, comp_zero, BIT_SECTSIZE);
    comp_zero      = mem_realloc (comp_zero, comp_zero_size);

    comp_ones = mem_alloc (BIT_SECTSIZE + 1);
    if (!comp_ones)
      {
        mem_free (comp_ones);
        return (-1);                    /*  Could not allocate new block     */
      }
    memset (compressed, BIT_SECTSIZE, 0xFF);
    comp_ones_size = <A HREF="sfldoc.htm#compress_bits">compress bits</A> (compressed, comp_ones, BIT_SECTSIZE);
    comp_ones      = mem_realloc (comp_ones, comp_ones_size);

    return (0);
}
</PRE>
<A NAME="bits_term">&nbsp;</A>
<H3><A NAME="TOC22"><TT>bits_term</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_term (void)
</PRE>
<H4>Synopsis</H4>
<P>Terminates bitstring functions. You must call this when you are
   finished using the bitstring functions. Returns 0 if okay, -1
   if there was an error.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    mem_free (comp_zero);
    mem_free (comp_ones);
    return (0);
}
</PRE>
<A NAME="bits_create">&nbsp;</A>
<H3><A NAME="TOC23"><TT>bits_create</TT></A></H3>
<PRE>
#include "sflbits.h"
BITS *
bits_create (void)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new bitstring and initialises all bits to zero.
   Returns a BITS handle which you should use in all further
   references to the bitstring.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    BITS
        *bits;                          /*  Newly-created bitstring          */
    BITBLOCK
        *index;                         /*  Newly-created index block        */

    bits = mem_alloc (sizeof (BITS));
    if (bits)
      {
        memset (bits, 0, sizeof (BITS));
        index = mem_alloc (sizeof (BITBLOCK));
        if (index)
          {
            /*  Set all index fields to 0: bitstring is all zeroes           */
            memset (index, 0, sizeof (BITBLOCK));
            index-&gt; left       = 0;
            index-&gt; right      = 0;
            index-&gt; size       = BIT_DATASIZE;
            bits-&gt; block [0]   = index;
            bits-&gt; block_count = 1;
            bits-&gt; free_list   = 0;     /*  No blocks in free list           */
          }
        else
          {
            mem_free (bits);
            bits = NULL;
          }
      }
    return (bits);
}
</PRE>
<A NAME="bits_destroy">&nbsp;</A>
<H3><A NAME="TOC24"><TT>bits_destroy</TT></A></H3>
<PRE>
#include "sflbits.h"
void
bits_destroy (
    BITS *bits)
</PRE>
<H4>Synopsis</H4>
<P>Releases all memory used by a bitstring and deletes the
   bitstring. Do not refer to the bitstring after calling this
   function.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */

    ASSERT (bits);

    /*  Free all blocks allocated to bitmap                                  */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
        mem_free (bits-&gt; block [block_nbr]);

    mem_free (bits);
}
</PRE>
<A NAME="bits_set">&nbsp;</A>
<H3><A NAME="TOC25"><TT>bits_set</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_set (
    BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Sets the specified bit in the bitmap. Returns ?
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section (bits, index, section, section_data, TRUE);
    section_data [bit_nbr / 8] |= 1 &lt;&lt; (bit_nbr % 8);
    put_section (bits, index, section, section_data);

    return 0;
}
</PRE>
<A NAME="bits_clear">&nbsp;</A>
<H3><A NAME="TOC26"><TT>bits_clear</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_clear (
    BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Clears the specified bit in the bitmap. Returns ?
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section (bits, index, section, section_data, TRUE);
    section_data [bit_nbr / 8] &amp;= 255 - (1 &lt;&lt; (bit_nbr % 8));
    put_section (bits, index, section, section_data);

    return 0;
}
</PRE>
<A NAME="bits_test">&nbsp;</A>
<H3><A NAME="TOC27"><TT>bits_test</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_test (
    const BITS *bits,
    long bit)
</PRE>
<H4>Synopsis</H4>
<P>Tests the specified bit in the bitmap. Returns 1 or 0.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        index,                          /*  Number of index block            */
        section;                        /*  Number of section in index       */
    dbyte
        bit_nbr;                        /*  Number of bit in section         */

    ASSERT (bits);

    locate_bit  (bits, bit, &amp;index, &amp;section, &amp;bit_nbr);
    get_section ((BITS *) bits, index, section, section_data, FALSE);
    if ((section_data [bit_nbr / 8]) &amp; (1 &lt;&lt; (bit_nbr % 8)))
        return (1);
    else
        return (0);
}
</PRE>
<A NAME="bits_fput">&nbsp;</A>
<H3><A NAME="TOC28"><TT>bits_fput</TT></A></H3>
<PRE>
#include "sflbits.h"
int
bits_fput (FILE *file,
    const BITS *bits)
</PRE>
<H4>Synopsis</H4>
<P>Writes the bitstring to the specified file stream. To read the
   bitstring, use the <A HREF="sfldoc.htm#bits_fget">bits fget</A>() function. The structure of
   the bitstring is:
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */
    word
        comp_size;                      /*  Size of compressed block         */
    BITBLOCK
        *block_ptr;                     /*  Points to bitstring block        */

    ASSERT (bits);
    ASSERT (file);

    /*  Write bitstring header to file                                       */
    fwrite (&amp;bits-&gt; block_count, sizeof (bits-&gt; block_count), 1, file);
    fwrite (&amp;bits-&gt; free_list,   sizeof (bits-&gt; free_list),   1, file);

    /*  Write bitstring blocks to file                                       */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
      {
        block_ptr = bits-&gt; block [block_nbr];
        comp_size = <A HREF="sfldoc.htm#compress_block">compress block</A> ((byte *) block_ptr,
                                    compressed, (word) block_ptr-&gt; size);

        fwrite (&amp;comp_size, sizeof (comp_size), 1, file);
        fwrite (compressed, comp_size,          1, file);
      }
    return 0;
}
</PRE>
<A NAME="bits_fget">&nbsp;</A>
<H3><A NAME="TOC29"><TT>bits_fget</TT></A></H3>
<PRE>
#include "sflbits.h"
BITS *
bits_fget (FILE *file)
</PRE>
<H4>Synopsis</H4>
<P>Reads a bitstring from the specified file stream. You must have
   previously written the bitstring using bit_fput (). Returns a
   newly-created bitmap, or NULL if there was insufficient memory.
<H4>Source Code - (sflbits.c)</H4>
<PRE>
{
    int
        block_nbr;                      /*  Bitstring block number           */
    word
        comp_size;                      /*  Size of compressed block         */
    BITBLOCK
        *block_ptr;                     /*  Points to bitstring block        */
    BITS
        *bits;

    ASSERT (file);

    bits = <A HREF="sfldoc.htm#bits_create">bits create</A> ();              /*  Create a new, empty bitmap       */

    /*  Read bitstring header from file                                      */
    fread (&amp;bits-&gt; block_count, sizeof (bits-&gt; block_count), 1, file);
    fread (&amp;bits-&gt; free_list,   sizeof (bits-&gt; free_list),   1, file);

    /*  Read bitstring blocks from file                                      */
    for (block_nbr = 0; block_nbr &lt; bits-&gt; block_count; block_nbr++)
      {
        block_nbr = alloc_block (bits);
        if (block_nbr == 0)
          {
            <A HREF="sfldoc.htm#bits_destroy">bits destroy</A> (bits);
            return (NULL);
          }
        fread (&amp;comp_size, sizeof (comp_size), 1, file);
        fread (compressed, comp_size,          1, file);
        block_ptr        = bits-&gt; block [block_nbr];
        block_ptr-&gt; size = <A HREF="sfldoc.htm#expand_block">expand block</A> (compressed, (byte *) block_ptr,
                                         comp_size);
      }
    return (bits);
}
</PRE>
<H2><A NAME="TOC30">Compression functions</A></H2>
<P>Filename: sflcomp.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 91/05/20 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Various compression/decompression functions. The LZ-type
   algorith (LZRW1/KH) was originally written by Kurt Haenen
   &lt;ghgaea8@blekul11&gt; and made portable by P. Hintjens. This
   is a reasonable LZ/RLE algorithm, very fast, but about 30% less
   efficient than a ZIP-type algorithm in terms of space. The RLE
   algorithms are better suited to compressing sparse data. The
   nulls variant is specifically tuned to data that consists
   mostly of binary zeroes. The bits variant is tuned for
   compressing sparse bitmaps.
<H4>List of Functions</H4>
<UL>
<LI>word <A HREF="sfldoc.htm#compress_block">compress block</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#expand_block">expand block</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#compress_rle">compress rle</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#expand_rle">expand rle</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#compress_nulls">compress nulls</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#expand_nulls">expand nulls</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#compress_bits">compress bits</A><BR>
   ( byte *source, byte *dest, word source_size);
</LI>
<LI>word <A HREF="sfldoc.htm#expand_bits">expand bits</A><BR>
   (const byte *source, byte *dest, word source_size);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcomp.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLCOMP_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="compress_block">&nbsp;</A>
<H3><A NAME="TOC31"><TT>compress_block</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_block (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Takes up to 64Kb of uncompressed data in Source, compresses it
   using a fast LZ/RLE algorithm and places the result in Dest.
   The compression technique is comparable to that used by Zip and
   such tools, but less agressive. It is, however, fast enough to
   use in realtime. Returns the size of the compressed data. To
   decompress the data, use the <A HREF="sfldoc.htm#expand_block">expand block</A>() function.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    static short
          Hash [4096];
    short SymbolAddress;
    word  Key;
    word  Size;
    byte  Bit = 0;
    word  Command = 0;
    word  src_index = 0;
    word  dst_size = 3;
    word  HeaderIndex = 1;

    dst [0] = FLAG_COMPRESS;
    for (Key = 0; Key &lt; 4096; Key++)
        Hash [Key] = -1;

    while ((src_index &lt; src_size) &amp;&amp; (dst_size &lt;= src_size))
      {
        if (Bit &gt; 15)
          {
            dst [HeaderIndex]     = (byte) ((Command &gt;&gt; 8) &amp; 0x00ff);
            dst [HeaderIndex + 1] = (byte) ( Command       &amp; 0x00ff);
            HeaderIndex = dst_size;
            dst_size += 2;
            Bit = 0;
          }
        for (Size = 1;; Size++)
            if ((word) (src_index + Size) &gt;= src_size
            || (src [src_index] != src [src_index + Size])
            || (Size &gt;= 0x0fff))
                break;

        if (Size &gt;= 16)
          {
            dst [dst_size++] = 0;
            dst [dst_size++] = (byte) (((word) (Size - 16) &gt;&gt; 8) &amp; 0x00ff);
            dst [dst_size++] = (byte) ((Size - 16) &amp; 0x00ff);
            dst [dst_size++] = src [src_index];
            src_index += Size;
            Command = (Command &lt;&lt; 1) + 1;
          }
        else
        if (get_match (src, src_index, src_size,
                       Hash, &amp;Size, &amp;SymbolAddress) != 0)
          {
            Key = ((src_index - SymbolAddress) &lt;&lt; 4) + (Size - 3);
            dst [dst_size++] = (byte) ((Key &gt;&gt; 8) &amp; 0x00ff);
            dst [dst_size++] = (byte) (Key &amp; 0x00ff);
            src_index += Size;
            Command = (Command &lt;&lt; 1) + 1;
          }
        else
          {
            dst [dst_size++] = src [src_index++];
            Command = (Command &lt;&lt; 1);
          }
        Bit++;
      }
    Command &lt;&lt;= (16 - Bit);
    dst [HeaderIndex]     = (byte) ((Command &gt;&gt; 8) &amp; 0x00ff);
    dst [HeaderIndex + 1] = (byte) ( Command       &amp; 0x00ff);

     if (dst_size &gt; src_size)
      {
         for (dst_size = 0; dst_size &lt; src_size; dst_size++)
             dst [dst_size + 1] = src [dst_size];
         dst [0] = FLAG_COPY;
         return (src_size + 1);
       }
     return (dst_size);
}
</PRE>
<A NAME="expand_block">&nbsp;</A>
<H3><A NAME="TOC32"><TT>expand_block</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_block (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A HREF="sfldoc.htm#compress_block">compress block</A>() function. The compressed block is passed
   in src; the expanded result in dst. dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the uncompressed data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word SymbolAddress;
    word ChunkSize;
    word Counter;
    word Command = 0;
    word src_index = 1;
    word dst_size = 0;
    byte Bit = 0;

    if (src [0] == FLAG_COPY)
      {
        for (dst_size = 1; dst_size &lt; src_size; dst_size++)
            dst [dst_size - 1] = src [dst_size];
        return (src_size - 1);
      }
    while (src_index &lt; src_size)
      {
        if (Bit == 0)
          {
            Command  = src [src_index++] &lt;&lt; 8;
            Command += src [src_index++];
            Bit = 16;
          }
        if (Command &amp; 0x8000)
          {
            SymbolAddress =  (word) (src [src_index++] &lt;&lt; 4);
            SymbolAddress += (word) (src [src_index] &gt;&gt; 4);
            if (SymbolAddress)
              {
                ChunkSize = (word) (src [src_index++] &amp; 0x0f) + 3;
                SymbolAddress = dst_size - SymbolAddress;
                for (Counter = 0; Counter &lt; ChunkSize; Counter++)
                    dst [dst_size++] = dst [SymbolAddress++];
              }
            else
              {
                ChunkSize  = (word) (src [src_index++] &lt;&lt; 8);
                ChunkSize += (word) (src [src_index++] + 16);
                for (Counter = 0; Counter &lt; ChunkSize; Counter++)
                    dst [dst_size++] = src [src_index];
                src_index++;
              }
          }
        else
            dst [dst_size++] = src [src_index++];

        Command &lt;&lt;= 1;
        Bit--;
      }
    return (dst_size);
}
</PRE>
<A NAME="compress_rle">&nbsp;</A>
<H3><A NAME="TOC33"><TT>compress_rle</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_rle (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Takes a block of uncompressed data in src, compresses it using
   a RLE algorithm and places the result in dst. To decompress the
   data, use the <A HREF="sfldoc.htm#expand_rle">expand rle</A> () function. Returns the size of
   the compressed data. The dst buffer should be 10% larger than
   the src buffer. The src buffer must be at least src_size + 1
   bytes long. It may be modified. The compressed data contains
   these strings: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>[01-7F][data...]</B>  <TD ALIGN="LEFT">String
   of uncompressed data, 1 to 127 bytes. <TR><TD
   ALIGN="LEFT"><B>[83-FF][byte]</B>  <TD ALIGN="LEFT">Run of 3 to
   127 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[80][len][byte]</B>  <TD ALIGN="LEFT">Run of
   128 to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[81][lo][hi][byte]</B>  <TD ALIGN="LEFT">Run of
   256 to 2^16 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[82][len]</B>  <TD ALIGN="LEFT">Run of 3 to 255
   spaces. <TR><TD ALIGN="LEFT"><B>[00][len]</B>  <TD
   ALIGN="LEFT">Run of 3 to 255 binary zeroes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    Bool
        have_run;                       /*  TRUE when we have a run          */

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];
        have_run = FALSE;               /*  Unless we find a run             */

        /*  Three identical bytes signals the start of a run                 */
        if (cur_byte == src [src_scan]
        &amp;&amp;  cur_byte == src [src_scan + 1]
        &amp;&amp; (src_scan + 1 &lt; src_size))
          {
            /*  Stick-in a sentinel character to ensure that the run ends    */
            src [src_size] = !cur_byte;
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            have_run = TRUE;
            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;
          }
        if (have_run)
          {
            /*  We compress short runs of spaces and nulls separately        */
            if (length &lt; 256 &amp;&amp; cur_byte == 0)
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) length;
              }
            else
            if (length &lt; 256 &amp;&amp; cur_byte == ' ')
              {
                dst [dst_size++] = 0x82;
                dst [dst_size++] = (byte) length;
              }
            else
            if (length &lt; 128)
              {
                dst [dst_size++] = (byte) length | 0x80;
                dst [dst_size++] = cur_byte;
              }
            else
            if (length &lt; 256)           /*  Short run 128-255 bytes          */
              {
                dst [dst_size++] = 0x80;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else
          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 127)        /*  Each string can be up to 127     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_rle">&nbsp;</A>
<H3><A NAME="TOC34"><TT>expand_rle</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_rle (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A HREF="sfldoc.htm#compress_rle">compress rle</A>() function. The compressed block is passed in
   src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*  1 to 127 is uncompressed string of 1 to 127 bytes                */
        if (cur_byte &gt; 0 &amp;&amp; cur_byte &lt; 128)
          {
            length = (word) cur_byte;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 3 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x00:              /*  Run of 3-255 zeroes              */
                    length   = src [src_scan++];
                    cur_byte = 0;
                    break;
                case 0x82:              /*  Run of 3-255 spaces              */
                    length   = src [src_scan++];
                    cur_byte = ' ';
                    break;
                case 0x80:              /*  Short run 128-255 bytes          */
                    length   = src [src_scan++];
                    cur_byte = src [src_scan++];
                    break;
                case 0x81:              /*  Long run 256-2^16 bytes          */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = src [src_scan++];
                    break;
                default:                /*  Run of 3 to 127 bytes            */
                    length = cur_byte &amp; 127;
                    cur_byte = src [src_scan++];
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<A NAME="compress_nulls">&nbsp;</A>
<H3><A NAME="TOC35"><TT>compress_nulls</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_nulls (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Similar to <A HREF="sfldoc.htm#compress_rle">compress rle</A>(), but optimised towards
   compression of binary zeroes. Use this when you are certain
   that the sparse areas are set to binary zeroes. You must use
   <A HREF="sfldoc.htm#expand_nulls">expand nulls</A> () to decompress a block compressed with this
   function. Returns the size of the compressed data. The dst
   buffer should be 10% larger than the src buffer. The src buffer
   must be at least src_size + 1 bytes long. It may be modified.
   The compressed data contains these strings: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>[01-7F][data...]</B>  <TD
   ALIGN="LEFT">String of uncompressed data, 1 to 127 bytes.
   <TR><TD ALIGN="LEFT"><B>[82-FF]</B>  <TD ALIGN="LEFT">Run of 2
   to 127 binary zeroes. <TR><TD ALIGN="LEFT"><B>[81][80-FF]</B>
   <TD ALIGN="LEFT">Run of 128 to 255 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[80][lo][hi]</B>  <TD ALIGN="LEFT">Run of 256
   to 2^16 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[00][len][byte]</B>  <TD ALIGN="LEFT">Run of 4
   to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[00][00][lo][hi][byte]</B>  <TD
   ALIGN="LEFT">Run of 256 to 2^16 identical bytes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    Bool
        have_run;                       /*  TRUE when we have a run          */

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];
        have_run = FALSE;               /*  Unless we find a run             */

        /*  Two identical bytes may signal the start of a run                */
        if (cur_byte == src [src_scan]
        &amp;&amp;  src_scan &lt; src_size)
          {
            /*  Stick-in a sentinel character to ensure that the run ends    */
            src [src_size] = !cur_byte;
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            /*  A run is 4+ identical bytes or 2+ nulls                      */
            if ((run_end - src_scan &gt; 2) || cur_byte == 0)
              {
                have_run = TRUE;
                if (header)             /*  If we have a previous unpacked   */
                  {                     /*    string, close it               */
                    *header = (byte) length;
                    header  = NULL;
                  }
                length = run_end - src_scan + 1;
                src_scan = run_end;
              }
          }
        if (have_run)
          {
            if (cur_byte == 0)
              {
                if (length &lt; 128)       /*  2-127 binary zeroes              */
                    dst [dst_size++] = (byte) (length | 0x80);
                else
                if (length &lt; 256)       /*  128-256 binary zeroes            */
                  {
                    dst [dst_size++] = 0x81;
                    dst [dst_size++] = (byte) length;
                  }
                else                    /*  256-2^15 binary zeroes           */
                  {
                    dst [dst_size++] = 0x80;
                    dst [dst_size++] = (byte) (length &amp; 0xff);
                    dst [dst_size++] = (byte) (length &gt;&gt; 8);
                  }
              }
            else
            if (length &lt; 256)           /*  Short run 4-255 bytes            */
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x00;
                dst [dst_size++] = 0x00;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else
          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 127)        /*  Each string can be up to 127     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_nulls">&nbsp;</A>
<H3><A NAME="TOC36"><TT>expand_nulls</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_nulls (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A HREF="sfldoc.htm#compress_nulls">compress nulls</A>() function. The compressed block is passed
   in src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*  1 to 127 is uncompressed string of 1 to 127 bytes                */
        if (cur_byte &gt; 0 &amp;&amp; cur_byte &lt; 128)
          {
            length = (word) cur_byte;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 2 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x00:              /*  Run of non-zero bytes            */
                    length = src [src_scan++];
                    if (length == 0)    /*  Stored as double-byte            */
                      {
                        length   = src [src_scan++];
                        length  += src [src_scan++] &lt;&lt; 8;
                      }
                    cur_byte = src [src_scan++];
                    break;
                case 0x80:              /*  256-2^16 zeroes                  */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = 0;
                    break;
                case 0x81:              /*  128 to 255 zeroes                */
                    length   = src [src_scan++];
                    cur_byte = 0;
                    break;
                default:                /*  2 to 127 zeroes                  */
                    length   = cur_byte &amp; 127;
                    cur_byte = 0;
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<A NAME="compress_bits">&nbsp;</A>
<H3><A NAME="TOC37"><TT>compress_bits</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
compress_bits (
    byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Similar to <A HREF="sfldoc.htm#compress_rle">compress rle</A>(), but optimised towards
   compression of sparse bitmaps. Use this when you are playing
   with large, sparse bitmaps. You must use <A HREF="sfldoc.htm#expand_bits">expand bits</A> () to
   decompress a block compressed with this function. Returns the
   size of the compressed data. The dst buffer should be 10%
   larger than the src buffer for worst cases. The src buffer must
   be at least src_size + 1 bytes long. It may be modified. The
   compressed data contains these strings: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>[00-07]</B>  <TD ALIGN="LEFT">Single
   byte containing a bit in position 0 to 7. <TR><TD
   ALIGN="LEFT"><B>[08-7F][data...]</B>  <TD ALIGN="LEFT">String
   of uncompressed data, 1 to 120 bytes. <TR><TD
   ALIGN="LEFT"><B>[82-FF]</B>  <TD ALIGN="LEFT">Run of 1 to 126
   binary zeroes. <TR><TD ALIGN="LEFT"><B>[81][00-FD]</B>  <TD
   ALIGN="LEFT">Run of 127 to 380 binary zeroes. <TR><TD
   ALIGN="LEFT"><B>[81][FE][len][byte]</B>  <TD ALIGN="LEFT">Run
   of 4 to 255 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[81][FF][lo][hi][byte]</B>  <TD
   ALIGN="LEFT">Run of 256 to 2^16 identical bytes. <TR><TD
   ALIGN="LEFT"><B>[80][lo][hi]</B>  <TD ALIGN="LEFT">Run of 381
   to 2^16 binary zeroes. </TABLE>
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of compressed data          */
        src_scan,                       /*  Scan through source data         */
        run_end,                        /*  Points to end of run of bytes    */
        length = 0;                     /*  Size of the run or string        */
    byte
        cur_byte,                       /*  Next byte to process             */
        *header;                        /*  Header of unpacked string        */
    static byte
        single_bits [256];              /*  Bytes with one bit set           */
    static Bool
        initialised = FALSE;            /*  First time flag                  */

    /*  The single_bits table provides a fast lookup for bytes with          */
    /*  one bit set.  The 'interesting' bytes are non-zero in the table      */
    /*  where their value is the output code value (0-7) + 1.                */
    if (!initialised)                   /*  First time?  Initialise          */
      {
        memset (single_bits, 0, 256);
        single_bits [1]   = 1;
        single_bits [2]   = 2;
        single_bits [4]   = 3;
        single_bits [8]   = 4;
        single_bits [16]  = 5;
        single_bits [32]  = 6;
        single_bits [64]  = 7;
        single_bits [128] = 8;
      }

    src_scan = 0;                       /*  Start at beginning of source     */
    dst_size = 0;                       /*  No output yet                    */
    header   = NULL;                    /*  No open unpacked string          */
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        /*- Look for 1 or more binary zeroes, and compress into a run -------*/

        if (cur_byte == 0)
          {
            src [src_size] = 0xff;      /*  Stop with a sentinel             */
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == 0)
                run_end++;

            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;
            if (length &lt; 127)           /*  1-126 binary zeroes              */
                dst [dst_size++] = (byte) (++length | 0x80);
            else
            if (length &lt; 381)           /*  127-380 binary zeroes            */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = (byte) length - 127;
              }
            else                        /*  381-2^16 binary zeroes           */
              {
                dst [dst_size++] = 0x80;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
              }
          }
        else

        /*- Next, look for bytes with 1 bit set; we encode these as 1 byte --*/

        if (single_bits [cur_byte])     /*  Single bit value?                */
          {
            dst [dst_size++] = single_bits [cur_byte] - 1;
            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
          }
        else

        /*- Next, look for a run of 4 or more identical (non-zero) bytes ----*/

        if (cur_byte == src [src_scan]
        &amp;&amp;  cur_byte == src [src_scan + 1]
        &amp;&amp;  cur_byte == src [src_scan + 2]
        &amp;&amp; (src_scan &lt; src_size - 2))
          {
            src [src_size] = !cur_byte; /*  Stick in a sentinel byte         */
            run_end = src_scan;         /*  src_scan &lt;= src_size             */
            while (src [run_end] == cur_byte)
                run_end++;

            if (header)                 /*  If we have a previous unpacked   */
              {                         /*    string, close it               */
                *header = (byte) length + 7;
                header  = NULL;
              }
            length = run_end - src_scan + 1;
            src_scan = run_end;

            if (length &lt; 256)           /*  Short run 4-255 bytes            */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = 0xFE;
                dst [dst_size++] = (byte) length;
                dst [dst_size++] = cur_byte;
              }
            else                        /*  Long run 256-2^16 bytes          */
              {
                dst [dst_size++] = 0x81;
                dst [dst_size++] = 0xFF;
                dst [dst_size++] = (byte) (length &amp; 0xff);
                dst [dst_size++] = (byte) (length &gt;&gt; 8);
                dst [dst_size++] = cur_byte;
              }
          }
        else

        /*- Lastly, compress unpackable strings into chunks of 120 bytes ----*/

          {
            if (!header)                /*  Start new unpacked string if     */
              {                         /*    necessary                      */
                header = &amp;dst [dst_size++];
                length = 0;
              }
            dst [dst_size++] = cur_byte;
            if (++length == 120)        /*  Each string can be up to 120     */
              {                         /*    bytes long (high bit cleared)  */
                *header = (byte) length + 7;
                header  = NULL;
              }
          }
      }
    if (header)                         /*  If we have a previous unpacked   */
      {                                 /*    string, close it               */
        *header = (byte) length + 7;
        header  = NULL;
      }
    return (dst_size);                  /*  Return compressed data size      */
}
</PRE>
<A NAME="expand_bits">&nbsp;</A>
<H3><A NAME="TOC38"><TT>expand_bits</TT></A></H3>
<PRE>
#include "sflcomp.h"
word
expand_bits (
    const byte *src,
    byte *dst,
    word src_size)
</PRE>
<H4>Synopsis</H4>
<P>Expands a block of data previously compressed using the
   <A HREF="sfldoc.htm#compress_bits">compress bits</A>() function. The compressed block is passed in
   src; the expanded result in dst. Dst must be large enough to
   accomodate the largest possible decompressed block. Returns the
   size of the expanded data.
<H4>Source Code - (sflcomp.c)</H4>
<PRE>
{
    word
        dst_size,                       /*  Size of expanded data            */
        src_scan,                       /*  Scan through source data         */
        length;                         /*  Size of the run or string        */
    byte
        cur_byte;                       /*  Next byte to process             */

    src_scan = 0;
    dst_size = 0;
    while (src_scan &lt; src_size)
      {
        cur_byte = src [src_scan++];

        if (cur_byte &lt; 8)               /*  Single bit in position 0 to 7    */
            dst [dst_size++] = 1 &lt;&lt; cur_byte;
        else
        if (cur_byte &lt; 128)             /*  String of 1 to 120 bytes         */
          {
            length = (word) cur_byte - 7;
            memcpy (dst + dst_size, src + src_scan, length);
            src_scan += length;
            dst_size += length;
          }
        else                            /*  Run of 1 or more bytes           */
          {
            switch (cur_byte)
              {
                case 0x80:              /*  381-2^16 binary zeroes           */
                    length   = src [src_scan++];
                    length  += src [src_scan++] &lt;&lt; 8;
                    cur_byte = 0;
                    break;
                case 0x81:
                    length = src [src_scan++];
                    if (length == 0xFE) /*  4-255 non-zero bytes             */
                      {
                        length   = src [src_scan++];
                        cur_byte = src [src_scan++];
                      }
                    else
                    if (length == 0xFF) /*  Run of 256-2^15 non-zero bytes   */
                      {
                        length   = src [src_scan++];
                        length  += src [src_scan++] &lt;&lt; 8;
                        cur_byte = src [src_scan++];
                      }
                    else
                      {
                        length  += 127;
                        cur_byte = 0;   /*  127 to 380 zeroes                */
                      }
                    break;
                default:                /*  1 to 126 zeroes                  */
                    length   = (cur_byte - 1) &amp; 127;
                    cur_byte = 0;
              }
            memset (dst + dst_size, cur_byte, length);
            dst_size += length;
          }
      }
    return (dst_size);                  /*  Return expanded data size        */
}
</PRE>
<H2><A NAME="TOC39">Console output functions</A></H2>
<P>Filename: sflcons.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/05/22 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/02/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides redirectable console output: use the <A HREF="sfldoc.htm#coprintf">coprintf</A>()
   and <A HREF="sfldoc.htm#coputs">coputs</A>() calls instead of printf() and puts() in a
   real-time application. Then, you can call <A HREF="sfldoc.htm#console_send">console send</A>() to
   send all console output to a specified function. This is a
   useful way to get output into -- for example -- a GUI window.
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#console_send">console send</A><BR>
   (CONSOLE_FCT *console_fct, Bool echo);
</LI>
<LI>void <A HREF="sfldoc.htm#console_enable">console enable</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#console_disable">console disable</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#console_set_mode">console set mode</A><BR>
   (int CONSOLE_MODE);
</LI>
<LI>int <A HREF="sfldoc.htm#console_capture">console capture</A><BR>
   (const char *filename, char mode);
</LI>
<LI>int <A HREF="sfldoc.htm#coputs">coputs</A><BR>
   (const char *string);
</LI>
<LI>int <A HREF="sfldoc.htm#coprintf">coprintf</A><BR>
   (const char *format, ...);
</LI>
<LI>int <A HREF="sfldoc.htm#coputc">coputc</A><BR>
   (int character);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcons.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLCONS_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>CONSOLE_FCT</B>  </TT>
<TD ALIGN="LEFT">void () (const char *)
</TABLE>
<A NAME="console_send">&nbsp;</A>
<H3><A NAME="TOC40"><TT>console_send</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_send (CONSOLE_FCT *new_console_fct, Bool echo)
</PRE>
<H4>Synopsis</H4>
<P>Redirects console output to a specified CONSOLE_FCT function.
   If the specified address is NULL, redirects back to the stdout
   stream. This is independent of any console capturing in
   progress. If the echo argument is TRUE, console output is also
   sent to stdout.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_fct  = new_console_fct;
    console_echo = echo;                /*  Copy to stdout                   */
}
</PRE>
<A NAME="console_enable">&nbsp;</A>
<H3><A NAME="TOC41"><TT>console_enable</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_enable (void)
</PRE>
<H4>Synopsis</H4>
<P>Enables console output. Use together with <A HREF="sfldoc.htm#console_disable">console disable</A>()
   to stop and start console output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_active = TRUE;
}
</PRE>
<A NAME="console_disable">&nbsp;</A>
<H3><A NAME="TOC42"><TT>console_disable</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_disable (void)
</PRE>
<H4>Synopsis</H4>
<P>Disables console output. Use together with <A HREF="sfldoc.htm#console_enable">console enable</A>()
   to stop and start console output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    console_active = FALSE;
}
</PRE>
<A NAME="console_set_mode">&nbsp;</A>
<H3><A NAME="TOC43"><TT>console_set_mode</TT></A></H3>
<PRE>
#include "sflcons.h"
void
console_set_mode (int mode)
</PRE>
<H4>Synopsis</H4>
<P>Sets console display mode; the argument can be one of: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CONSOLE PLAIN</B>  <TD
   ALIGN="LEFT">Output text exactly as specified <TR><TD
   ALIGN="LEFT"><B>CONSOLE DATETIME</B>  <TD ALIGN="LEFT">Prefix
   text by "yy/mm/dd hh:mm:ss " <TR><TD ALIGN="LEFT"><B>CONSOLE
   TIME</B>  <TD ALIGN="LEFT">Prefix text by "hh:mm:ss " </TABLE>
   The default is plain output.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    ASSERT (mode == CONSOLE_PLAIN
         || mode == CONSOLE_DATETIME
         || mode == CONSOLE_TIME);

    console_mode = mode;
}
</PRE>
<A NAME="console_capture">&nbsp;</A>
<H3><A NAME="TOC44"><TT>console_capture</TT></A></H3>
<PRE>
#include "sflcons.h"
int
console_capture (const char *filename, char mode)
</PRE>
<H4>Synopsis</H4>
<P>Starts capturing console output to the specified file. If the
   mode is 'w', creates an empty capture file. If the mode is 'a',
   appends to any existing data. Returns 0 if okay, -1 if there
   was an error - in this case you can test the value of errno. If
   the filename is NULL or an empty string, closes any current
   capture file.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    if (console_file)
      {
        <A HREF="sfldoc.htm#file_close">file close</A> (console_file);
        console_file = NULL;
      }
    if (filename &amp;&amp; *filename)
      {
        ASSERT (mode == 'w' || mode == 'a');
        console_file = <A HREF="sfldoc.htm#file_open">file open</A> (filename, mode);
        if (console_file == NULL)
            return (-1);
      }
    return (0);
}
</PRE>
<A NAME="coprintf">&nbsp;</A>
<H3><A NAME="TOC45"><TT>coprintf</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coprintf (const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>As printf() but sends output to the current console. This is by
   default the stdout device, unless you used <A HREF="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function. A newline is added
   automatically.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    static char
        formatted [LINE_MAX];
    va_list
        argptr;                         /*  Argument list pointer            */
    int
        fmtsize = 0;                    /*  Size of formatted line           */
    char
        *prefixed = NULL;               /*  Prefixed formatted line          */

    if (console_active)
      {
        va_start (argptr, format);      /*  Start variable args processing   */
#if (defined (DOES_SNPRINTF))
        fmtsize = vsnprintf (formatted, LINE_MAX, format, argptr);
#else
        fmtsize = vsprintf  (formatted, format, argptr);
#endif
        va_end (argptr);                /*  End variable args processing     */
        ASSERT (fmtsize &lt; LINE_MAX);

        switch (console_mode)
          {
            case CONSOLE_DATETIME:
                prefixed = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, date_str (), " ", time_str (), ": ",
                                    formatted, NULL);
                break;
            case CONSOLE_TIME:
                prefixed = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, time_str (), ": ", formatted, NULL);
                break;
          }
        if (console_file)
          {
            <A HREF="sfldoc.htm#file_write">file write</A> (console_file, prefixed? prefixed: formatted);
            fflush (console_file);
          }
        if (console_fct)
            (console_fct) (prefixed? prefixed: formatted);

        if (console_echo)
          {
            fprintf (stdout, prefixed? prefixed: formatted);
            fprintf (stdout, "\n");
            fflush  (stdout);
          }
        if (prefixed)
          {
            fmtsize = strlen (prefixed);
            mem_free (prefixed);
          }
      }
    return (fmtsize);
}
</PRE>
<A NAME="coputs">&nbsp;</A>
<H3><A NAME="TOC46"><TT>coputs</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coputs (const char *string)
</PRE>
<H4>Synopsis</H4>
<P>As puts() but sends output to the current console. This is by
   default the stdout device, unless you used <A HREF="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    <A HREF="sfldoc.htm#coprintf">coprintf</A> (string);
    return (1);
}
</PRE>
<A NAME="coputc">&nbsp;</A>
<H3><A NAME="TOC47"><TT>coputc</TT></A></H3>
<PRE>
#include "sflcons.h"
int
coputc (int character)
</PRE>
<H4>Synopsis</H4>
<P>As putc() but sends output to the current console. This is by
   default the stdout device, unless you used <A HREF="sfldoc.htm#console_send">console send</A>()
   to direct console output to some function.
<H4>Source Code - (sflcons.c)</H4>
<PRE>
{
    char
        buffer [2];

    if (console_active)
      {
        if (console_file)
          {
            putc (character, console_file);
            fflush (console_file);
          }
        if (console_fct)
          {
            buffer [0] = (char) character;
            buffer [1] = '\0';
            (console_fct) (buffer);
          }
        if (console_echo)
          {
            putc (character, stdout);
            fflush  (stdout);
          }
      }
    return (character);
}
</PRE>
<H2><A NAME="TOC48">Conversion functions</A></H2>
<P>Filename: sflconv.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 95/12/17 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>These functions provide conversion between a set of datatypes
   (dates, times, numbers, Booleans) and external strings that
   represent the values. The objective is to format datatypes for
   display or printing, and to validate and convert strings
   supplied by the user. Conversion is controlled by a set of
   options specific to each datatype. Additionally, dates and
   times may be formatted using picture strings. The functions
   were written for use in an interactive 'forms' environment.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#conv_number_str">conv number str</A><BR>
   (const char *number, int flags, char point, int decimals, int
   decimal_format, int width, int sign_format);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_str_number">conv str number</A><BR>
   (const char *string, int flags, char point, int decimals, int
   decimal_format, int width);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_date_str">conv date str</A><BR>
   (long date, int flags, int format, int order, char datesep, int
   width);
</LI>
<LI>long <A HREF="sfldoc.htm#conv_str_date">conv str date</A><BR>
   (const char *string, int flags, int format, int order);
</LI>
<LI>int <A HREF="sfldoc.htm#conv_str_day">conv str day</A><BR>
   (const char *day_name);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_time_str">conv time str</A><BR>
   (long time, int flags, char timesep, int width);
</LI>
<LI>long <A HREF="sfldoc.htm#conv_str_time">conv str time</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_bool_str">conv bool str</A><BR>
   (Bool boolean, int format);
</LI>
<LI>int <A HREF="sfldoc.htm#conv_str_bool">conv str bool</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_time_pict">conv time pict</A><BR>
   (long time, const char *picture);
</LI>
<LI>char * <A HREF="sfldoc.htm#conv_date_pict">conv date pict</A><BR>
   (long date, const char *picture);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflconv.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>BOOL_1_0</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>BOOL_TRUE_FALSE</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>BOOL_T_F</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>BOOL_YES_NO</B>  </TT>
<TD ALIGN="LEFT">0 /* Boolean field formatting */
<TR><TD ALIGN="LEFT"><TT><B>BOOL_Y_N</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_BAD_MONTH</B>  </TT>
<TD ALIGN="LEFT">8 /* Unknown month name */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DATE_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">5 /* Result too large for output */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DATE_SIZE</B>  </TT>
<TD ALIGN="LEFT">6 /* Too few or too many digits */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_HIDDEN</B>  </TT>
<TD ALIGN="LEFT">18 /* Decimals not allowed if hidden */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_MISSING</B>  </TT>
<TD ALIGN="LEFT">11 /* Not enough decimals supplied */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">19 /* Too many decimal positions */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_DECS_REJECTED</B>  </TT>
<TD ALIGN="LEFT">17 /* Decimals not allowed if integer */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_INVALID_INPUT</B>  </TT>
<TD ALIGN="LEFT">1 /* Unrecognised char in input */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_AM</B>  </TT>
<TD ALIGN="LEFT">4 /* More than one 'am' or 'pm' */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_DELIM</B>  </TT>
<TD ALIGN="LEFT">7 /* Too many delimiters */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_MONTH</B>  </TT>
<TD ALIGN="LEFT">10 /* More than one month name */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_POINT</B>  </TT>
<TD ALIGN="LEFT">16 /* More than one decimal point */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_MULTIPLE_SIGN</B>  </TT>
<TD ALIGN="LEFT">13 /* More than one sign character */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_NOT_BOOLEAN</B>  </TT>
<TD ALIGN="LEFT">3 /* Not a yes/no or true/false value */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_NUM_OVERFLOW</B>  </TT>
<TD ALIGN="LEFT">12 /* Result too large for output */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_OUT_OF_RANGE</B>  </TT>
<TD ALIGN="LEFT">2 /* Value out of valid range */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_REJECT_3_5</B>  </TT>
<TD ALIGN="LEFT">9 /* 3/5 digits in a row not allowed */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_SIGN_BAD_FIN</B>  </TT>
<TD ALIGN="LEFT">15 /* Malformed financial negative */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_SIGN_REJECTED</B>  </TT>
<TD ALIGN="LEFT">14 /* Sign not allowed if unsigned */
<TR><TD ALIGN="LEFT"><TT><B>CONV_ERR_TOO_MANY_DIGITS</B>  </TT>
<TD ALIGN="LEFT">20 /* Too many digits for number */
<TR><TD ALIGN="LEFT"><TT><B>CONV_MAX_DECS</B>  </TT>
<TD ALIGN="LEFT">100 /* Up to 100 decimal positions */
<TR><TD ALIGN="LEFT"><TT><B>CONV_NO_ERRORS</B>  </TT>
<TD ALIGN="LEFT">0 /* No errors */
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_COMPACT</B>  </TT>
<TD ALIGN="LEFT">7
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_DELIM</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>DATE_MD_SPACE</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_DMY</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_MDY</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_ORDER_YMD</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_COMMA</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_COMPACT</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_DELIM</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DATE_YMD_SPACE</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_COMPACT</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_DELIM</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>DATE_YM_SPACE</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>DECS_DROP_ZEROS</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DECS_HIDE_ALL</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>DECS_SCIENTIFIC</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DECS_SHOW_ALL</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_CENTURY</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_DD_AS_D</B>  </TT>
<TD ALIGN="LEFT">1 /* Date field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_MM_AS_M</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_MONTH_ABC</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_DMY</B>  </TT>
<TD ALIGN="LEFT">64
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_MDY</B>  </TT>
<TD ALIGN="LEFT">128
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_ORDER_YMD</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_D_UPPER</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_DECIMALS</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_LEFT</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_SIGNED</B>  </TT>
<TD ALIGN="LEFT">1 /* Number field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_THOUSANDS</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_ZERO_BLANK</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_N_ZERO_FILL</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_12_HOUR</B>  </TT>
<TD ALIGN="LEFT">32
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_CC_AS_C</B>  </TT>
<TD ALIGN="LEFT">8
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_COMPACT</B>  </TT>
<TD ALIGN="LEFT">16
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_HH_AS_H</B>  </TT>
<TD ALIGN="LEFT">1 /* Time field flags */
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_MM_AS_M</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>FLAG_T_SS_AS_S</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>FORMAT_MAX</B>  </TT>
<TD ALIGN="LEFT">80 /* Max. size of formatted field */
<TR><TD ALIGN="LEFT"><TT><B>SIGN_ALL_LEAD</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>SIGN_ALL_TRAIL</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>SIGN_FINANCIAL</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>SIGN_NEG_LEAD</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>SIGN_NEG_TRAIL</B>  </TT>
<TD ALIGN="LEFT">1 /* Number field formatting */
<TR><TD ALIGN="LEFT"><TT><B>_DATE_FORMAT_FIRST</B>  </TT>
<TD ALIGN="LEFT">0 /* Date field formatting */
<TR><TD ALIGN="LEFT"><TT><B>_DATE_FORMAT_LAST</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>_DATE_MD_LAST</B>  </TT>
<TD ALIGN="LEFT">9
<TR><TD ALIGN="LEFT"><TT><B>_DATE_ORDER_FIRST</B>  </TT>
<TD ALIGN="LEFT">1 /* Values for date_order */
<TR><TD ALIGN="LEFT"><TT><B>_DATE_ORDER_LAST</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>_DATE_YMD_LAST</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>_DATE_YM_LAST</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>_SFLCONV_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="conv_bool_str">&nbsp;</A>
<H3><A NAME="TOC49"><TT>conv_bool_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_bool_str (
    Bool boolean,
    int  format)
</PRE>
<H4>Synopsis</H4>
<P>Converts a Bool value to a string according to the specified
   format: 0 = Yes|No; 1 = Y|N, 2 = True|False, 3 = T|F, 4 = 1|0.
   Returns a pointer to a static string that is overwritten by
   each call.
<H4>Source Code - (sflcvbs.c)</H4>
<PRE>
{
    static char *bool_name [] =
      {
        "Yes",  "No",
        "Y",    "N",
        "True", "False",
        "T",    "F",
        "1",    "0"
      };

    conv_reason = 0;                    /*  No conversion errors so far      */
    return (bool_name [format * 2 + (boolean? 0: 1)]);
}
</PRE>
<A NAME="conv_date_pict">&nbsp;</A>
<H3><A NAME="TOC50"><TT>conv_date_pict</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_date_pict (
    long date,
    const char *picture)
</PRE>
<H4>Synopsis</H4>
<P>Converts a date to a string using a picture. The picture is
   composed of any combination of these formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>cc</B>  <TD
   ALIGN="LEFT">century 2 digits, 01-99 <TR><TD
   ALIGN="LEFT"><B>y</B>  <TD ALIGN="LEFT">day of year, 1-366
   <TR><TD ALIGN="LEFT"><B>yy</B>  <TD ALIGN="LEFT">year 2 digits,
   00-99 <TR><TD ALIGN="LEFT"><B>yyyy</B>  <TD ALIGN="LEFT">year 4
   digits, 100-9999 <TR><TD ALIGN="LEFT"><B>m</B>  <TD
   ALIGN="LEFT">month, 1-12 <TR><TD ALIGN="LEFT"><B>mm</B>  <TD
   ALIGN="LEFT">month, 01-12 <TR><TD ALIGN="LEFT"><B>mmm</B>  <TD
   ALIGN="LEFT">month, 3 letters <TR><TD ALIGN="LEFT"><B>mmmm</B>
   <TD ALIGN="LEFT">month, full name <TR><TD
   ALIGN="LEFT"><B>MMM</B>  <TD ALIGN="LEFT">month, 3 letters,
   ucase <TR><TD ALIGN="LEFT"><B>MMMM</B>  <TD ALIGN="LEFT">month,
   full name, ucase <TR><TD ALIGN="LEFT"><B>d</B>  <TD
   ALIGN="LEFT">day, 1-31 <TR><TD ALIGN="LEFT"><B>dd</B>  <TD
   ALIGN="LEFT">day, 01-31 <TR><TD ALIGN="LEFT"><B>ddd</B>  <TD
   ALIGN="LEFT">day of week, Sun-Sat <TR><TD
   ALIGN="LEFT"><B>dddd</B>  <TD ALIGN="LEFT">day of week, Sunday-
   Saturday <TR><TD ALIGN="LEFT"><B>DDD</B>  <TD ALIGN="LEFT">day
   of week, SUN-SAT <TR><TD ALIGN="LEFT"><B>DDDD</B>  <TD
   ALIGN="LEFT">day of week, SUNDAY-SATURDAY <TR><TD
   ALIGN="LEFT"><B>w</B>  <TD ALIGN="LEFT">day of week, 1-7
   (1=Sunday) <TR><TD ALIGN="LEFT"><B>ww</B>  <TD
   ALIGN="LEFT">week of year, 1-53 <TR><TD ALIGN="LEFT"><B>q</B>
   <TD ALIGN="LEFT">year quarter, 1-4 <TR><TD
   ALIGN="LEFT"><B>\x</B>  <TD ALIGN="LEFT">literal character x
   <TR><TD ALIGN="LEFT"><B>other</B>  <TD ALIGN="LEFT">literal
   character </TABLE> Returns the formatted result. This is a
   static string, of at most 80 characters, that is overwritten by
   each call. If date is zero, returns an empty string. The 'm'
   and 'd' formats output a leading space when used at the start
   of the picture. This is to improve alignment of columns of
   dates. The 'm' and 'd' formats also output a space when the
   previous character was a digit; otherwise the date components
   stick together and are illegible.
<H4>Examples</H4>
<PRE>
    puts (conv_date_pict (19951202, "mm d, yy"));
        Dec 2, 95
    puts (conv_date_pict (19951202, "d mmm, yy"));
        2 Dec, 95
</PRE>
<H4>Source Code - (sflcvdp.c)</H4>
<PRE>
{
    static char
        *month_name [] =
          {
            "January", "February", "March", "April", "May", "June", "July",
            "August", "September", "October", "November", "December"
          },
        *day_name [] =
          {
            "Sunday", "Monday", "Tuesday", "Wednesday",
            "Thursday", "Friday", "Saturday"
          },
        formatted [FORMAT_MAX + 1];     /*  Formatted return string          */
    int
        century,                        /*  Century component of date        */
        year,                           /*  Year component of date           */
        month,                          /*  Month component of date          */
        day,                            /*  Day component of date            */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch,                             /*  Next character in picture        */
        lastch = '0';                   /*  Last character we output         */
    long
        full_date = date;

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  Zero date is returned as empty string                                */
    if (date == 0)
      {
        strclr (formatted);
        return (formatted);
      }

    <A HREF="sfldoc.htm#default_century">default century</A> (&amp;full_date);
    century = GET_CENTURY (full_date);
    year    = GET_YEAR    (full_date);
    month   = GET_MONTH   (full_date);
    day     = GET_DAY     (full_date);

    ASSERT (month &gt; 0 &amp;&amp; month &lt;= 12);
    ASSERT (day   &gt; 0 &amp;&amp; day   &lt;= 31);

    /*  Scan through picture, converting each component                      */
    dest = formatted;
    *dest = 0;                          /*  string is empty                  */
    while (*picture)
      {
        /*  Get character and count number of occurences                     */
        ch = *picture++;
        for (cursize = 1; *picture == ch; cursize++)
            picture++;

        switch (ch)
          {
            /*  cc        century 2 digits, 01-99                            */
            case 'c':
                if (cursize == 2)
                    sprintf (dest, "%02d", century);
                break;

            /*  y         day of year, 1-366                                 */
            /*  yy        year 2 digits, 00-99                               */
            /*  yyyy      year 4 digits, 0100-9999                           */
            case 'y':                   /*  y = day of year                  */
                if (cursize == 1)
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#julian_date">julian date</A> (full_date));
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", year);
                else
                if (cursize == 4)
                    sprintf (dest, "%02d%02d", century, year);
                break;

            /*  m         month, 1-12                                        */
            /*  mm        month, 01-12                                       */
            /*  mmm       month, 3 letters                                   */
            /*  mmmm      month, full name                                   */
            case 'm':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), month);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", month);
                else
                if (cursize == 3)
                  {
                    memcpy (dest, month_name [month - 1], 3);
                    dest [3] = 0;
                  }
                else
                if (cursize == 4)
                    strcpy (dest, month_name [month - 1]);
                break;

            /*  MMM       month, 3-letters, ucase                            */
            /*  MMMM      month, full name, ucase                            */
            case 'M':
                if (cursize == 3)
                  {
                    memcpy (dest, month_name [month - 1], 3);
                    dest [3] = 0;
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                else
                if (cursize == 4)
                  {
                    strcpy (dest, month_name [month - 1]);
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            /*  d         day, 1-31                                          */
            /*  dd        day, 01-31                                         */
            /*  ddd       day of week, Sun-Sat                               */
            /*  dddd      day of week, Sunday-Saturday                       */
            case 'd':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), day);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", day);
                else
                if (cursize == 3)
                  {
                    memcpy (dest, day_name [<A HREF="sfldoc.htm#day_of_week">day of week</A> (full_date)], 3);
                    dest [3] = 0;
                  }
                else
                if (cursize == 4)
                    strcpy (dest, day_name [<A HREF="sfldoc.htm#day_of_week">day of week</A> (full_date)]);
                break;

            /*  DDD       day of week, SUN-SAT                               */
            /*  DDDD      day of week, SUNDAY-SATURDAY                       */
            case 'D':
                if (cursize == 3)
                  {
                    memcpy (dest, day_name [<A HREF="sfldoc.htm#day_of_week">day of week</A> (full_date)], 3);
                    dest [3] = 0;
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                else
                if (cursize == 4)
                  {
                    strcpy (dest, day_name [<A HREF="sfldoc.htm#day_of_week">day of week</A> (full_date)]);
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            /*  w         day of week, 1-7 (1=Sunday)                        */
            /*  ww        week of year, 1-53                                 */
            case 'w':
                if (cursize == 1)
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#day_of_week">day of week</A> (full_date) + 1);
                else
                if (cursize == 2)
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#week_of_year">week of year</A> (full_date));
                break;

            /*  q         year quarter, 1-4                                  */
            case 'q':
                if (cursize == 1)
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#year_quarter">year quarter</A> (full_date));
                break;

            /*  \x        literal character x                                */
            case '\\':
                ch = *picture++;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */

        lastch = *(dest - 1);           /*  Get previous character           */
        *dest = 0;                      /*  Terminate the string nicely      */
    }
    return (formatted);
}
</PRE>
<A NAME="conv_date_str">&nbsp;</A>
<H3><A NAME="TOC51"><TT>conv_date_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_date_str (
    long date,
    int  flags,
    int  format,
    int  order,
    char datesep,
    int  width)
</PRE>
<H4>Synopsis</H4>
<P>Converts a date to a string. The format argument defines how
   the date is shown: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>DATE YMD COMPACT</B>  <TD ALIGN="LEFT">ddmmyy
   <TR><TD ALIGN="LEFT"><B>DATE YMD SLASH</B>  <TD
   ALIGN="LEFT">dd/mm/yy <TR><TD ALIGN="LEFT"><B>DATE YMD
   SPACE</B>  <TD ALIGN="LEFT">dd mm yy <TR><TD
   ALIGN="LEFT"><B>DATE YMD COMMA</B>  <TD ALIGN="LEFT">dd mm, yy
   (DM,Y or MD,Y or Y,MD) <TR><TD ALIGN="LEFT"><B>DATE YM
   COMPACT</B>  <TD ALIGN="LEFT">mmyy <TR><TD ALIGN="LEFT"><B>DATE
   YM SLASH</B>  <TD ALIGN="LEFT">mm/yy <TR><TD
   ALIGN="LEFT"><B>DATE YM SPACE</B>  <TD ALIGN="LEFT">mm yy
   <TR><TD ALIGN="LEFT"><B>DATE MD COMPACT</B>  <TD
   ALIGN="LEFT">ddmm <TR><TD ALIGN="LEFT"><B>DATE MD SLASH</B>
   <TD ALIGN="LEFT">dd/mm <TR><TD ALIGN="LEFT"><B>DATE MD
   SPACE</B>  <TD ALIGN="LEFT">dd mm </TABLE> The date order
   (year/month/day) is normally supplied in the order argument.
   However, the date flags can override this. The flags are:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG D DD AS
   D</B>  <TD ALIGN="LEFT">Show day without leading zero <TR><TD
   ALIGN="LEFT"><B>FLAG D MM AS M</B>  <TD ALIGN="LEFT">Show month
   without leading zero <TR><TD ALIGN="LEFT"><B>FLAG D MONTH
   ABC</B>  <TD ALIGN="LEFT">Show month as letters (fullname if
   width &gt; 16) <TR><TD ALIGN="LEFT"><B>FLAG D CENTURY</B>  <TD
   ALIGN="LEFT">Show year as four digits <TR><TD
   ALIGN="LEFT"><B>FLAG D UPPERCASE</B>  <TD ALIGN="LEFT">Month
   name in uppercase <TR><TD ALIGN="LEFT"><B>FLAG D ORDER DMY</B>
   <TD ALIGN="LEFT">Order is DMY for this date <TR><TD
   ALIGN="LEFT"><B>FLAG D ORDER MDY</B>  <TD ALIGN="LEFT">Order is
   MDY for this date <TR><TD ALIGN="LEFT"><B>FLAG D ORDER YMD</B>
   <TD ALIGN="LEFT">Order is YMD for this date </TABLE> Returns a
   pointer to a static area holding the string, or NULL if there
   was an error (for instance, formatted date greater than width).
<H4>Source Code - (sflcvds.c)</H4>
<PRE>
{
    static char *format_table [] = {
        "ymd",    "dmy",    "mdy",      /*  DATE_YMD_COMPACT                 */
        "y/m/d",  "d/m/y",  "m/d/y",    /*  DATE_YMD_DELIM                   */
        "y m d",  "d m y",  "m d y",    /*  DATE_YMD_SPACE                   */
        "y, m d", "d m, y", "m d, y",   /*  DATE_YMD_COMMA                   */
        "ym",     "my",     "my",       /*  DATE_YM_COMPACT                  */
        "y/m",    "m/y",    "m/y",      /*  DATE_YM_DELIM                    */
        "y m",    "m y",    "m y",      /*  DATE_YM_SPACE                    */
        "md",     "dm",     "md",       /*  DATE_MD_COMPACT                  */
        "m/d",    "d/m",    "m/d",      /*  DATE_MD_DELIM                    */
        "m d",    "d m",    "m d"       /*  DATE_MD_SPACE                    */
    };
    char
        *format_ptr,                    /*  Scan through format string       */
        delim [2],                      /*  Delimiter character              */
        picture [14],                   /*  Largest picture: dd mmmm, yyyy   */
        ch;                             /*  Next char in format string       */
    int
        index,
        date_order = order;             /*  Order to use                     */

    ASSERT (format &gt;= _DATE_FORMAT_FIRST &amp;&amp; format &lt;= _DATE_FORMAT_LAST);
    ASSERT (order  &gt;= _DATE_ORDER_FIRST  &amp;&amp; order  &lt;= _DATE_ORDER_LAST);

    conv_reason = 0;                    /*  No conversion errors so far      */

    if (flags &amp; FLAG_D_ORDER_YMD)
        date_order = DATE_ORDER_YMD;
    else
    if (flags &amp; FLAG_D_ORDER_DMY)
        date_order = DATE_ORDER_DMY;
    else
    if (flags &amp; FLAG_D_ORDER_MDY)
        date_order = DATE_ORDER_MDY;

    /*  Get index into table                                                 */
    index = format * 3 + date_order - 1;

    /*  Now build-up picture according to format string                      */
    strclr (picture);
    for (format_ptr = format_table [index]; *format_ptr; format_ptr++)
      {
        ch = *format_ptr;
        switch (ch)
          {
            case 'y':
                strcat (picture, flags &amp; FLAG_D_CENTURY? "yyyy": "yy");
                break;

            case 'm':
                if (flags &amp; FLAG_D_MONTH_ABC)
                    if (width &gt; 16)
                        strcat (picture, flags &amp; FLAG_D_UPPER? "MMMM": "mmmm");
                    else
                        strcat (picture, flags &amp; FLAG_D_UPPER? "MMM": "mmm");
                else
                    strcat (picture, flags &amp; FLAG_D_MM_AS_M? "m": "mm");
                break;

            case 'd':
                strcat (picture, flags &amp; FLAG_D_DD_AS_D? "d": "dd");
                break;

            case '/':
                ch = datesep;           /*  Use supplied date separator      */
            default:
                delim [0] = ch;
                delim [1] = 0;
                strcat (picture, delim);
          }
      }
    format_ptr = <A HREF="sfldoc.htm#conv_date_pict">conv date pict</A> (date, picture);
    if (strlen (format_ptr) &gt; (unsigned) width)
      {
        conv_reason = CONV_ERR_DATE_OVERFLOW;
        return (NULL);
      }
    else
        return (format_ptr);
}
</PRE>
<A NAME="conv_number_str">&nbsp;</A>
<H3><A NAME="TOC52"><TT>conv_number_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_number_str (
    const char *number,                 /*  Number to convert                */
    int   flags,                        /*  Number formatting flags          */
    char  dec_point,                    /*  Decimal point: '.' or ','        */
    int   decimals,                     /*  Number of decimals, or 0         */
    int   dec_format,                   /*  How are decimals shown?          */
    int   width,                        /*  Output field width, or 0         */
    int   sign_format                   /*  How are negatives shown?         */
)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number to a string. The number format is defined
   largely by the flags argument, which can specify various values
   defined in sflconv.h: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>FLAG N SIGNED</B>  <TD ALIGN="LEFT">Show signed
   number, using sign_format argument. <TR><TD
   ALIGN="LEFT"><B>FLAG N DECIMALS</B>  <TD ALIGN="LEFT">Show
   decimals, using dec_format argument. <TR><TD
   ALIGN="LEFT"><B>FLAG N LEFT</B>  <TD ALIGN="LEFT">Left-justify
   number; no effect if width is 0. <TR><TD ALIGN="LEFT"><B>FLAG N
   ZERO FILL</B>  <TD ALIGN="LEFT">Right-justfified, with leading
   zeroes. <TR><TD ALIGN="LEFT"><B>FLAG N ZERO BLANK</B>  <TD
   ALIGN="LEFT">Show zero as empty string or spaces (width &gt;
   0). <TR><TD ALIGN="LEFT"><B>FLAG N THOUSANDS</B>  <TD
   ALIGN="LEFT">Show number with thousands separators. </TABLE>
   Sign formats: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SIGN NEG TRAIL</B>  <TD ALIGN="LEFT">Negative
   numbers only: 123- <TR><TD ALIGN="LEFT"><B>SIGN ALL TRAIL</B>
   <TD ALIGN="LEFT">All non-zero numbers: 123- 123+ <TR><TD
   ALIGN="LEFT"><B>SIGN NEG LEAD</B>  <TD ALIGN="LEFT">Negative
   numbers only: -123 <TR><TD ALIGN="LEFT"><B>SIGN ALL LEAD</B>
   <TD ALIGN="LEFT">All non-zero numbers: -123 +123 <TR><TD
   ALIGN="LEFT"><B>SIGN FINANCIAL</B>  <TD ALIGN="LEFT">Negative
   numbers only: (123) </TABLE> Decimal formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>DECS SHOW ALL</B>  <TD
   ALIGN="LEFT">123.10, 123.00, 0.95 <TR><TD ALIGN="LEFT"><B>DECS
   DROP ZEROS</B>  <TD ALIGN="LEFT">123.1, 123, 0.95 <TR><TD
   ALIGN="LEFT"><B>DECS HIDE ALL</B>  <TD ALIGN="LEFT">123, 123, 0
   <TR><TD ALIGN="LEFT"><B>DECS PERCENTAGE</B>  <TD
   ALIGN="LEFT">12300, 12300, 95 <TR><TD ALIGN="LEFT"><B>DECS
   SCIENTIFIC</B>  <TD ALIGN="LEFT">1.231e2, 1.23e2, 9.5e-1
   </TABLE> The input number string may contain leading zeros and
   a leading sign character (space, '+', '-') if signed. These are
   examples of valid 8-digit numbers: "1234" "00001234" "12345678"
   "+12345678". If the flag FLAG_N_DECIMALS is set, the last X
   digits are taken to be decimals, where X is the value of the
   decimals argument. If the number contains a decimal point
   (always '.'), this is taken to indicate the start of the
   decimal part. The formatted number is placed within a field of
   specified width. If the number is right-justfied, this means it
   may have leading spaces. If the field width is 0, the number
   will never have leading spaces. Returns a pointer to the
   formatted string, or NULL if the specified width is too small
   for formatted number or the supplied number does not contain
   enough digits.
<H4>Source Code - (sflcvns.c)</H4>
<PRE>
{
    static char
        formatted [FORMAT_MAX + 1],     /*  Formatted return string          */
        zero [CONV_MAX_DECS + 2];       /*  Default value if needed          */
    int
        sep_stop,                       /*  Where we put next sep_char       */
        dec_stop,                       /*  Where we put decimal point       */
        decs_wanted = decimals,         /*  Number of decimals wanted        */
        decs_seen,                      /*  Number of decimals output        */
        sign_pos,                       /*  Where we put sign, if any        */
        digits;                         /*  Number of digits read so far     */
    char
       *dest,                           /*  Store formatted number here      */
        sign_char,                      /*  Number's sign: ' ', '+', '-'     */
        sep_char,                       /*  Thousands separator '.' or ','   */
        drop_zero,                      /*  We suppress this char            */
        ch;                             /*  Next character in picture        */
    Bool
        have_zero;                      /*  TRUE if whole number is zero     */

    ASSERT (width &lt;= FORMAT_MAX);
    ASSERT (dec_point == '.' || dec_point == ',');

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  ---------------------------------   Prepare to copy digits  ---------*/

    if (decs_wanted &gt; CONV_MAX_DECS)
      {
        conv_reason = CONV_ERR_DECS_OVERFLOW;
        return (NULL);                  /*  Error - too many decimals        */
      }
    /*  If value is empty, use "0" with enough decimals as default value     */
    /*  We allow one whole digit and as many decimals as needed.             */
    if (strnull (number))
      {
        <A HREF="sfldoc.htm#strpad">strpad</A> (zero, '0', decs_wanted + 1);
        number = zero;
      }

    /*  Pick-up sign character if present                                    */
    if (*number == ' ' || *number == '+' || *number == '-')
        sign_char = *number++;
    else
        sign_char = ' ';

    /*  While leading zero is '0' we blank-out zeros in the number           */
    drop_zero = (char) (flags &amp; FLAG_N_ZERO_FILL? ' ': '0');

    /*  Prepare for decimals                                                 */
    if ((flags &amp; FLAG_N_DECIMALS) == 0)
        decs_wanted = 0;

    if (strchr (number, '.'))
        dec_stop = (int) (strchr (number, '.') - (char *) number);
    else
        dec_stop = strlen (number) - decs_wanted;

    if (dec_stop &lt; 1)
      {
        conv_reason = CONV_ERR_DECS_MISSING;
        return (NULL);                  /*  Error - too few decimals         */
      }

    /*  Prepare for thousands-separators if FLAG_N_THOUSANDS                 */
    if ((flags &amp; FLAG_N_THOUSANDS) &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
      {
        /*  Get number of whole digits, allowing for decimals &amp; dec sign     */
        sep_char = (char) (dec_point == '.'? ',': '.');
        sep_stop = (dec_stop - (decs_wanted? decs_wanted + 1: 0)) % 3;
        if (sep_stop == 0)
            sep_stop = 3;               /*  Get into range 1..3              */
      }
    else
      {
        sep_char = ' ';
        sep_stop = 0;                   /*  No thousands separators          */
      }

    /*  ---------------------------------   Copy the digits  ----------------*/

    digits    = 0;                      /*  No digits loaded yet             */
    decs_seen = 0;                      /*  No decimals output yet           */
    have_zero = TRUE;                   /*  Assume number is zero            */
    dest      = formatted;              /*  Format number                    */
    while (*number)                     /*    until we hit the terminator    */
      {
        ch = *number++;
        if (ch == '.')
            continue;                   /*  Ignore '.' in number             */

        digits++;

        if (ch == drop_zero &amp;&amp; digits &lt; dec_stop)
            ch = ' ';
        else
        if (isdigit (ch))
          {
            drop_zero = ' ';
            if (ch &gt; '0')
                have_zero = FALSE;
          }
        if (ch != ' ' || (width &gt; 0 &amp;&amp; !(flags &amp; FLAG_N_LEFT)))
          {
            *dest++ = ch;               /*  Output this digit                */
            if (digits &gt; dec_stop)
                decs_seen++;            /*  Count the decimal digit          */
            else
            if (digits == dec_stop)     /*  Handle decimal stop              */
              {                         /*    with optional point            */
                if (flags &amp; FLAG_N_DECIMALS)
                    *dest++ = dec_point;
                sep_stop = 0;           /*  And kill further thousand seps   */
              }
          }
        /*  Output thousands separator unless we are in blank area           */
        if (digits == sep_stop)
          {
            if (ch != ' ')
                *dest++ = sep_char;
            sep_stop += 3;
          }
      }
    *dest = 0;                          /*  Terminate the string nicely      */
    /*  ---------------------------------   Post-format the result  ---------*/

    if (decs_wanted &gt; 0)
      {
        /*  Output trailing decimal zeroes if not supplied                   */
        if (decs_seen == 0)
            *dest++ = dec_point;
        while (decs_seen &lt; decs_wanted)
          {
            *dest++ = '0';
            decs_seen++;
          }
        /*  Drop all decimals if format is DEC_HIDE_ALL                      */
        if (dec_format == DECS_HIDE_ALL)
            while (*dest != dec_point)
                dest--;                 /*  Drop-off trailing zero           */
        else
        /*  Drop trailing decimal zeroes if format is DEC_DROP_ZEROS         */
        if (dec_format == DECS_DROP_ZEROS)
            while (*dest != dec_point)
                if (*(dest - 1) &gt; '0')
                    break;
                else
                    dest--;             /*  Drop-off trailing zero           */

        *dest = 0;                      /*  Terminate the string nicely      */
      }

    /*  Justify within width if width &gt; 0                                    */
    sign_pos = 0;                       /*  Sign normally comes at start     */
    digits   = strlen (formatted);
    if (flags &amp; FLAG_N_SIGNED)
      {
        digits++;                       /*  Allow for eventual sign          */
        if (sign_format == SIGN_FINANCIAL)
            digits++;                   /*  Sign shown like (123)            */
      }
    while (digits &lt; width)
      {
        if (flags &amp; FLAG_N_LEFT &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
            strcat (formatted, " ");
        else
          {
            <A HREF="sfldoc.htm#stropen">stropen</A> (formatted, FALSE); /*  Insert blank at start of string  */
            if (flags &amp; FLAG_N_ZERO_FILL)
                formatted [0] = '0';
            else
                sign_pos++;             /*  Skip leading space               */
          }
        digits++;
      }

    /*  Format sign if FLAG_N_SIGNED                                         */
    if (flags &amp; FLAG_N_SIGNED)
      {
        if (sign_format == SIGN_NEG_LEAD
        ||  sign_format == SIGN_ALL_LEAD
        ||  sign_format == SIGN_FINANCIAL)
            <A HREF="sfldoc.htm#stropen">stropen</A> (formatted, FALSE);

        if (sign_format == SIGN_NEG_TRAIL
        ||  sign_format == SIGN_ALL_TRAIL
        ||  sign_format == SIGN_FINANCIAL)
            strcat (formatted, " ");

        if (!have_zero)                 /*  Zero has no sign                 */
            switch (sign_format)
              {
                case SIGN_NEG_LEAD:
                    if (sign_char != '-')
                        break;          /*  Fall through if negative sign    */
                case SIGN_ALL_LEAD:
                    formatted [sign_pos] = sign_char;
                    break;

                case SIGN_NEG_TRAIL:
                    if (sign_char != '-')
                        break;          /*  Fall through if negative sign    */
                case SIGN_ALL_TRAIL:
                    strlast (formatted) = sign_char;
                    break;

                case SIGN_FINANCIAL:
                    if (sign_char == '-')
                      {
                        formatted [0]       = '(';
                        strlast (formatted) = ')';
                      }
                    break;
              }
      }

    /*  If all zeroes, return a blank string if FLAG_N_ZERO_BLANK            */
    if ((flags &amp; FLAG_N_ZERO_BLANK) &amp;&amp; have_zero)
      {
        memset (formatted, ' ', width);
        formatted [width] = 0;
      }

    if (width &gt; 0 &amp;&amp; (strlen (formatted) &gt; (size_t) width))
      {
        conv_reason = CONV_ERR_NUM_OVERFLOW;
        return (NULL);                  /*  Overflow -- number too large     */
      }
    else
        return (formatted);
}
</PRE>
<A NAME="conv_str_bool">&nbsp;</A>
<H3><A NAME="TOC53"><TT>conv_str_bool</TT></A></H3>
<PRE>
#include "sflconv.h"
int
conv_str_bool (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a Bool. Accepts T/Y/1 as TRUE, F/N/0 as
   FALSE, ignoring case. Looks only at the first letter of the
   string. Returns 1 for TRUE, 0 for FALSE, -1 if the string was
   not valid.
<H4>Source Code - (sflcvsb.c)</H4>
<PRE>
{
    char
        ch = tolower (string [0]);

    conv_reason = 0;                    /*  No conversion errors so far      */
    if (ch == 'y' || ch == 't' || ch == '1')
        return (1);
    else
    if (ch == 'n' || ch == 'f' || ch == '0')
        return (0);
    else
      {
        conv_reason = CONV_ERR_NOT_BOOLEAN;
        return (-1);
      }
}
</PRE>
<A NAME="conv_str_date">&nbsp;</A>
<H3><A NAME="TOC54"><TT>conv_str_date</TT></A></H3>
<PRE>
#include "sflconv.h"
long
conv_str_date (
    const char *string,
    int  flags,
    int  format,
    int  order)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a date. The supposed format of the date is
   defined by the format argument, which can be one of: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>DATE YMD COMPACT</B>
   <TD ALIGN="LEFT">Year month day. <TR><TD ALIGN="LEFT"><B>DATE
   YMD DELIM</B>  <TD ALIGN="LEFT">Year month day. <TR><TD
   ALIGN="LEFT"><B>DATE YMD SPACE</B>  <TD ALIGN="LEFT">Year month
   day. <TR><TD ALIGN="LEFT"><B>DATE YMD COMMA</B>  <TD
   ALIGN="LEFT">Year month day. <TR><TD ALIGN="LEFT"><B>DATE YM
   COMPACT</B>  <TD ALIGN="LEFT">Year and month only; day is zero.
   <TR><TD ALIGN="LEFT"><B>DATE YM DELIM</B>  <TD
   ALIGN="LEFT">Year and month only; day is zero. <TR><TD
   ALIGN="LEFT"><B>DATE YM SPACE</B>  <TD ALIGN="LEFT">Year and
   month only; day is zero. <TR><TD ALIGN="LEFT"><B>DATE MD
   COMPACT</B>  <TD ALIGN="LEFT">Month and day only; year is zero.
   <TR><TD ALIGN="LEFT"><B>DATE MD DELIM</B>  <TD
   ALIGN="LEFT">Month and day only; year is zero. <TR><TD
   ALIGN="LEFT"><B>DATE MD SPACE</B>  <TD ALIGN="LEFT">Month and
   day only; year is zero. </TABLE> The date order must be one of:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>DATE ORDER
   YMD</B>  <TD ALIGN="LEFT">Year month day. <TR><TD
   ALIGN="LEFT"><B>DATE ORDER DMY</B>  <TD ALIGN="LEFT">Day month
   year. <TR><TD ALIGN="LEFT"><B>DATE ORDER MDY</B>  <TD
   ALIGN="LEFT">Month day year. </TABLE> You can override the
   order using these flags: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>FLAG D ORDER YMD</B>  <TD ALIGN="LEFT">Year
   month day. <TR><TD ALIGN="LEFT"><B>FLAG D ORDER DMY</B>  <TD
   ALIGN="LEFT">Day month year. <TR><TD ALIGN="LEFT"><B>FLAG D
   ORDER MDY</B>  <TD ALIGN="LEFT">Month day year. </TABLE>
   Returns the date as a long integer, YYYYMMDD. The conversion is
   pretty relaxed and allows strings like: 010195, 1-1-95, 1-Jan-
   95, 1jan95, 01jan95, 1 1 95, etc. The input string must be
   null-terminated. Returns -1 in case of an invalid date or
   format. If the short formats (DATE_DM_..., DATE_YM_...) are
   used, the missing field is always set to 0 and cannot be
   supplied in the string. If the date was empty, i.e. contains no
   usable digits, returns 0.
<H4>Source Code - (sflcvsd.c)</H4>
<PRE>
{
    static
        char *month_name [] =
          {
            "jan", "feb", "mar", "apr", "may", "jun",
            "jul", "aug", "sep", "oct", "nov", "dec"
          };

    static byte
        month_days [] =
          {
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
          },
        order_ptr [][3] =               /*  Year, Month, Day pointers        */
          {                             /*    for various orders &amp; formats   */
          /*  YY MM DD   YYYY MM DD     YY MM       YYYY MM            MM DD */
            { 0, 2, 4 }, { 0, 4, 6 }, { 0, 2, 99 }, { 0, 4, 99 }, { 99, 0, 2 },
            { 4, 2, 0 }, { 4, 2, 0 }, { 2, 0, 99 }, { 2, 0, 99 }, { 99, 2, 0 },
            { 4, 0, 2 }, { 4, 0, 2 }, { 2, 0, 99 }, { 2, 0, 99 }, { 99, 0, 2 },
          };

    char
        date_digits   [9],              /*  8 digits of date                 */
        month_letters [4] = "???",      /*  3 characters of month            */
        ch;                             /*  Next character in date           */
    long
        feedback;                       /*  Returned date; -1 = error        */
    int
        digits,                         /*  Number of digits in string       */
        delimiters,                     /*  Number of delimiters in date     */
        digitseq,                       /*  Number of digits in sequence     */
        count,                          /*  Number of month letters          */
        year,                           /*  Date year value                  */
        month,                          /*  Date month value                 */
        day,                            /*  Date day value                   */
        order_index,                    /*  Index into order table           */
        y_ptr,                          /*  Where is year in date?           */
        m_ptr,                          /*  Where is month in date?          */
        d_ptr,                          /*  Where is day in date?            */
        date_order = order;             /*  Actual date order                */
    Bool
        had_month;                      /*  Did we already get a month?      */

    ASSERT (format &gt;= _DATE_FORMAT_FIRST &amp;&amp; format &lt;= _DATE_FORMAT_LAST);
    ASSERT (order  &gt;= _DATE_ORDER_FIRST  &amp;&amp; order  &lt;= _DATE_ORDER_LAST);

    conv_reason = 0;                    /*  No conversion errors so far      */
    if (flags &amp; FLAG_D_ORDER_YMD)
        date_order = DATE_ORDER_YMD;
    else
    if (flags &amp; FLAG_D_ORDER_DMY)
        date_order = DATE_ORDER_DMY;
    else
    if (flags &amp; FLAG_D_ORDER_MDY)
        date_order = DATE_ORDER_MDY;

    /*  Collect date digits                                                  */
    digits     = 0;                     /*  Nothing collected so far         */
    digitseq   = 0;                     /*  No digits in sequence            */
    feedback   = 0;                     /*  No errors so far                 */
    delimiters = 0;                     /*  We allow up to 2 delimiters      */
    had_month  = FALSE;                 /*  True after 3-letter month seen   */

    do
      {
        ch = *string++;
        if (isdigit (ch))
          {
            if (digits &lt; 8)
              {
                digitseq++;
                date_digits [digits++] = ch;
              }
            else
              {
                conv_reason = CONV_ERR_DATE_SIZE;
                feedback = -1;          /*  Too many digits                  */
              }
          }
        else
          {
            /*  Fill-up to even number of digits                             */
            if (digits &gt; (digits / 2) * 2)
              {
                date_digits [digits] = date_digits [digits - 1];
                date_digits [digits - 1] = '0';
                digits++;
              }
            /*  3 or 5 in a row is not allowed                               */
            if (digitseq == 3 || digitseq == 5)
              {
                conv_reason = CONV_ERR_REJECT_3_5;
                feedback = -1;
              }
            digitseq = 0;

            /*  If a letter, try to match against a month                    */
            if (isalpha (ch))
              {
                if (had_month)
                  {
                    conv_reason = CONV_ERR_MULTIPLE_MONTH;
                    feedback = -1;
                  }
                else
                  {
                    for (count = 0; isalpha (ch); )
                      {
                        if (count &lt; 3)
                            month_letters [count++] = (char) tolower (ch);
                        ch = *string++;
                      }
                    string--;           /*  Move back to char after month    */
                    if (count &lt; 3)
                      {
                        conv_reason = CONV_ERR_BAD_MONTH;
                        feedback = -1;  /*  Too few letters                  */
                      }
                    month_letters [3] = 0;
                    for (count = 0; count &lt; 12; count++)
                        if (streq (month_letters, month_name [count]))
                          {
                            count++;
                            date_digits [digits++] = (char) (count / 10 + '0');
                            date_digits [digits++] = (char) (count % 10 + '0');
                            had_month = TRUE;
                            break;
                          }
                    if (!had_month)
                      {
                        conv_reason = CONV_ERR_BAD_MONTH;
                        feedback = -1;  /*  Month not found                  */
                      }
                  }
              }
            else
            if (ispunct (ch))           /*  Skip any delimiter               */
                if ((++delimiters &gt; 2)
                ||  (format &gt; _DATE_YMD_LAST &amp;&amp; delimiters &gt; 1))
                  {
                    conv_reason = CONV_ERR_MULTIPLE_DELIM;
                    feedback = -1;      /*  Multiple delimiters              */
                  }
          }
      }
    until (ch == 0);

    /*  Return zero date if empty                                            */
    if (digits == 0)
        return (feedback);

    /*  Calculate offset in date_digits for various date order &amp; formats     */
    order_index = (date_order - 1) * 5; /*  Each row has 5 items             */

    if (format &lt;= _DATE_YMD_LAST)
      {
        if (digits == 6)
            ;   /* nothing */
        else
        if (digits == 8)
            order_index += 1;
      }
    else
    if (format &lt;= _DATE_YM_LAST)
      {
        date_digits [digits++] = '0';
        date_digits [digits++] = '0';
        if (digits == 6)
            order_index += 2;
        else
        if (digits == 8)
            order_index += 3;
        else
          {
            conv_reason = CONV_ERR_DATE_SIZE;
            return (-1);                /*  Error - bad date size            */
          }
      }
    else
    if (format &lt;= _DATE_MD_LAST)
      {
        date_digits [digits++] = '0';
        date_digits [digits++] = '0';
        if (digits == 6)
            order_index += 4;
        else
          {
            conv_reason = CONV_ERR_DATE_SIZE;
            return (-1);                /*  Error - bad date size            */
          }
      }

    /*  Decode order to pick-up offset of day/month/year in date_digits      */
    y_ptr = order_ptr [order_index][0];
    m_ptr = order_ptr [order_index][1];
    d_ptr = order_ptr [order_index][2];

#   define DIGIT(x) (date_digits [(x)] - '0')
    if (y_ptr != 99)
      {
        year = DIGIT (y_ptr) * 10 + DIGIT (y_ptr + 1);
        if (digits == 8)
            year = DIGIT (y_ptr + 2) * 10 + DIGIT (y_ptr + 3) + year * 100;

        if (year &lt; 50)
            year += 2000;
        else
        if (year &lt; 100)
            year += 1900;
      }
    else
        year = 0;

    if (m_ptr != 99)
      {
        month = DIGIT (m_ptr) * 10 + DIGIT (m_ptr + 1);
        if (month == 0 || month &gt; 12)
          {
            conv_reason = CONV_ERR_OUT_OF_RANGE;
            feedback = -1;
          }
      }
    else
        month = 0;

    if (d_ptr != 99)
      {
        day = DIGIT (d_ptr) * 10 + DIGIT (d_ptr + 1);
        if ((day == 0 || day &gt; (int) month_days [month - 1])
        ||  (month == 2 &amp;&amp; day == 29 &amp;&amp; !<A HREF="sfldoc.htm#leap_year">leap year</A> (year)))
          {
            conv_reason = CONV_ERR_OUT_OF_RANGE;
            feedback = -1;
          }
      }
    else
        day = 0;

    if (feedback == 0)
        feedback = year * 10000L + month * 100 + day;

    return (feedback);
}
</PRE>
<A NAME="conv_str_day">&nbsp;</A>
<H3><A NAME="TOC55"><TT>conv_str_day</TT></A></H3>
<PRE>
#include "sflconv.h"
int
conv_str_day (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a day. The string contains a day name in
   English. Only the first three letters of the name are
   significant. Returns a value 0..6 for Sunday to Saturday, or -1
   if the name is not a valid day.
<H4>Source Code - (sflcvsd.c)</H4>
<PRE>
{
    static
        char *day_name [] =
          { "sun", "mon", "tue", "wed", "thu", "fri", "sat" };
    int
        day;
    char
        day_comp [4];

    /*  Get up to three letters of day name and convert to lower case        */
    strncpy (day_comp, string, 3);
    day_comp [3] = '\0';
    <A HREF="sfldoc.htm#strlwc">strlwc</A> (day_comp);

    /*  I don't like magic constants, but "7" is pretty safe for now         */
    for (day = 0; day &lt; 7; day++)
        if (streq (day_name [day], day_comp))
            break;

    return (day &gt;= 7? -1: day);
}
</PRE>
<A NAME="conv_str_number">&nbsp;</A>
<H3><A NAME="TOC56"><TT>conv_str_number</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_str_number (
    const char *string,                 /*  String to convert                */
    int   flags,                        /*  Number field flags               */
    char  dec_point,                    /*  Decimal point: '.' or ','        */
    int   decimals,                     /*  Number of decimals, or 0         */
    int   dec_format,                   /*  How are decimals shown           */
    int   width                         /*  Output field width, > 0          */
)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a number. The number format is defined by
   one or more of these flags (you add them to get a flags
   argument): <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG N
   SIGNED</B>  <TD ALIGN="LEFT">Number is signed. <TR><TD
   ALIGN="LEFT"><B>FLAG N DECIMALS</B>  <TD ALIGN="LEFT">Number
   has decimals. <TR><TD ALIGN="LEFT"><B>FLAG N ZERO FILL</B>  <TD
   ALIGN="LEFT">Number has leading zeros. <TR><TD
   ALIGN="LEFT"><B>FLAG N THOUSANDS</B>  <TD ALIGN="LEFT">Number
   has thousands-separators. </TABLE> The input string may contain
   digits, decimal point, thousand separators and a sign character
   or indicator. Formatting characters are only accepted if they
   correspond to the number format. A blank string is accepted as
   zero. A space following digits ends the number; anything
   further is ignored. Returns a string of width digits, including
   leading sign if that is required. Zeroes are signed with a
   space. Width must be at least 1. If the flag FLAG_N_DECIMALS is
   set, the last X digits are decimals, where X is the value of
   the decimals argument. Decimals are then accepted or rejected
   depending on the dec_format: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>DECS SHOW ALL</B>  <TD ALIGN="LEFT">Accept
   decimals. <TR><TD ALIGN="LEFT"><B>DECS DROP ZEROS</B>  <TD
   ALIGN="LEFT">Accept decimals. <TR><TD ALIGN="LEFT"><B>DECS HIDE
   ALL</B>  <TD ALIGN="LEFT">Reject decimals. <TR><TD
   ALIGN="LEFT"><B>DECS SCIENTIFIC</B>  <TD ALIGN="LEFT">Accept
   decimals. </TABLE> If the flag FLAG_N_SIGNED is set, accepts a
   leading or trailing sign, or a financial negative like this:
   (123). Returns a pointer to the formatted string, or null if
   the string was rejected. These are the possible reasons for
   rejection: <UL> <LI>- input number is too large for specified
   width; <LI>- input number is signed when no sign is allowed;
   <LI>- input number decimals when none are allowed; <LI>- input
   number has more decimals than are allowed; <LI>- more than one
   sign character in number; <LI>- malformed financial negative
   '(123)'; <LI>- more than one decimal point in number; <LI>-
   thousand seps when FLAG_N_THOUSANDS is cleared or
   FLAG_N_ZERO_FILL <LI>is set (this overrides FLAG_N_THOUSANDS);
   <LI>- junk in input string (unrecognised character). </UL>
<H4>Source Code - (sflcvsn.c)</H4>
<PRE>
{
    static char
        number [FORMAT_MAX + 1];        /*  Cleaned-up return string         */
    int
        digits,                         /*  Number of digits read so far     */
        decs_wanted = decimals;         /*  Number of decimals wanted        */
    char
       *dest,                           /*  Store formatted number here      */
        sign_char,                      /*  Number's sign: ' ', '+', '-'     */
        sep_char,                       /*  Thousands separator '.' or ','   */
        decs_seen,                      /*  Number of decimals output        */
        ch;                             /*  Next character in picture        */
    Bool
        have_point,                     /*  Have we seen a decimal point     */
        have_zero,                      /*  TRUE if number is all zero       */
        end_loop;                       /*  Flag to break out of scan loop   */

    ASSERT (width &lt;= FORMAT_MAX);
    ASSERT (width &gt; 0);
    ASSERT (dec_point == '.' || dec_point == ',');

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  ---------------------------------   Prepare to copy digits  ---------*/

    if ((flags &amp; FLAG_N_THOUSANDS) &amp;&amp; !(flags &amp; FLAG_N_ZERO_FILL))
        sep_char = dec_point == '.'? ',': '.';
    else
        sep_char = ' ';                 /*  Reject any thousands separator   */

    /*  ---------------------------------   Copy the digits  ----------------*/

    digits     = 0;                     /*  No digits loaded yet             */
    decs_seen  = 0;                     /*  No decimals output yet           */
    sign_char  = ' ';                   /*  Final sign character '+' or '-'  */
    end_loop   = FALSE;                 /*  Flag to break out of scan loop   */
    have_point = FALSE;                 /*  No decimal point seen            */
    have_zero  = TRUE;                  /*  So far, it's zero                */

    dest = number;                      /*  Scan through number              */
    while (*string)
      {
        ch = *string++;
        switch (ch)
          {
            case '9':
            case '8':
            case '7':
            case '6':
            case '5':
            case '4':
            case '3':
            case '2':
            case '1':
                have_zero = FALSE;
            case '0':
                digits++;
                *dest++ = ch;
                if (have_point)
                    ++decs_seen;
                break;

            case '-':
            case '+':
            case '(':
                if (sign_char != ' ')
                  {
                    conv_reason = CONV_ERR_MULTIPLE_SIGN;
                    return (NULL);      /*  More than one sign char          */
                  }
                else
                if (flags &amp; FLAG_N_SIGNED)
                    sign_char = ch;
                else
                  {
                    conv_reason = CONV_ERR_SIGN_REJECTED;
                    return (NULL);      /*  Number may not be signed         */
                  }
                break;

            case ')':
                if (sign_char == '(')
                    sign_char = '-';
                else
                  {
                    conv_reason = CONV_ERR_SIGN_BAD_FIN;
                    return (NULL);      /*  Malformed financial negative     */
                  }
                break;

            case ' ':                   /*  Space ends number after digits   */
                end_loop = (digits &gt; 0);
                break;

            default:
                if (ch == dec_point)
                  {
                    if (have_point)
                      {
                        conv_reason = CONV_ERR_MULTIPLE_POINT;
                        return (NULL);  /*  More than one decimal point      */
                      }
                    else
                    if (flags &amp; FLAG_N_DECIMALS)
                        have_point = TRUE;
                    else
                      {
                        conv_reason = CONV_ERR_DECS_REJECTED;
                        return (NULL);  /*  No decimals are allowed          */
                      }
                  }
                else
                if (ch != sep_char)     /*  We allow sep chars anywhere      */
                  {
                    conv_reason = CONV_ERR_INVALID_INPUT;
                    return (NULL);      /*    else we have junk              */
                  }
          }
        if (end_loop)
            break;
      }

    /*  ---------------------------------   Post-format the result  ---------*/

    if (flags &amp; FLAG_N_DECIMALS)
      {
        ASSERT (width &gt; decs_wanted);   /*  At least decimals + 1 digit      */

        if (dec_format == DECS_HIDE_ALL)
          {
            if (have_point)
              {
                conv_reason = CONV_ERR_DECS_HIDDEN;
                return (NULL);          /*  No decimals are allowed          */
              }
          }
        while (decs_seen &lt; decs_wanted) /*  Supply missing decimals          */
          {
            digits++;
            *dest++ = '0';
            decs_seen++;
          }
        if (decs_seen &gt; decs_wanted)
          {
            conv_reason = CONV_ERR_DECS_OVERFLOW;
            return (NULL);              /*  More decimals than allowed       */
          }
      }
    else
        decs_wanted = 0;

    *dest = 0;                          /*  Terminate the string nicely      */
    if (digits &gt; width)
      {
        conv_reason = CONV_ERR_TOO_MANY_DIGITS;
        return (NULL);                  /*  Overflow -- number too large     */
      }

    /*  Supply leading zeroes                                                */
    if (digits &lt; width)
      {
        /*  Shift number and null to right of field                          */
        memmove (number + (width - digits), number, digits + 1);
        memset  (number, '0', width - digits);
      }

    /*  Store sign if necessary                                              */
    if (flags &amp; FLAG_N_SIGNED)
      {
        ASSERT (width &gt; 1);             /*  At least sign + 1 digit          */
        if (number [0] != '0')
          {
            conv_reason = CONV_ERR_TOO_MANY_DIGITS;
            return (NULL);              /*  Overflow -- no room for sign     */
          }
        if (sign_char == '(')
          {
            conv_reason = CONV_ERR_SIGN_BAD_FIN;
            return (NULL);              /*  Malformed financial negative     */
          }
        else
        if (sign_char == ' ')
            sign_char = '+';

        if (have_zero)
            number [0] = ' ';           /*  Store sign                       */
        else
            number [0] = sign_char;
      }

    return (number);
}
</PRE>
<A NAME="conv_str_time">&nbsp;</A>
<H3><A NAME="TOC57"><TT>conv_str_time</TT></A></H3>
<PRE>
#include "sflconv.h"
/*  We supply the dialog file as the source
long
conv_str_time (const char *p_string)
</PRE>
<H4>Synopsis</H4>
<P>Converts a string to a time. The string must have this format:
   hour[&lt;delim&gt;minute[&lt;delim&gt;second[&lt;delim&gt;centi
   ]]][a[m]|p[m]] Any non-digit is accepted as delimiter. Each
   component may be one or two digits. The input string must be
   null-terminated. Returns -1 in case of an invalid date or
   format. If the string was empty (contains no usable digits,
   returns 0. The am/pm indicator can occur one anywhere in the
   string.
<H4>Source Code - (sflcvst.c)</H4>
<PRE>
{

After-Init:
    (--) Ok                                 -&gt; Expect-Hour
          + Get-Next-Component

Expect-Hour:
    (--) Number                             -&gt; Expect-Minute
          + Have-Hour
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Hour
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Minute:
    (--) Number                             -&gt; Expect-Second
          + Have-Minute
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Minute
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Second:
    (--) Number                             -&gt; Expect-Centisecond
          + Have-Second
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Second
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Centisecond:
    (--) Number                             -&gt; Allow-Am-Pm
          + Have-Centisecond
          + Get-Next-Component
    (--) Am-Pm                              -&gt; Expect-Centisecond
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Allow-Am-Pm:
    (--) Am-Pm                              -&gt; Expect-Finished
          + Have-Am-Pm-Indicator
          + Get-Next-Component

Expect-Finished:
    (--) Finished                           -&gt;
          + Have-Complete-Time
          + Terminate-The-Program

Defaults:
    (--) Number                             -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
    (--) Am-Pm                              -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
    (--) Finished                           -&gt;
          + Have-Complete-Time
          + Terminate-The-Program
    (--) Delimiter                          -&gt;
          + Have-Delimiter
          + Get-Next-Component
    (--) Error                              -&gt;
          + Have-Invalid-Time
          + Terminate-The-Program
}
</PRE>
<A NAME="conv_time_pict">&nbsp;</A>
<H3><A NAME="TOC58"><TT>conv_time_pict</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_time_pict (
    long time,
    const char *picture)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time to a string using a picture. The picture is
   composed of any combination of these formats: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>h</B>  <TD ALIGN="LEFT">hour,
   0-23 <TR><TD ALIGN="LEFT"><B>hh</B>  <TD ALIGN="LEFT">hour, 00-
   23 <TR><TD ALIGN="LEFT"><B>m</B>  <TD ALIGN="LEFT">minute, 0-59
   <TR><TD ALIGN="LEFT"><B>mm</B>  <TD ALIGN="LEFT">minute, 00-59
   <TR><TD ALIGN="LEFT"><B>s</B>  <TD ALIGN="LEFT">second, 0-59
   <TR><TD ALIGN="LEFT"><B>ss</B>  <TD ALIGN="LEFT">second, 00-59
   <TR><TD ALIGN="LEFT"><B>c</B>  <TD ALIGN="LEFT">centisecond, 0-
   99 <TR><TD ALIGN="LEFT"><B>cc</B>  <TD
   ALIGN="LEFT">centisecond, 00-99 <TR><TD ALIGN="LEFT"><B>a</B>
   <TD ALIGN="LEFT">a/p indicator - use 12-hour clock <TR><TD
   ALIGN="LEFT"><B>aa</B>  <TD ALIGN="LEFT">am/pm indicator - use
   12-hour clock <TR><TD ALIGN="LEFT"><B>A</B>  <TD
   ALIGN="LEFT">A/P indicator - use 12-hour clock <TR><TD
   ALIGN="LEFT"><B>AA</B>  <TD ALIGN="LEFT">AM/PM indicator - use
   12-hour clock <TR><TD ALIGN="LEFT"><B>\x</B>  <TD
   ALIGN="LEFT">literal character x <TR><TD
   ALIGN="LEFT"><B>other</B>  <TD ALIGN="LEFT">literal character
   </TABLE> Returns the formatted result. This is a static string,
   of at most 80 characters, that is overwritten by each call. If
   time is zero, returns an empty string. The 'h', 'm', 's', and
   'c' formats output a leading space when used at the start of
   the picture. This is to improve the alignment of a column of
   times. If the previous character was a digit, these formats
   also output a space in place of the leading zero.
<H4>Source Code - (sflcvtp.c)</H4>
<PRE>
{
    static char
        formatted [FORMAT_MAX + 1];     /*  Formatted return string          */
    int
        hour,                           /*  Hour component of time           */
        minute,                         /*  Minute component of time         */
        second,                         /*  Second component of time         */
        centi,                          /*  1/100 sec component of time      */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch,                             /*  Next character in picture        */
        lastch = '0';                   /*  Last character we output         */
    Bool
        pm;                             /*  TRUE when hour &gt;= 12             */

    conv_reason = 0;                    /*  No conversion errors so far      */

    /*  Zero time is returned as empty string                                */
    if (time == 0)
      {
        strclr (formatted);
        return (formatted);
      }

    hour    = GET_HOUR   (time);
    minute  = GET_MINUTE (time);
    second  = GET_SECOND (time);
    centi   = GET_CENTI  (time);

    /*  If am/pm component specified, use 12-hour clock                      */
    if (hour &gt;= 12)
      {
        pm = TRUE;
        if (strpbrk (picture, "aA") &amp;&amp; hour &gt; 12)
            hour = 12;
      }
    else
        pm = FALSE;

    ASSERT (hour   &gt;= 0 &amp;&amp; hour   &lt; 24);
    ASSERT (minute &gt;= 0 &amp;&amp; minute &lt; 60);
    ASSERT (second &gt;= 0 &amp;&amp; second &lt; 60);

    /*  Scan through picture, converting each component                      */
    dest = formatted;
    *dest = 0;                          /*  string is empty                  */
    while (*picture)
      {
        /*  Get character and count number of occurences                     */
        ch = *picture++;
        for (cursize = 1; *picture == ch; cursize++)
            picture++;

        switch (ch)
          {
            /*  h         hour,  0-23                                        */
            /*  hh        hour, 00-23                                        */
            case 'h':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), hour);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", hour);
                break;

            /*  m         minute,  0-59                                      */
            /*  mm        minute, 00-59                                      */
            case 'm':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), minute);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", minute);
                break;

            /*  s         second,  0-59                                      */
            /*  ss        second, 00-59                                      */
            case 's':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), second);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", second);
                break;

            /*  c         centisecond,  0-99                                 */
            /*  cc        centisecond, 00-99                                 */
            case 'c':
                if (cursize == 1)
                    sprintf (dest, (isdigit (lastch)? "%2d": "%d"), centi);
                else
                if (cursize == 2)
                    sprintf (dest, "%02d", centi);
                break;

            /*  a         a/p indicator                                      */
            /*  aa        am/pm indicator                                    */
            case 'a':
                strncat (dest, (pm? "pm": "am"), cursize);
                dest [cursize] = 0;
                break;

            /*  A         A/P indicator                                      */
            /*  AA        AM/PM indicator                                    */
            case 'A':
                strncat (dest, (pm? "PM": "AM"), cursize);
                dest [cursize] = 0;
                break;

            /*  \x        literal character x                                */
            case '\\':
                ch = *picture++;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */

        lastch = *(dest - 1);           /*  Get previous character           */
        *dest = 0;                      /*  Terminate the string nicely      */
    }
    return (formatted);
}
</PRE>
<A NAME="conv_time_str">&nbsp;</A>
<H3><A NAME="TOC59"><TT>conv_time_str</TT></A></H3>
<PRE>
#include "sflconv.h"
char *
conv_time_str (
    long time,
    int  flags,
    char timesep,
    int  width)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time to a string. The flags and width control the
   resulting string. You can use one or more of these flags added
   together: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>FLAG T
   HH AS H</B>  <TD ALIGN="LEFT">Suppress leading zeroes on the
   hours. <TR><TD ALIGN="LEFT"><B>FLAG T MM AS M</B>  <TD
   ALIGN="LEFT">Suppress leading zeroes on the minutes. <TR><TD
   ALIGN="LEFT"><B>FLAG T SS AS S</B>  <TD ALIGN="LEFT">Suppress
   leading zeroes on the seconds. <TR><TD ALIGN="LEFT"><B>FLAG T
   CC AS C</B>  <TD ALIGN="LEFT">Suppress leading zeroes on the
   centiseconds. <TR><TD ALIGN="LEFT"><B>FLAG T COMPACT</B>  <TD
   ALIGN="LEFT">Show without delimiters. <TR><TD
   ALIGN="LEFT"><B>FLAG T 12 HOUR</B>  <TD ALIGN="LEFT">Append
   am/pm indicator. </TABLE> Returns a pointer to a static area
   holding the string, or NULL if there was an error. If no flags
   are used, the width argument gives these results (shown as a
   picture, which is how conv_time_str works - see
   conv_time_pict): <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>4 or less</B>  <TD ALIGN="LEFT">Error. <TR><TD
   ALIGN="LEFT"><B>5 to 7</B>  <TD ALIGN="LEFT">"hh:mm" <TR><TD
   ALIGN="LEFT"><B>8 to 10</B>  <TD ALIGN="LEFT">"hh:mm:ss"
   <TR><TD ALIGN="LEFT"><B>11 or more</B>  <TD
   ALIGN="LEFT">"hh:mm:ss:cc" </TABLE> If FLAG_T_COMPACT is used,
   width gives these results: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>3 or less</B>  <TD ALIGN="LEFT">Error. <TR><TD
   ALIGN="LEFT"><B>4 to 5</B>  <TD ALIGN="LEFT">"hhmm" <TR><TD
   ALIGN="LEFT"><B>6 to 7</B>  <TD ALIGN="LEFT">"hhmmss" <TR><TD
   ALIGN="LEFT"><B>8 or more</B>  <TD ALIGN="LEFT">"hhmmsscc"
   </TABLE> If FLAG_T_12_HOUR is used, width gives these results:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>5 or less</B>
   <TD ALIGN="LEFT">Error. <TR><TD ALIGN="LEFT"><B>6 to 8</B>  <TD
   ALIGN="LEFT">"hh:mma" <TR><TD ALIGN="LEFT"><B>9 to 11</B>  <TD
   ALIGN="LEFT">"hh:mm:ssa" <TR><TD ALIGN="LEFT"><B>12 or more</B>
   <TD ALIGN="LEFT">"hh:mm:ss:cca" </TABLE> If FLAG_T_COMPACT and
   FLAG_T_12_HOUR are used, width gives these results: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>4 or less</B>  <TD
   ALIGN="LEFT">Error. <TR><TD ALIGN="LEFT"><B>5 to 6</B>  <TD
   ALIGN="LEFT">"hhmma" <TR><TD ALIGN="LEFT"><B>7 to 8</B>  <TD
   ALIGN="LEFT">"hhmmssa" <TR><TD ALIGN="LEFT"><B>9 or more</B>
   <TD ALIGN="LEFT">"hhmmsscca" </TABLE>
<H4>Source Code - (sflcvts.c)</H4>
<PRE>
{
    char
        delim [2],                      /*  Delimiter string, ":" or ""      */
        picture [13];                   /*  Largest picture: hh:mm:ss:cca    */
    int
        delim_len;
    int
        space_left = width;

    conv_reason = 0;                    /*  No conversion errors so far      */
    if (flags &amp; FLAG_T_COMPACT)
      {
        delim [0] = 0;
        delim_len = 0;
      }
    else
      {
        delim [0] = timesep;
        delim [1] = 0;
        delim_len = 1;
      }
    if (flags &amp; FLAG_T_12_HOUR)
        space_left--;                   /*  Subtract 1 if eventual "a"       */

    /*  Build-up date picture components until we run out of space           */
    strcpy (picture, (flags &amp; FLAG_T_HH_AS_H? "h": "hh"));
    space_left -= 2;

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_MM_AS_M? "m": "mm"));
        space_left -= delim_len + 2;
      }
    else
        return (NULL);                  /*  Error - space_left is too small  */

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_SS_AS_S? "s": "ss"));
        space_left -= delim_len + 2;
      }

    if (space_left &gt;= delim_len + 2)
      {
        strcat (picture, delim);
        strcat (picture, (flags &amp; FLAG_T_CC_AS_C? "c": "cc"));
        space_left -= delim_len + 2;
      }

    /*  Append "a" (or "aa" if space) if 12-hour clock wanted                */
    if (flags &amp; FLAG_T_12_HOUR)
        strcat (picture, (space_left == 0? "a": "aa"));

    return (<A HREF="sfldoc.htm#conv_time_pict">conv time pict</A> (time, picture));
}
</PRE>
<H2><A NAME="TOC60">Encryption and decryption functions</A></H2>
<P>Filename: sflcryp.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/01/23 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>The encryption/decryption functions were based on the
   cryptosystem library by Andrew Brown <A
   HREF=mailto:"asb@cs.nott.ac.uk">asb@cs.nott.ac.uk</A>, cleaned-
   up for portability. Thanks for a great package. IDEA is
   registered as the international patent WO 91/18459 "Device for
   Converting a Digital Block and the Use thereof". For commercial
   use of IDEA, you should contact: ASCOM TECH AG Freiburgstrasse
   370 CH-3018 Bern, Switzerland
<H3>Notes</H3>
<PRE>
    Description of IDEA cipher
    --------------------------
    The IDEA cipher operates on 64 bit (8 byte) blocks, using a 128 bit (16
    byte) key. IDEA has found itself famous through its inclusion in the
    well-known PGP package. The following is from the introduction to chapter
    3 of the thesis that presented the cipher.

    The block cipher IDEA (International Data Encryption Algorithm) is based
    on the new design concept of "mixing operations from different algebraic
    groups". The required "confusion" was achieved by successively using three
    "incompatible" group operations on pairs of 16-bit subblocks and the cipher
    structure was chosen to provide the necessary "diffusion". The cipher
    structure was further chosen to facilitate both hardware and software
    implementations. The IDEA cipher is an improved version of PES and was
    developed to increase security against differential cryptanalysis.

    Description of MDC cipher
    -------------------------
    This is a method for turning a hash function, here MD5, into a fast
    secret-key encryption. Based on a suggestion by Phil Karn in sci.crypt, 13
    Feb 1992. See also his comments from sci.crypt, 23 Mar 1992. The method is
    a variant of that described in Zheng, Matsumoto and Imai, Crypto 89. See
    also, "A New Class of Cryptosystems Based on Interconnection Networks" by
    michaelp@terpsichore.informatic.rwth-aachen.de

    Description of DES cipher
    -------------------------
    DES is the well known U.S. Data Encryption Standard cipher.
    DES encrypts data in 64 bit blocks, using a 64 bit key -- of which
    56 bits are used in the encipherment process.
</PRE>
<H4>List of Functions</H4>
<UL>
<LI>Bool <A HREF="sfldoc.htm#crypt_encode">crypt encode</A><BR>
   (byte *buffer, word buffer_size, int algorithm, const byte
   *key);
</LI>
<LI>Bool <A HREF="sfldoc.htm#crypt_decode">crypt decode</A><BR>
   (byte *buffer, word buffer_size, int algorithm, const byte
   *key);
</LI>
<LI>qbyte <A HREF="sfldoc.htm#calculate_crc">calculate crc</A><BR>
   (byte *block, size_t length);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflcryp.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_DES</B>  </TT>
<TD ALIGN="LEFT">2 /* DES algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_IDEA</B>  </TT>
<TD ALIGN="LEFT">0 /* IDEA algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_MAX_BLOCK_SIZE</B>  </TT>
<TD ALIGN="LEFT">32 /* Largest block size, in bytes */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_MDC</B>  </TT>
<TD ALIGN="LEFT">1 /* MDC algorithm */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_TOP</B>  </TT>
<TD ALIGN="LEFT">4 /* We support 4 algorithms */
<TR><TD ALIGN="LEFT"><TT><B>CRYPT_XOR</B>  </TT>
<TD ALIGN="LEFT">3 /* A basic XOR algorithm */
<TR><TD ALIGN="LEFT"><TT><B>_SFLCRYP_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="crypt_encode">&nbsp;</A>
<H3><A NAME="TOC61"><TT>crypt_encode</TT></A></H3>
<PRE>
#include "sflcryp.h"
Bool
crypt_encode (
    byte *buffer,                       /*  Data to encrypt, in-place        */
    word  buffer_size,                  /*  Amount of data to encrypt        */
    int   algorithm,                    /*  What type of encryption          */
    const byte *key)                    /*  Encryption key                   */
</PRE>
<H4>Synopsis</H4>
<P>Encrypt a buffer with the specified algorithm and specified
   key. Returns TRUE if the buffer is encrypted sucessfully. The
   buffer is encrypted in-place. The algorithm can be one of:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CRYPT IDEA</B>
   <TD ALIGN="LEFT">Use IDEA encryption. <TR><TD
   ALIGN="LEFT"><B>CRYPT MDC</B>  <TD ALIGN="LEFT">Use MDC
   encryption. <TR><TD ALIGN="LEFT"><B>CRYPT DES</B>  <TD
   ALIGN="LEFT">Use DES encryption. <TR><TD ALIGN="LEFT"><B>CRYPT
   XOR</B>  <TD ALIGN="LEFT">Use XOR encryption. </TABLE> The
   minimum buffer size, and key size depends on the algorithm:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>CRYPT IDEA</B>
   <TD ALIGN="LEFT">Buffer is at least 8 bytes long, key is 16
   bytes. <TR><TD ALIGN="LEFT"><B>CRYPT MDC</B>  <TD
   ALIGN="LEFT">Buffer is at least 8 bytes long, key is 8 bytes.
   <TR><TD ALIGN="LEFT"><B>CRYPT DES</B>  <TD ALIGN="LEFT">Buffer
   is at least 32 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Buffer is at
   least 16 bytes long, key is 16 bytes. </TABLE> Use
   <A HREF="sfldoc.htm#crypt_decode">crypt decode</A>() with the same algorithm and key to decrypt
   the buffer. The buffer size must be a multiple of the minimum
   size shown above. If you specify a buffer size of zero the
   function does nothing but returns TRUE. For portability, the
   buffer size is limited to 64k.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    return (crypt_data (buffer, buffer_size, algorithm, key, TRUE));
}
</PRE>
<A NAME="crypt_decode">&nbsp;</A>
<H3><A NAME="TOC62"><TT>crypt_decode</TT></A></H3>
<PRE>
#include "sflcryp.h"
Bool
crypt_decode (
    byte *buffer,                       /*  Data to decrypt, in-place        */
    word  buffer_size,                  /*  Amount of data to decrypt        */
    int   algorithm,                    /*  What type of decryption          */
    const byte *key)                    /*  Decryption key                   */
</PRE>
<H4>Synopsis</H4>
<P>Decrypt a buffer that was produced by <A HREF="sfldoc.htm#crypt_encode">crypt encode</A>(). You
   must (obviously, I reckon) use the same algorithm and key as
   was used to encrypt the data. Returns TRUE if the buffer is
   decrypted okay. The buffer is encrypted in-place. The algorithm
   can be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CRYPT IDEA</B>  <TD ALIGN="LEFT">Use IDEA
   encryption. <TR><TD ALIGN="LEFT"><B>CRYPT MDC</B>  <TD
   ALIGN="LEFT">Use MDC encryption. <TR><TD ALIGN="LEFT"><B>CRYPT
   DES</B>  <TD ALIGN="LEFT">Use DES encryption. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Use XOR
   encryption. </TABLE> The minimum buffer size, and key size
   depends on the algorithm: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CRYPT IDEA</B>  <TD ALIGN="LEFT">Buffer is at
   least 8 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT MDC</B>  <TD ALIGN="LEFT">Buffer is at
   least 8 bytes long, key is 8 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT DES</B>  <TD ALIGN="LEFT">Buffer is at
   least 32 bytes long, key is 16 bytes. <TR><TD
   ALIGN="LEFT"><B>CRYPT XOR</B>  <TD ALIGN="LEFT">Buffer is at
   least 16 bytes long, key is 16 bytes. </TABLE> The buffer size
   must be a multiple of the minimum size shown above. If you
   specify a buffer size of zero the function does nothing but
   returns TRUE.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    return (crypt_data (buffer, buffer_size, algorithm, key, FALSE));
}
</PRE>
<A NAME="calculate_crc">&nbsp;</A>
<H3><A NAME="TOC63"><TT>calculate_crc</TT></A></H3>
<PRE>
#include "sflcryp.h"
qbyte
calculate_crc (byte *block, size_t length)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the 32-bit CCITT CRC for a memory block. The CRC
   calculation is rapid, since the function uses a pre-calculated
   table. Returns the 32-bit CRC.
<H4>Source Code - (sflcryp.c)</H4>
<PRE>
{
    size_t
        offset;
    word
        this_word;
    qbyte
        crc_value;                      /*  Running CRC value                */

    crc_value = 0xFFFFFFFFL;
    for (offset = 0; offset &lt; length; offset++)
    {
        this_word = block [offset];
        this_word = this_word ^ (dbyte) (crc_value &amp; 255);
        crc_value = (crc_value &gt;&gt; 8) ^ crc_table [this_word];
    }
    return (crc_value ^ 0xFFFFFFFFL);
}
</PRE>
<H2><A NAME="TOC64">Date and time functions</A></H2>
<P>Filename: sfldate.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/01/05 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/08/05
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Includes functions to get the current date/time, calculate the
   day or week, week of year and leap year. Dates and times are
   each stored in a 32-bit long value of 8 digits: dates are
   CCYYMMDD; times are HHMMSSCC. You can compare dates and times
   directly - e.g. if (date_wanted &gt;= date_now).
<H4>List of Functions</H4>
<UL>
<LI>long <A HREF="sfldoc.htm#date_now">date now</A><BR>
   (void);
</LI>
<LI>long <A HREF="sfldoc.htm#time_now">time now</A><BR>
   (void);
</LI>
<LI>Bool <A HREF="sfldoc.htm#leap_year">leap year</A><BR>
   (int year);
</LI>
<LI>int <A HREF="sfldoc.htm#julian_date">julian date</A><BR>
   (long date);
</LI>
<LI>int <A HREF="sfldoc.htm#day_of_week">day of week</A><BR>
   (long date);
</LI>
<LI>int <A HREF="sfldoc.htm#week_of_year">week of year</A><BR>
   (long date);
</LI>
<LI>int <A HREF="sfldoc.htm#year_quarter">year quarter</A><BR>
   (long date);
</LI>
<LI>long <A HREF="sfldoc.htm#next_weekday">next weekday</A><BR>
   (long date);
</LI>
<LI>long <A HREF="sfldoc.htm#prev_weekday">prev weekday</A><BR>
   (long date);
</LI>
<LI>word <A HREF="sfldoc.htm#pack_date">pack date</A><BR>
   (long date);
</LI>
<LI>word <A HREF="sfldoc.htm#pack_time">pack time</A><BR>
   (long time);
</LI>
<LI>long <A HREF="sfldoc.htm#unpack_date">unpack date</A><BR>
   (word packdate);
</LI>
<LI>long <A HREF="sfldoc.htm#unpack_time">unpack time</A><BR>
   (word packtime);
</LI>
<LI>long <A HREF="sfldoc.htm#default_century">default century</A><BR>
   (long *date);
</LI>
<LI>long <A HREF="sfldoc.htm#date_to_days">date to days</A><BR>
   (long date);
</LI>
<LI>long <A HREF="sfldoc.htm#days_to_date">days to date</A><BR>
   (long days);
</LI>
<LI>time_t <A HREF="sfldoc.htm#date_to_timer">date to timer</A><BR>
   (long date, long time);
</LI>
<LI>long <A HREF="sfldoc.htm#timer_to_date">timer to date</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A HREF="sfldoc.htm#timer_to_time">timer to time</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A HREF="sfldoc.htm#timer_to_gmdate">timer to gmdate</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A HREF="sfldoc.htm#timer_to_gmtime">timer to gmtime</A><BR>
   (time_t time_secs);
</LI>
<LI>long <A HREF="sfldoc.htm#time_to_csecs">time to csecs</A><BR>
   (long time);
</LI>
<LI>long <A HREF="sfldoc.htm#csecs_to_time">csecs to time</A><BR>
   (long csecs);
</LI>
<LI>void <A HREF="sfldoc.htm#future_date">future date</A><BR>
   (long *date, long *time, long days, long csecs);
</LI>
<LI>void <A HREF="sfldoc.htm#past_date">past date</A><BR>
   (long *date, long *time, long days, long csecs);
</LI>
<LI>void <A HREF="sfldoc.htm#date_diff">date diff</A><BR>
   (long date1, long time1, long date2, long time2, long *days,
   long *csecs);
</LI>
<LI>Bool <A HREF="sfldoc.htm#valid_date">valid date</A><BR>
   (long date);
</LI>
<LI>Bool <A HREF="sfldoc.htm#valid_time">valid time</A><BR>
   (long time);
</LI>
<LI>Bool <A HREF="sfldoc.htm#date_is_future">date is future</A><BR>
   (long date, long time);
</LI>
<LI>Bool <A HREF="sfldoc.htm#date_is_past">date is past</A><BR>
   (long date, long time);
</LI>
<LI>char * <A HREF="sfldoc.htm#timezone_string">timezone string</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#local_to_gmt">local to gmt</A><BR>
   (long date, long time, long *gmdate, long *gmtime);
</LI>
<LI>void <A HREF="sfldoc.htm#gmt_to_local">gmt to local</A><BR>
   (long gmdate, long gmtime, long *date, long *time);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfldate.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>DAY_FRIDAY</B>  </TT>
<TD ALIGN="LEFT">5
<TR><TD ALIGN="LEFT"><TT><B>DAY_MONDAY</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>DAY_SATURDAY</B>  </TT>
<TD ALIGN="LEFT">6
<TR><TD ALIGN="LEFT"><TT><B>DAY_SUNDAY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>DAY_THURSDAY</B>  </TT>
<TD ALIGN="LEFT">4
<TR><TD ALIGN="LEFT"><TT><B>DAY_TUESDAY</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>DAY_WEDNESDAY</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>GET_CCYEAR(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_CENTI(t)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (t) % 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_CENTURY(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) / 1000000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_DAY(d)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (d) % 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_HOUR(t)</B>  </TT>
<TD ALIGN="LEFT">(int) ( (t) / 1000000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_MINUTE(t)</B>  </TT>
<TD ALIGN="LEFT">(int) (((t) % 1000000L) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>GET_MONTH(d)</B>  </TT>
<TD ALIGN="LEFT">(int) (((d) % 10000L) / 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_SECOND(t)</B>  </TT>
<TD ALIGN="LEFT">(int) (((t) % 10000L) / 100)
<TR><TD ALIGN="LEFT"><TT><B>GET_YEAR(d)</B>  </TT>
<TD ALIGN="LEFT">(int) (((d) % 1000000L) / 10000L)
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_CENTI</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_DAY</B>  </TT>
<TD ALIGN="LEFT">8640000L
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_HOUR</B>  </TT>
<TD ALIGN="LEFT">360000L
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_MIN</B>  </TT>
<TD ALIGN="LEFT">6000
<TR><TD ALIGN="LEFT"><TT><B>INTERVAL_SEC</B>  </TT>
<TD ALIGN="LEFT">100
<TR><TD ALIGN="LEFT"><TT><B>MAKE_DATE(c,y,m,d)</B>  </TT>
<TD ALIGN="LEFT">(long) (c) * 1000000L + <TR><TD ALIGN="LEFT"><TT><B>MAKE_TIME(h,m,s,c)</B>  </TT>
<TD ALIGN="LEFT">(long) (h) * 1000000L + <TR><TD ALIGN="LEFT"><TT><B>_SFLDATE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>timeeq(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) == (d2) && (t1) == (t2))
<TR><TD ALIGN="LEFT"><TT><B>timege(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &gt; (d2) || ((d1) == (d2) && (t1) &gt;= (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timegt(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &gt; (d2) || ((d1) == (d2) && (t1) &gt; (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timele(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &lt; (d2) || ((d1) == (d2) && (t1) &lt;= (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timelt(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) &lt; (d2) || ((d1) == (d2) && (t1) &lt; (t2)))
<TR><TD ALIGN="LEFT"><TT><B>timeneq(d1,t1,d2,t2)</B>  </TT>
<TD ALIGN="LEFT">((d1) != (d2) || (t1) != (t2))
</TABLE>
<A NAME="date_now">&nbsp;</A>
<H3><A NAME="TOC65"><TT>date_now</TT></A></H3>
<PRE>
#include "sfldate.h"
long
date_now (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current date as a long value (CCYYMMDD). Since most
   system clocks do not return a century, this function assumes
   that all years 80 and above are in the 20th century, and all
   years 00 to 79 are in the 21st century. For best results,
   consume before 1 Jan 2080.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#timer_to_date">timer to date</A> (time (NULL)));
}
</PRE>
<A NAME="time_now">&nbsp;</A>
<H3><A NAME="TOC66"><TT>time_now</TT></A></H3>
<PRE>
#include "sfldate.h"
long
time_now (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current time as a long value (HHMMSSCC). If the
   system clock does not return centiseconds, these are set to
   zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
#if (defined (__TURBOC__))
    /*  The Turbo-C gettime() function returns just what we want             */
    struct time
        time_struct;

    gettime (&amp;time_struct);
    return (MAKE_TIME (time_struct.ti_hour,
                       time_struct.ti_min,
                       time_struct.ti_sec,
                       time_struct.ti_hund));

#elif (defined (__UTYPE_FREEBSD__))
    return (<A HREF="sfldoc.htm#timer_to_time">timer to time</A> (time (NULL)));

#elif (defined (__UNIX__) || defined (__VMS_XOPEN))
    /*  The BSD gettimeofday function returns seconds and microseconds       */
    struct timeval
        time_struct;

    gettimeofday (&amp;time_struct, 0);
    return (<A HREF="sfldoc.htm#timer_to_time">timer to time</A> (time_struct.tv_sec)
                         + time_struct.tv_usec / 10000);

#elif (defined (WIN32))
    /*  The Win32 GetLocalTime function returns just what we want            */
    SYSTEMTIME
        time_struct;

    GetLocalTime (&amp;time_struct);
    return (MAKE_TIME (time_struct.wHour,
                       time_struct.wMinute,
                       time_struct.wSecond,
                       time_struct.wMilliseconds / 10));

#else
    /*  Otherwise, just get the time without milliseconds                    */
    return (<A HREF="sfldoc.htm#timer_to_time">timer to time</A> (time (NULL)));
#endif
}
</PRE>
<A NAME="leap_year">&nbsp;</A>
<H3><A NAME="TOC67"><TT>leap_year</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
leap_year (int year)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the year is a leap year. You must supply a 4-
   digit value for the year: 90 is taken to mean 90 ad. Handles
   leap centuries correctly.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0);
}
</PRE>
<A NAME="julian_date">&nbsp;</A>
<H3><A NAME="TOC68"><TT>julian_date</TT></A></H3>
<PRE>
#include "sfldate.h"
int
julian_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of days since 31 December last year. The
   Julian date of 1 January is 1.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    static int
        days [12] = {
        0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
    };
    int
        julian;

    julian = days [GET_MONTH (date) - 1] + GET_DAY (date);
    if (GET_MONTH (date) &gt; 2 &amp;&amp; <A HREF="sfldoc.htm#leap_year">leap year</A> (GET_YEAR (date)))
        julian++;

    return (julian);
}
</PRE>
<A NAME="day_of_week">&nbsp;</A>
<H3><A NAME="TOC69"><TT>day_of_week</TT></A></H3>
<PRE>
#include "sfldate.h"
int
day_of_week (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the day of the week where 0 is Sunday, 1 is Monday, ...
   6 is Saturday. Uses Zeller's Congurence algorithm.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int
        year  = GET_CCYEAR (date),
        month = GET_MONTH  (date),
        day   = GET_DAY    (date);

    if (month &gt; 2)
        month -= 2;
    else
      {
        month += 10;
        year--;
      }
    day = ((13 * month - 1) / 5) + day + (year % 100) +
          ((year % 100) / 4) + ((year / 100) / 4) - 2 *
           (year / 100) + 77;

    return (day - 7 * (day / 7));
}
</PRE>
<A NAME="next_weekday">&nbsp;</A>
<H3><A NAME="TOC70"><TT>next_weekday</TT></A></H3>
<PRE>
#include "sfldate.h"
long
next_weekday (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the date of the next weekday, skipping from Friday to
   Monday.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        days = <A HREF="sfldoc.htm#date_to_days">date to days</A> (date);

    if (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date) == 5)        /*  Friday                           */
        days += 3;
    else
    if (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date) == 6)        /*  Saturday                         */
        days += 2;
    else
        days += 1;                      /*  Sunday to Thursday               */

    return (<A HREF="sfldoc.htm#days_to_date">days to date</A> (days));
}
</PRE>
<A NAME="prev_weekday">&nbsp;</A>
<H3><A NAME="TOC71"><TT>prev_weekday</TT></A></H3>
<PRE>
#include "sfldate.h"
long
prev_weekday (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the date of the previous weekday, skipping from Monday
   to Friday.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        days = <A HREF="sfldoc.htm#date_to_days">date to days</A> (date);

    if (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date) == 1)        /*  Monday                           */
        days -= 3;
    else
    if (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date) == 0)        /*  Sunday                           */
        days -= 2;
    else
        days -= 1;                      /*  Tuesday to Saturday              */

    return (<A HREF="sfldoc.htm#days_to_date">days to date</A> (days));
}
</PRE>
<A NAME="week_of_year">&nbsp;</A>
<H3><A NAME="TOC72"><TT>week_of_year</TT></A></H3>
<PRE>
#include "sfldate.h"
int
week_of_year (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the week of the year, where 1 is the first full week.
   Week 0 may or may not exist in any year. Uses a Lillian date
   algorithm to calculate the week of the year.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        year = GET_CCYEAR (date) - 1501,
        day  = year * 365 + year / 4 - 29872L + 1
             - year / 100 + (year - 300) / 400;

    return ((<A HREF="sfldoc.htm#julian_date">julian date</A> (date) + (int) ((day + 4) % 7)) / 7);
}
</PRE>
<A NAME="year_quarter">&nbsp;</A>
<H3><A NAME="TOC73"><TT>year_quarter</TT></A></H3>
<PRE>
#include "sfldate.h"
int
year_quarter (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns the year quarter, 1 to 4, depending on the month
   specified.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((GET_MONTH (date) - 1) / 3 + 1);
}
</PRE>
<A NAME="default_century">&nbsp;</A>
<H3><A NAME="TOC74"><TT>default_century</TT></A></H3>
<PRE>
#include "sfldate.h"
long
default_century (long *date)
</PRE>
<H4>Synopsis</H4>
<P>Supplies a default century for the year if necessary. If the
   year is 51 to 99, the century is set to 19. If the year is 0 to
   50, the century is set to 20. Returns the adjusted date.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    if (GET_CENTURY (*date) == 0)
        *date += (GET_YEAR (*date) &gt; 50? 19000000L: 20000000L);
    return (*date);
}
</PRE>
<A NAME="pack_date">&nbsp;</A>
<H3><A NAME="TOC75"><TT>pack_date</TT></A></H3>
<PRE>
#include "sfldate.h"
word
pack_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Packs the date into a single unsigned short word. Use this
   function to store dates when memory space is at a premium. The
   packed date can be used correctly in comparisons. Returns the
   packed date. The date must be later than 31 December 1979.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (word) (((GET_CCYEAR (date) - 1980) &lt;&lt; 9) +
                    (GET_MONTH  (date) &lt;&lt; 5) +
                     GET_DAY    (date));
}
</PRE>
<A NAME="pack_time">&nbsp;</A>
<H3><A NAME="TOC76"><TT>pack_time</TT></A></H3>
<PRE>
#include "sfldate.h"
word
pack_time (long time)
</PRE>
<H4>Synopsis</H4>
<P>Packs the time into a single unsigned short word. Use this
   function to store times when memory space is at a premium. The
   packed time can be used correctly in comparisons. Returns the
   packed time. Seconds are stored with 2-second accuracy and
   centiseconds are lost.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (word) ((GET_HOUR   (time) &lt;&lt; 11) +
                   (GET_MINUTE (time) &lt;&lt; 5)  +
                   (GET_SECOND (time) &gt;&gt; 1));
}
</PRE>
<A NAME="unpack_date">&nbsp;</A>
<H3><A NAME="TOC77"><TT>unpack_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
unpack_date (word packdate)
</PRE>
<H4>Synopsis</H4>
<P>Converts a packed date back into a long value.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int year;

    year = ((word) (packdate &amp; 0xfe00) &gt;&gt; 9) + 80;
    return (MAKE_DATE (year &gt; 80? 19: 20,
                       year,
                       (word) (packdate &amp; 0x01e0) &gt;&gt; 5,
                       (word) (packdate &amp; 0x001f)));
}
</PRE>
<A NAME="unpack_time">&nbsp;</A>
<H3><A NAME="TOC78"><TT>unpack_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
unpack_time (word packtime)
</PRE>
<H4>Synopsis</H4>
<P>Converts a packed time back into a long value.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (MAKE_TIME ((word) (packtime &amp; 0xf800) &gt;&gt; 11,
                       (word) (packtime &amp; 0x07e0) &gt;&gt; 5,
                       (word) (packtime &amp; 0x001f) &lt;&lt; 1, 0));
}
</PRE>
<A NAME="date_to_days">&nbsp;</A>
<H3><A NAME="TOC79"><TT>date_to_days</TT></A></H3>
<PRE>
#include "sfldate.h"
long
date_to_days (long date)
</PRE>
<H4>Synopsis</H4>
<P>Converts the date into a number of days since a distant but
   unspecified epoch. You can use this function to calculate
   differences between dates, and forward dates. Use
   <A HREF="sfldoc.htm#days_to_date">days to date</A>() to calculate the reverse function. Author:
   Robert G. Tantzen, translated from the Algol original in
   Collected Algorithms of the CACM (algorithm 199). Original
   translation into C by Nat Howard, posted to Usenet 5 Jul 1985.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        year    = GET_YEAR    (date),
        century = GET_CENTURY (date),
        month   = GET_MONTH   (date),
        day     = GET_DAY     (date);

    if (month &gt; 2)
        month -= 3;
    else
      {
        month += 9;
        if (year)
            year--;
        else
          {
            year = 99;
            century--;
          }
      }
    return ((146097L * century)    / 4L +
            (1461L   * year)       / 4L +
            (153L    * month + 2L) / 5L +
                       day   + 1721119L);
}
</PRE>
<A NAME="days_to_date">&nbsp;</A>
<H3><A NAME="TOC80"><TT>days_to_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
days_to_date (long days)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number of days since some distant but unspecified
   epoch into a date. You can use this function to calculate
   differences between dates, and forward dates. Use
   <A HREF="sfldoc.htm#date_to_days">date to days</A>() to calculate the reverse function. Author:
   Robert G. Tantzen, translated from the Algol original in
   Collected Algorithms of the CACM (algorithm 199). Original
   translation into C by Nat Howard, posted to Usenet 5 Jul 1985.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        century,
        year,
        month,
        day;

    days   -= 1721119L;
    century = (4L * days - 1L) / 146097L;
    days    =  4L * days - 1L  - 146097L * century;
    day     =  days / 4L;

    year    = (4L * day + 3L) / 1461L;
    day     =  4L * day + 3L  - 1461L * year;
    day     = (day + 4L) / 4L;

    month   = (5L * day - 3L) / 153L;
    day     =  5L * day - 3   - 153L * month;
    day     = (day + 5L) / 5L;

    if (month &lt; 10)
        month += 3;
    else
      {
        month -= 9;
        if (year++ == 99)
          {
            year = 0;
            century++;
          }
      }
    return (MAKE_DATE (century, year, month, day));
}
</PRE>
<A NAME="date_to_timer">&nbsp;</A>
<H3><A NAME="TOC81"><TT>date_to_timer</TT></A></H3>
<PRE>
#include "sfldate.h"
time_t
date_to_timer (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied date and time into a time_t timer value.
   This is the number of non-leap seconds since 00:00:00 GMT Jan
   1, 1970. Function was rewritten by Bruce Walter <A
   HREF=mailto:"walter@fortean.com">walter@fortean.com</A>.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        time_struct;

    time_struct.tm_sec   = GET_SECOND (time);
    time_struct.tm_min   = GET_MINUTE (time);
    time_struct.tm_hour  = GET_HOUR   (time);
    time_struct.tm_mday  = GET_DAY    (date);
    time_struct.tm_mon   = GET_MONTH  (date) - 1;
    time_struct.tm_year  = GET_CCYEAR (date) - 1900;
    time_struct.tm_isdst = -1;
    return (mktime (&amp;time_struct));
}
</PRE>
<A NAME="timer_to_date">&nbsp;</A>
<H3><A NAME="TOC82"><TT>timer_to_date</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_date (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long date value. Dates
   are stored as long values: CCYYMMDD. If the supplied value is
   zero, returns zero. The timer value is assumed to be UTC (GMT).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value CCYYMMDD                               */
        time_struct = localtime (&amp;time_secs);
        time_struct-&gt; tm_year += 1900;
        return (MAKE_DATE (time_struct-&gt; tm_year / 100,
                           time_struct-&gt; tm_year % 100,
                           time_struct-&gt; tm_mon + 1,
                           time_struct-&gt; tm_mday));
      }
}
</PRE>
<A NAME="timer_to_time">&nbsp;</A>
<H3><A NAME="TOC83"><TT>timer_to_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_time (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long time value. Times
   are stored as long values: HHMMSS00. Since the timer value does
   not hold centiseconds, these are set to zero. If the supplied
   value was zero, returns zero. The timer value is assumed to be
   UTC (GMT).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value HHMMSS00                               */
        time_struct = localtime (&amp;time_secs);
        return (MAKE_TIME (time_struct-&gt; tm_hour,
                           time_struct-&gt; tm_min,
                           time_struct-&gt; tm_sec,
                           0));
      }
}
</PRE>
<A NAME="timer_to_gmdate">&nbsp;</A>
<H3><A NAME="TOC84"><TT>timer_to_gmdate</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_gmdate (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long date value in
   Greenwich Mean Time (GMT). Dates are stored as long values:
   CCYYMMDD. If the supplied value is zero, returns zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value CCYYMMDD                               */
        time_struct = gmtime (&amp;time_secs);
        if (time_struct == NULL)        /*  If gmtime is not implemented     */
            time_struct = localtime (&amp;time_secs);

        ASSERT (time_struct);
        time_struct-&gt; tm_year += 1900;
        return (MAKE_DATE (time_struct-&gt; tm_year / 100,
                           time_struct-&gt; tm_year % 100,
                           time_struct-&gt; tm_mon + 1,
                           time_struct-&gt; tm_mday));
      }
}
</PRE>
<A NAME="timer_to_gmtime">&nbsp;</A>
<H3><A NAME="TOC85"><TT>timer_to_gmtime</TT></A></H3>
<PRE>
#include "sfldate.h"
long
timer_to_gmtime (time_t time_secs)
</PRE>
<H4>Synopsis</H4>
<P>Converts the supplied timer value into a long time value in
   Greenwich Mean Time (GMT). Times are stored as long values:
   HHMMSS00. On most systems the clock does not return
   centiseconds, so these are set to zero. If the supplied value
   is zero, returns zero.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    struct tm
        *time_struct;

    if (time_secs == 0)
        return (0);
    else
      {
        /*  Convert into a long value HHMMSS00                               */
        time_struct = gmtime (&amp;time_secs);
        if (time_struct == NULL)        /*  If gmtime is not implemented     */
            time_struct = localtime (&amp;time_secs);

        ASSERT (time_struct);
        return (MAKE_TIME (time_struct-&gt; tm_hour,
                           time_struct-&gt; tm_min,
                           time_struct-&gt; tm_sec,
                           0));
      }
}
</PRE>
<A NAME="time_to_csecs">&nbsp;</A>
<H3><A NAME="TOC86"><TT>time_to_csecs</TT></A></H3>
<PRE>
#include "sfldate.h"
long
time_to_csecs (long time)
</PRE>
<H4>Synopsis</H4>
<P>Converts a time (HHMMSSCC) into a number of centiseconds.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return ((long) (GET_HOUR   (time) * (long) INTERVAL_HOUR)
          + (long) (GET_MINUTE (time) * (long) INTERVAL_MIN)
          + (long) (GET_SECOND (time) * (long) INTERVAL_SEC)
          + (long) (GET_CENTI  (time)));
}
</PRE>
<A NAME="csecs_to_time">&nbsp;</A>
<H3><A NAME="TOC87"><TT>csecs_to_time</TT></A></H3>
<PRE>
#include "sfldate.h"
long
csecs_to_time (long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Converts a number of centiseconds (&lt; INTERVAL_DAY) into a
   time value (HHMMSSCC).
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        hour,
        min,
        sec;

    ASSERT (csecs &lt; INTERVAL_DAY);

    hour  = csecs / INTERVAL_HOUR;
    csecs = csecs % INTERVAL_HOUR;
    min   = csecs / INTERVAL_MIN;
    csecs = csecs % INTERVAL_MIN;
    sec   = csecs / INTERVAL_SEC;
    csecs = csecs % INTERVAL_SEC;
    return (MAKE_TIME (hour, min, sec, csecs));
}
</PRE>
<A NAME="future_date">&nbsp;</A>
<H3><A NAME="TOC88"><TT>future_date</TT></A></H3>
<PRE>
#include "sfldate.h"
void
future_date (long *date, long *time, long days, long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Calculates a future date and time from the date and time
   specified, plus an interval specified in days and 1/100th
   seconds. The date can be any date since some distant epoch
   (around 1600). If the date and time arguments are both zero,
   the current date and time are used. Either date and time
   arguments may be null.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        dummy_date = 0,
        dummy_time = 0;

    if (date == NULL)
        date = &amp;dummy_date;
    if (time == NULL)
        time = &amp;dummy_time;

    /*  Set date and time to NOW if necessary                                */
    if (*date == 0 &amp;&amp; *time == 0)
      {
        *date = <A HREF="sfldoc.htm#date_now">date now</A> ();
        *time = <A HREF="sfldoc.htm#time_now">time now</A> ();
      }

    /*  Get future date in days and centiseconds                             */
    days  = <A HREF="sfldoc.htm#date_to_days">date to days</A>  (*date) + days;
    csecs = <A HREF="sfldoc.htm#time_to_csecs">time to csecs</A> (*time) + csecs;

    /*  Normalise overflow in centiseconds                                   */
    while (csecs &gt;= INTERVAL_DAY)
      {
        days++;
        csecs -= INTERVAL_DAY;
      }

    /*  Convert date and time back into organised values                     */
    *date = <A HREF="sfldoc.htm#days_to_date">days to date</A>  (days);
    *time = <A HREF="sfldoc.htm#csecs_to_time">csecs to time</A> (csecs);
}
</PRE>
<A NAME="past_date">&nbsp;</A>
<H3><A NAME="TOC89"><TT>past_date</TT></A></H3>
<PRE>
#include "sfldate.h"
void
past_date (long *date, long *time, long days, long csecs)
</PRE>
<H4>Synopsis</H4>
<P>Calculates a past date and time from the date and time
   specified, minus an interval specified in days and 1/100th
   seconds. The date can be any date since some distant epoch
   (around 1600). If the date and time arguments are both zero,
   the current date and time are used. Either date and time
   arguments may be null.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    long
        dummy_date = 0,
        dummy_time = 0;

    if (date == NULL)
        date = &amp;dummy_date;
    if (time == NULL)
        time = &amp;dummy_time;

    /*  Set date and time to NOW if necessary                                */
    if (*date == 0 &amp;&amp; *time == 0)
      {
        *date = <A HREF="sfldoc.htm#date_now">date now</A> ();
        *time = <A HREF="sfldoc.htm#time_now">time now</A> ();
      }
    /*  Get past date in days and centiseconds                               */
    days  = <A HREF="sfldoc.htm#date_to_days">date to days</A>  (*date) - days;
    csecs = <A HREF="sfldoc.htm#time_to_csecs">time to csecs</A> (*time) - csecs;

    /*  Normalise underflow in centiseconds                                  */
    while (csecs &lt; 0)
      {
        days--;
        csecs += INTERVAL_DAY;
      }

    /*  Convert date and time back into organised values                     */
    *date = <A HREF="sfldoc.htm#days_to_date">days to date</A>  (days);
    *time = <A HREF="sfldoc.htm#csecs_to_time">csecs to time</A> (csecs);
}
</PRE>
<A NAME="date_diff">&nbsp;</A>
<H3><A NAME="TOC90"><TT>date_diff</TT></A></H3>
<PRE>
#include "sfldate.h"
void
date_diff (
    long date1, long time1,             /*  Date and time                    */
    long date2, long time2,             /*    minus this date and time       */
    long *days, long *csecs             /*  Gives these values               */
)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the difference between two date/time values, and
   returns the difference as a number of days and a number of
   centiseconds. The date can be any date since some distant epoch
   (around 1600). The calculation is date1:time1 - date2:time2.
   The returned values may be negative.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    *days  = <A HREF="sfldoc.htm#date_to_days">date to days</A>  (date1) - <A HREF="sfldoc.htm#date_to_days">date to days</A>  (date2);
    *csecs = <A HREF="sfldoc.htm#time_to_csecs">time to csecs</A> (time1) - <A HREF="sfldoc.htm#time_to_csecs">time to csecs</A> (time2);
}
</PRE>
<A NAME="valid_date">&nbsp;</A>
<H3><A NAME="TOC91"><TT>valid_date</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
valid_date (long date)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the date is valid or zero; returns FALSE if the
   date is not valid.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    int
        month,
        day;
    Bool
        feedback;
    static byte
        month_days [] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    month = GET_MONTH (date);
    day   = GET_DAY   (date);

    if (date == 0)
        feedback = TRUE;                /*  Zero date is okay                */
    else
    if (month &lt; 1 || month &gt; 12)
        feedback = FALSE;               /*  Month out of range               */
    else
    if ((day &lt; 1 || day &gt; month_days [month - 1])
    ||  (month == 2 &amp;&amp; day == 29 &amp;&amp; !<A HREF="sfldoc.htm#leap_year">leap year</A> (GET_YEAR (date))))
        feedback = FALSE;               /*  Day out of range                 */
    else
        feedback = TRUE;                /*  Zero date is okay                */

    return (feedback);
}
</PRE>
<A NAME="valid_time">&nbsp;</A>
<H3><A NAME="TOC92"><TT>valid_time</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
valid_time (long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the time is valid or zero; returns FALSE if the
   time is not valid.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (GET_SECOND (time) &lt; 60
        &amp;&amp;  GET_MINUTE (time) &lt; 60
        &amp;&amp;  GET_HOUR   (time) &lt; 24);
}
</PRE>
<A NAME="date_is_future">&nbsp;</A>
<H3><A NAME="TOC93"><TT>date_is_future</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
date_is_future (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified date and time are in the future.
   Returns FALSE if the date and time are in the past, or the
   present (which will be the past by the time you've read this).
   Date is specified as a YYYYMMDD value; time as HHMMSSCC.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (date  &gt; <A HREF="sfldoc.htm#date_now">date now</A> ()
        || (date == <A HREF="sfldoc.htm#date_now">date now</A> () &amp;&amp; time &gt; <A HREF="sfldoc.htm#time_now">time now</A> ()));
}
</PRE>
<A NAME="date_is_past">&nbsp;</A>
<H3><A NAME="TOC94"><TT>date_is_past</TT></A></H3>
<PRE>
#include "sfldate.h"
Bool
date_is_past (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified date and time are in the past.
   Returns FALSE if the date and time are in the future or present
   (which despite any assertion to the contrary, is not the past.
   Although that may change soon). Date is specified as YYYYMMDD;
   time as HHMMSSCC.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    return (date  &lt; <A HREF="sfldoc.htm#date_now">date now</A> ()
        || (date == <A HREF="sfldoc.htm#date_now">date now</A> () &amp;&amp; time &lt; <A HREF="sfldoc.htm#time_now">time now</A> ()));
}
</PRE>
<A NAME="timezone_string">&nbsp;</A>
<H3><A NAME="TOC95"><TT>timezone_string</TT></A></H3>
<PRE>
#include "sfldate.h"
char *
timezone_string (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a static string containing the time zone as a 4-digit
   number, with a leading '+' or '-' character. GMT is represented
   as "+0000"; Central European Time is "+1000". If the system
   does not support the timezone, returns "+0000".
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
#if (defined (TIMEZONE))
    static char
        formatted_string [6];           /*  -nnnn plus null                  */
    int
        minutes;                        /*  TIMEZONE is in seconds           */

    minutes = (int) (TIMEZONE / 60);
    sprintf (formatted_string, "%03d%02d", 0 - minutes / 60, minutes % 60);
    if (*formatted_string == '0')
        *formatted_string = '+';
    return  (formatted_string);
#else
    return ("+0000");
#endif
}
</PRE>
<A NAME="local_to_gmt">&nbsp;</A>
<H3><A NAME="TOC96"><TT>local_to_gmt</TT></A></H3>
<PRE>
#include "sfldate.h"
void
local_to_gmt (long date, long time, long *gmt_date, long *gmt_time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the specified date and time to GMT. Returns the GMT
   date and time in two arguments.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    time_t
        time_value;

    time_value = <A HREF="sfldoc.htm#date_to_timer">date to timer</A>   (date, time);
    *gmt_date  = <A HREF="sfldoc.htm#timer_to_gmdate">timer to gmdate</A> (time_value);
    *gmt_time  = <A HREF="sfldoc.htm#timer_to_gmtime">timer to gmtime</A> (time_value);
}
</PRE>
<A NAME="gmt_to_local">&nbsp;</A>
<H3><A NAME="TOC97"><TT>gmt_to_local</TT></A></H3>
<PRE>
#include "sfldate.h"
void
gmt_to_local (long gmt_date, long gmt_time, long *date, long *time)
</PRE>
<H4>Synopsis</H4>
<P>Converts the specified GMT date and time to the local time.
   Returns the local date and time in two arguments.
<H4>Source Code - (sfldate.c)</H4>
<PRE>
{
    time_t
        time_value;
    struct tm
        *time_struct;

    /*  Convert from GMT                                                     */
    time_value  = <A HREF="sfldoc.htm#date_to_timer">date to timer</A> (gmt_date, gmt_time) - TIMEZONE;
    time_struct = localtime (&amp;time_value);
    if (time_struct-&gt; tm_isdst)
      {
        time_value  += 3600;            /*  Adjust for daylight savings      */
        time_struct = localtime (&amp;time_value);
      }
    time_struct-&gt; tm_year += 1900;
    *date = MAKE_DATE (time_struct-&gt; tm_year / 100,
                       time_struct-&gt; tm_year % 100,
                       time_struct-&gt; tm_mon + 1,
                       time_struct-&gt; tm_mday);

    *time = MAKE_TIME (time_struct-&gt; tm_hour,
                       time_struct-&gt; tm_min,
                       time_struct-&gt; tm_sec,
                       0);
}
</PRE>
<H2><A NAME="TOC98">External data representation functions</A></H2>
<P>Filename: sflexdr.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/06/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read and write data in a portable format
   that is suitable for transmission to other systems. The
   principle is similar to the ONC XDR standard used in RPC, but
   somewhat simpler. The streams produced by these functions are
   not compatible with ONC XDR.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#exdr_write">exdr write</A><BR>
   (byte *buffer, const char *format, ...);
</LI>
<LI>int <A HREF="sfldoc.htm#exdr_writed">exdr writed</A><BR>
   (DESCR *buffer, const char *format, ...);
</LI>
<LI>int <A HREF="sfldoc.htm#exdr_read">exdr read</A><BR>
   (const byte *buffer, const char *format, ...);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflexdr.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLEXDR_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="exdr_write">&nbsp;</A>
<H3><A NAME="TOC99"><TT>exdr_write</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_write (byte *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a list of data items, prepares them according to the
   format string, and stores the result in the buffer. The buffer
   may be transmitted to another system, then decoded using
   exdr_read. Assumes nothing about system word sizes, etc.
   However, does assume that both systems use ASCII. If the buffer
   address is NULL, does not store the data items, but counts the
   effective size and returns that. The null-terminated format
   string can contain these sequences: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>c</B>  <TD ALIGN="LEFT">Single
   character value (may be multibyte) <TR><TD
   ALIGN="LEFT"><B>b</B>  <TD ALIGN="LEFT">Single byte value
   <TR><TD ALIGN="LEFT"><B>w,d</B>  <TD ALIGN="LEFT">Double byte
   value (16-bit short integer) <TR><TD ALIGN="LEFT"><B>q,l</B>
   <TD ALIGN="LEFT">Quad-byte value (32-bit long integer) <TR><TD
   ALIGN="LEFT"><B>s</B>  <TD ALIGN="LEFT">Null-terminated string
   (address of string), or NULL <TR><TD ALIGN="LEFT"><B>B</B>  <TD
   ALIGN="LEFT">Bool value (16-bit short integer) <TR><TD
   ALIGN="LEFT"><B>m</B>  <TD ALIGN="LEFT">Memory descriptor size
   (16-bit integer), &gt;= 0 <TR><TD ALIGN="LEFT"><B>M</B>  <TD
   ALIGN="LEFT">Memory descriptor body (pointer to block), or NULL
   <TR><TD ALIGN="LEFT"><B>h</B>  <TD ALIGN="LEFT">Huge memory
   descriptor size (31-bit integer), &gt;= 0 <TR><TD
   ALIGN="LEFT"><B>H</B>  <TD ALIGN="LEFT">Huge memory descriptor
   body (pointer), or NULL </TABLE> Each format sequence
   corresponds to one item in the list. The buffer must be large
   enough to hold the formatted result. Returns the size of the
   formatted data. Ignores invalid format characters; you can
   insert hyphens or spaces freely. Strings may be specified as
   (void *) NULL - they are stored as empty strings. Memory blocks
   may be specified as 0 and (void *) NULL together. Note that if
   you do not use the (void *) typecast when calling
   <A HREF="sfldoc.htm#exdr_write">exdr write</A>(), your code will fail on systems where an int
   is not the same size as a void *. Huge memory blocks cannot be
   more than 2^31 bytes large (2Gb) or 2^16 bytes if size_t is 16
   bits large.
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    byte
        byte_value,                     /*  Byte value from arguments        */
        *target,                        /*  Pointer into target buffer       */
        *block;                         /*  Source block for 'M' type        */
    char
        *string;                        /*  Source string for 's' type       */
    dbyte
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */

    ASSERT (format);
    va_start (argptr, format);          /*  Start variable arguments list    */
    target = buffer;

    while (*format)
      {
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                byte_value = (byte) va_arg (argptr, int);
                if (buffer)
                    *(byte *) target = byte_value;
                target += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                dbyte_value = htons ((short) va_arg (argptr, int));
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;dbyte_value);
                    *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                  }
                else
                    target += 2;
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                qbyte_value = htonl (va_arg (argptr, qbyte));
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;qbyte_value);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                  }
                else
                    target += 4;
                break;

            case 's':                   /*  Null-terminated string           */
                string = va_arg (argptr, char *);
                if (string)
                  {
                    if (buffer)
                        strcpy ((char *) target, string);
                    target += strlen (string) + 1;
                  }
                else                    /*  Store NULL as single null byte   */
                  {
                    if (buffer)
                        *(byte *) target++ = 0;
                    else
                        target += 1;
                  }
                break;

            case 'm':                   /*  Memory descriptor size           */
                memory_size = va_arg (argptr, int);
                dbyte_value = htons ((dbyte) memory_size);
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;dbyte_value);
                    *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                  }
                else
                    target += 2;
                break;
            case 'M':                   /*  Memory descriptor body           */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    if (buffer)
                        memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;

            case 'h':                   /*  Huge memory descriptor size       */
                memory_size = va_arg (argptr, qbyte);
                qbyte_value = htonl (memory_size);
                if (buffer)
                  {
                    *(byte *) target++ = *((byte *) &amp;qbyte_value);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                    *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                  }
                else
                    target += 4;
                break;
            case 'H':                   /*  Huge memory descriptor body       */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    if (buffer)
                        memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    return ((int) (target - buffer));
}
</PRE>
<A NAME="exdr_writed">&nbsp;</A>
<H3><A NAME="TOC100"><TT>exdr_writed</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_writed (DESCR *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>As <A HREF="sfldoc.htm#exdr_write">exdr write</A>(), but accepts a DESCR buffer. This is more
   secure. Aborts with an error if the formatted data would be too
   long for the buffer, if compiled with DEBUG. The buffer address
   cannot be NULL.
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    byte
        *target,                        /*  Pointer into target buffer       */
        *block;                         /*  Source block for 'M' type        */
    char
        *string;                        /*  Source string for 's' type       */
    dbyte
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */
    size_t
        used_size;                      /*  Current buffer data size         */

    ASSERT (buffer);
    ASSERT (format);
    va_start (argptr, format);          /*  Start variable arguments list    */
    target = buffer-&gt; data;

    while (*format)
      {
        used_size = (size_t) (target - buffer-&gt; data);
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                *(byte *) target = (byte) va_arg (argptr, int);
                ASSERT (used_size + 1 &lt;= buffer-&gt; size);
                target += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                dbyte_value = htons ((short) va_arg (argptr, int));
                ASSERT (used_size + 2 &lt;= buffer-&gt; size);
                *(byte *) target++ = *((byte *) &amp;dbyte_value);
                *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                qbyte_value = htonl (va_arg (argptr, qbyte));
                ASSERT (used_size + 4 &lt;= buffer-&gt; size);
                *(byte *) target++ = *((byte *) &amp;qbyte_value);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                break;

            case 's':                   /*  Null-terminated string           */
                string = va_arg (argptr, char *);
                if (string)
                  {
                    ASSERT (used_size + strlen (string) + 1 &lt;= buffer-&gt; size);
                    strcpy ((char *) target, string);
                    target += strlen (string) + 1;
                  }
                else                    /*  Store NULL as single null byte   */
                  {
                    ASSERT (used_size + 1 &lt;= buffer-&gt; size);
                    *(byte *) target++ = 0;
                  }
                break;

            case 'm':                   /*  Memory descriptor size           */
                memory_size = va_arg (argptr, int);
                ASSERT (used_size + 2 + memory_size &lt;= buffer-&gt; size);
                dbyte_value = htons ((dbyte) memory_size);
                *(byte *) target++ = *((byte *) &amp;dbyte_value);
                *(byte *) target++ = *((byte *) &amp;dbyte_value + 1);
                break;
            case 'M':                   /*  Memory descriptor body           */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;

            case 'h':                   /*  Huge memory descriptor size      */
                memory_size = va_arg (argptr, qbyte);
                ASSERT (used_size + 4 + memory_size &lt;= buffer-&gt; size);
                qbyte_value = htonl (memory_size);
                *(byte *) target++ = *((byte *) &amp;qbyte_value);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 1);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 2);
                *(byte *) target++ = *((byte *) &amp;qbyte_value + 3);
                break;
            case 'H':                   /*  Huge memory descriptor body      */
                block = va_arg (argptr, byte *);
                if (block)
                  {
                    memcpy (target, block, (size_t) memory_size);
                    target += (size_t) memory_size;
                  }
                else
                    ASSERT (memory_size == 0);
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    return ((int) (target - buffer-&gt; data));
}
</PRE>
<A NAME="exdr_read">&nbsp;</A>
<H3><A NAME="TOC101"><TT>exdr_read</TT></A></H3>
<PRE>
#include "sflexdr.h"
int
exdr_read (const byte *buffer, const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>Unpacks a buffer prepared by <A HREF="sfldoc.htm#exdr_write">exdr write</A>() into as set of
   data items as specified by a format string. See
   <A HREF="sfldoc.htm#exdr_write">exdr write</A>() for the syntax of the format string. Each
   format sequence corresponds to one item in in the list which
   must be specified as an address. Target strings and memory
   blocks must be large enough to hold the returned data: target
   strings and blocks can also be null, in which case the function
   calls mem_alloc to allocate heap memory. Note that you must
   supply a pointer to the string or memory block address, not the
   address itself. It is a common error to pass the address of a
   static block - see the example below for the *right* way to do
   it. Any of the argument addresses can be NULL, in which case
   that field is ignored. This is useful to get a few selected
   fields out of a message. Errors in the argument list can cause
   memory corruption and unpredictable program results. If a
   memory allocation fails, all previous memory allocations are
   "rolled back" and the function returns the value -1. Return
   codes: 0 - normal -1 - memory allocation failed
<H4>Examples</H4>
<PRE>
    char *string = NULL;
    byte buffer [1000];
    byte *buffaddr = buffer;
    int value, length;
    exdr_read (buffer, "qdsmM", NULL, &value, &string, &length, &buffaddr);
</PRE>
<H4>Source Code - (sflexdr.c)</H4>
<PRE>
{
    MEMTRN
        *memtrn;                        /*  Memory transaction               */
    va_list
        argptr;                         /*  Argument list pointer            */
    void
        *target;                        /*  Source data item address         */
    dbyte
        string_size,                    /*  String size                      */
        dbyte_value;                    /*  Network format dbyte value       */
    qbyte
        memory_size = 0,                /*  Memory descriptor size value     */
        qbyte_value;                    /*  Network format qbyte value       */

    ASSERT (buffer);
    ASSERT (format);
    memtrn = <A HREF="sfldoc.htm#mem_new_trans">mem new trans</A> ();

    va_start (argptr, format);          /*  Start variable arguments list    */
    while (*format)
      {
        target = va_arg (argptr, void *);
        switch (*format++)
          {
            case 'c':                   /*  Character                        */
            case 'b':                   /*  Single byte                      */
                if (target)
                    *(byte *) target = *(byte *) buffer;
                buffer += 1;
                break;

            case 'd':                   /*  Signed short integer             */
            case 'w':                   /*  Unsigned short integer           */
            case 'B':                   /*  Bool                             */
                *((byte *) &amp;dbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;dbyte_value + 1) = *(byte *) buffer++;
                if (target)
                    *(dbyte *) target = ntohs (dbyte_value);
                break;

            case 'l':                   /*  Signed long (32-bit)             */
            case 'q':                   /*  4-byte unsigned value            */
                *((byte *) &amp;qbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 1) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 2) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 3) = *(byte *) buffer++;
                if (target)
                    *(qbyte *) target = ntohl (qbyte_value);
                break;

            case 's':                   /*  Null-terminated string           */
                string_size = strlen ((char *) buffer) + 1;
                if (target)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc (string_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer, string_size);
                    else
                      {
                        <A HREF="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += string_size;
                break;

            case 'm':                   /*  Memory descriptor size           */
                *((byte *) &amp;dbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;dbyte_value + 1) = *(byte *) buffer++;
                memory_size = ntohs (dbyte_value);
                if (target)
                    *(dbyte *) target = (dbyte) memory_size;
                break;
            case 'M':                   /*  Memory descriptor body           */
                if (target &amp;&amp; memory_size &gt; 0)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc ((size_t) memory_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer,
                                 (size_t) memory_size);
                    else
                      {
                        <A HREF="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += (size_t) memory_size;
                break;

            case 'h':                   /*  Huge memory descriptor size      */
                *((byte *) &amp;qbyte_value)     = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 1) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 2) = *(byte *) buffer++;
                *((byte *) &amp;qbyte_value + 3) = *(byte *) buffer++;
                memory_size = ntohl (qbyte_value);
                if (target)
                    *(qbyte *) target = memory_size;
                break;
            case 'H':                   /*  Huge memory descriptor body      */
                if (target &amp;&amp; memory_size &gt; 0)
                  {
                    if (*(byte **) target == NULL)
                        *(byte **) target = mem_alloc ((size_t) memory_size);
                    if (*(byte **) target)
                        memcpy (*(byte **) target, buffer,
                                 (size_t) memory_size);
                    else
                      {
                        <A HREF="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                        return (-1);
                      }
                  }
                buffer += (size_t) memory_size;
                break;
          }
      }
    va_end (argptr);                    /*  End variable arguments list      */
    <A HREF="sfldoc.htm#mem_commit">mem commit</A> (memtrn);
    return (0);
}
</PRE>
<H2><A NAME="TOC102">Fast string searching functions</A></H2>
<P>Filename: sflfind.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/04/24 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/05/03
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Searches for a pattern within a string or block of memory using
   a variant of the Boyer-Moore algorithm (improved by Horspool
   and Sunday). As fast or faster than the normal Boyer-Moore
   algorithm for most search strings, and much simpler. Includes a
   basic function for searching blocks of memory with known sizes,
   plus an envelope that searches null-delimited strings. Provides
   the option of repeatedly searching for the same pattern without
   re-parsing the pattern each time. Original algorithm published
   by BOYER, R., and S. MOORE 1977, "A Fast String Searching
   Algorithm." CACM, 20, 762-72. Simplifications by HORSPOOL, R.
   N. 1980, "Practical Fast Searching in Strings." Software -
   Practice and Experience, 10, 501-06. More improvements by HUME,
   A., and D. M. SUNDAY 1991, "Fast String Searching." AT&amp;T
   Bell Labs Computing Science Technical Report No. 156.
   Implemented in C by P. Hintjens. <A HREF="sfldoc.htm#strfind_r">strfind r</A>() and
   <A HREF="sfldoc.htm#memfind_r">memfind r</A>(), are reentrant versions of <A HREF="sfldoc.htm#strfind">strfind</A>() and
   <A HREF="sfldoc.htm#memfind">memfind</A>() for single searches, and <A HREF="sfldoc.htm#strfind_rb">strfind rb</A>() and
   <A HREF="sfldoc.htm#memfind_rb">memfind rb</A>() are reentrant versions of <A HREF="sfldoc.htm#strfind">strfind</A>() and
   <A HREF="sfldoc.htm#memfind">memfind</A>() supporting repeat searches against the same
   pattern.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#strfind">strfind</A><BR>
   (const char *string, const char *pattern, Bool repeat_find);
</LI>
<LI>char * <A HREF="sfldoc.htm#strfind_r">strfind r</A><BR>
   (const char *string, const char *pattern);
</LI>
<LI>char * <A HREF="sfldoc.htm#strfind_rb">strfind rb</A><BR>
   (const char *string, const char *pattern, size_t *shift, Bool
   *repeat_find);
</LI>
<LI>void * <A HREF="sfldoc.htm#memfind">memfind</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size, Bool repeat_find);
</LI>
<LI>void * <A HREF="sfldoc.htm#memfind_r">memfind r</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size);
</LI>
<LI>void * <A HREF="sfldoc.htm#memfind_rb">memfind rb</A><BR>
   (const void *block, size_t block_size, const void *pattern,
   size_t pattern_size, size_t *shift, Bool *repeat_find);
</LI>
<LI>char * <A HREF="sfldoc.htm#txtfind">txtfind</A><BR>
   (const char *string, const char *pattern);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflfind.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLFIND_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="strfind">&nbsp;</A>
<H3><A NAME="TOC103"><TT>strfind</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind (const char *string,            /*  String containing data           */
         const char *pattern,           /*  Pattern to search for            */
         Bool repeat_find)              /*  Same pattern as last time        */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found. If you
   repeatedly scan for the same pattern, use the repeat_find
   argument. If this is TRUE, the function does not re-parse the
   pattern. You must of course call the function with repeat_find
   equal to FALSE the first time. This function is meant to handle
   character data, and is most effective when you work with large
   strings. To search binary data use <A HREF="sfldoc.htm#memfind">memfind</A>(). Will not work
   on multibyte characters.
<H4>Examples</H4>
<PRE>
    char *result;

    result = strfind ("abracadabra", "cad", FALSE);
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    static size_t
        searchbuf [256];                /*  Fixed search buffer              */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */

    return (char *) <A HREF="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                searchbuf, &amp;repeat_find);
}
</PRE>
<A NAME="strfind_r">&nbsp;</A>
<H3><A NAME="TOC104"><TT>strfind_r</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind_r (const char *string,          /*  String containing data           */
           const char *pattern)         /*  Pattern to search for            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found. This
   function is meant to handle character data, and is most
   effective when you work with large strings. To search binary
   data use <A HREF="sfldoc.htm#memfind">memfind</A>(). Will not work on multibyte characters.
   Reentrant.
<H4>Examples</H4>
<PRE>
    char *result;

    result = strfind_r ("abracadabra", "cad");
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        searchbuf [256];                /*  One-time search buffer           */
    Bool
        secondtime = FALSE;             /*  Search buffer init needed        */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */

    return (char *) <A HREF="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                searchbuf, &amp;secondtime);
}
</PRE>
<A NAME="strfind_rb">&nbsp;</A>
<H3><A NAME="TOC105"><TT>strfind_rb</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
strfind_rb (const char *string,         /*  String containing data           */
            const char *pattern,        /*  Pattern to search for            */
            size_t     *shift,          /*  Working buffer between searches  */
            Bool       *repeat_find)    /*  Flag for first/later search      */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a string using the Boyer-Moore-
   Horspool-Sunday algorithm. The string and pattern are null-
   terminated strings. Returns a pointer to the pattern if found
   within the string, or NULL if the pattern was not found.
   Supports more efficient repeat searches (for the same pattern),
   through a supplied search buffer. The search buffer must be
   long enough to contain 256 (2**8) size_t entries. On the first
   call repeat_find must be set to FALSE. After the search buffer
   has been initialised, repeat_find will be set to TRUE by the
   function, avoiding the search buffer initialisation on later
   calls. This function is most effective when repeated searches
   are made for the same pattern in one or more strings. This
   function is meant to handle character data, and is most
   effective when you work with large strings. To search binary
   data use <A HREF="sfldoc.htm#memfind">memfind</A>(). Will not work on multibyte characters.
   Reentrant.
<H4>Examples</H4>
<PRE>
    char   *result;
    Bool   repeat_search = FALSE;
    size_t searchbuf[256];

    result = strfind_rb ("abracadabra", "cad", searchbuf, &repeat_search);
    if (result)
      {
        puts (result);
        result = strfind_rb ("cad/cam", "cad", searchbuf, &repeat_search);
        if (result)
            puts (result);
      }
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fall through if not debugging    */
    ASSERT (shift);
    ASSERT (repeat_find);

    return (char *) <A HREF="sfldoc.htm#memfind_rb">memfind rb</A> (string,    strlen (string),
                                pattern,   strlen (pattern),
                                shift,     repeat_find);
}
</PRE>
<A NAME="memfind">&nbsp;</A>
<H3><A NAME="TOC106"><TT>memfind</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind (const void  *block,            /*  Block containing data            */
         size_t       block_size,       /*  Size of block in bytes           */
         const void  *pattern,          /*  Pattern to search for            */
         size_t       pattern_size,     /*  Size of pattern block            */
         Bool         repeat_find)      /*  Same pattern as last time        */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. If you repeatedly scan for
   the same pattern, use the repeat_find argument. If this is
   TRUE, the function does not re-parse the pattern. This function
   is meant to handle binary data. If you need to search strings,
   use the strfind_r or <A HREF="sfldoc.htm#strfind_rb">strfind rb</A>() functions. Non-Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    static size_t
        searchbuf [256];                /*  Static shared search buffer      */

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  full through if not debugging    */

    return <A HREF="sfldoc.htm#memfind_rb">memfind rb</A> (block, block_size, pattern, pattern_size,
                       searchbuf, &amp;repeat_find);
}
</PRE>
<A NAME="memfind_r">&nbsp;</A>
<H3><A NAME="TOC107"><TT>memfind_r</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind_r (const void  *block,          /*  Block containing data            */
           size_t       block_size,     /*  Size of block in bytes           */
           const void  *pattern,        /*  Pattern to search for            */
           size_t       pattern_size)   /*  Size of pattern block            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. This function is meant to
   handle binary data, for a single search for a given pattern. If
   you need to search strings, use the <A HREF="sfldoc.htm#strfind_r">strfind r</A>() or
   <A HREF="sfldoc.htm#strfind_rb">strfind rb</A>() functions. If you want to do efficient
   repeated searches for one pattern, use <A HREF="sfldoc.htm#memfind_rb">memfind rb</A>().
   Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        searchbuf [256];                /*  One-time search buffer           */
    Bool
        secondtime  = FALSE;

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  full through if not debugging    */

    return <A HREF="sfldoc.htm#memfind_rb">memfind rb</A> (block, block_size, pattern, pattern_size,
                       searchbuf, &amp;secondtime);
}
</PRE>
<A NAME="memfind_rb">&nbsp;</A>
<H3><A NAME="TOC108"><TT>memfind_rb</TT></A></H3>
<PRE>
#include "sflfind.h"
void *
memfind_rb (const void  *in_block,      /*  Block containing data            */
            size_t       block_size,    /*  Size of block in bytes           */
            const void  *in_pattern,    /*  Pattern to search for            */
            size_t       pattern_size,  /*  Size of pattern block            */
            size_t      *shift,         /*  Shift table (search buffer)      */
            Bool        *repeat_find)   /*  TRUE: search buffer already init */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a pattern in a block of memory using the Boyer-
   Moore-Horspool-Sunday algorithm. The block and pattern may
   contain any values; you must explicitly provide their lengths.
   Returns a pointer to the pattern if found within the block, or
   NULL if the pattern was not found. On the first search with a
   given pattern, *repeat_find should be FALSE. It will be set to
   TRUE after the shift table is initialised, allowing the
   initialisation phase to be skipped on subsequent searches.
   shift must point to an array big enough to hold 256 (8**2)
   size_t values. This function is meant to handle binary data,
   for repeated searches for the same pattern. If you need to
   search strings, use the <A HREF="sfldoc.htm#strfind_r">strfind r</A>() or <A HREF="sfldoc.htm#strfind_rb">strfind rb</A>()
   functions. If you wish to search for a pattern only once
   consider using <A HREF="sfldoc.htm#memfind_r">memfind r</A>(). Reentrant.
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        byte_nbr,                       /*  Distance through block           */
        match_size;                     /*  Size of matched part             */
    const byte
        *match_base = NULL,             /*  Base of match of pattern         */
        *match_ptr  = NULL,             /*  Point within current match       */
        *limit      = NULL;             /*  Last potiental match point       */
    const byte
        *block   = (byte *) in_block,   /*  Concrete pointer to block data   */
        *pattern = (byte *) in_pattern; /*  Concrete pointer to search value */

    ASSERT (block);                     /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fail gracefully if not debugging */
    ASSERT (shift);                     /*  NULL repeat_find =&gt; is false     */
    if (block == NULL || pattern == NULL || shift == NULL)
        return (NULL);

    /*  Pattern must be smaller or equal in size to string                   */
    if (block_size &lt; pattern_size)
        return (NULL);                  /*  Otherwise it's not found         */

    if (pattern_size == 0)              /*  Empty patterns match at start    */
        return ((void *)block);

    /*  Build the shift table unless we're continuing a previous search      */

    /*  The shift table determines how far to shift before trying to match   */
    /*  again, if a match at this point fails.  If the byte after where the  */
    /*  end of our pattern falls is not in our pattern, then we start to     */
    /*  match again after that byte; otherwise we line up the last occurence */
    /*  of that byte in our pattern under that byte, and try match again.    */

    if (!repeat_find || !*repeat_find)
      {
        for (byte_nbr = 0; byte_nbr &lt; 256; byte_nbr++)
            shift [byte_nbr] = pattern_size + 1;
        for (byte_nbr = 0; byte_nbr &lt; pattern_size; byte_nbr++)
            shift [(byte) pattern [byte_nbr]] = pattern_size - byte_nbr;

        if (repeat_find)
            *repeat_find = TRUE;
      }

    /*  Search for the block, each time jumping up by the amount             */
    /*  computed in the shift table                                          */

    limit = block + (block_size - pattern_size + 1);
    ASSERT (limit &gt; block);

    for (match_base = block;
         match_base &lt; limit;
         match_base += shift [*(match_base + pattern_size)])
      {
        match_ptr  = match_base;
        match_size = 0;

        /*  Compare pattern until it all matches, or we find a difference    */
        while (*match_ptr++ == pattern [match_size++])
          {
            ASSERT (match_size &lt;= pattern_size &amp;&amp;
                    match_ptr == (match_base + match_size));

            /*  If we found a match, return the start address                */
            if (match_size &gt;= pattern_size)
              return ((void*)(match_base));

          }
      }
    return (NULL);                      /*  Found nothing                    */
}
</PRE>
<A NAME="txtfind">&nbsp;</A>
<H3><A NAME="TOC109"><TT>txtfind</TT></A></H3>
<PRE>
#include "sflfind.h"
char *
txtfind (const char *string,            /*  String containing data           */
         const char *pattern)           /*  Pattern to search for            */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a case-insensitive text pattern in a string using
   the Boyer-Moore-Horspool-Sunday algorithm. The string and
   pattern are null-terminated strings. Returns a pointer to the
   pattern if found within the string, or NULL if the pattern was
   not found. Will match strings irrespective of case. To match
   exact strings, use <A HREF="sfldoc.htm#strfind">strfind</A>(). Will not work on multibyte
   characters.
<H4>Examples</H4>
<PRE>
    char *result;

    result = txtfind ("AbracaDabra", "cad");
    if (result)
        puts (result);
</PRE>
<H4>Source Code - (sflfind.c)</H4>
<PRE>
{
    size_t
        shift [256];                    /*  Shift distance for each value    */
    size_t
        string_size,
        pattern_size,
        byte_nbr,                       /*  Index into byte array            */
        match_size;                     /*  Size of matched part             */
    const char
        *match_base = NULL,             /*  Base of match of pattern         */
        *match_ptr  = NULL,             /*  Point within current match       */
        *limit      = NULL;             /*  Last potiental match point       */

    ASSERT (string);                    /*  Expect non-NULL pointers, but    */
    ASSERT (pattern);                   /*  fail gracefully if not debugging */
    if (string == NULL || pattern == NULL)
        return (NULL);

    string_size  = strlen (string);
    pattern_size = strlen (pattern);

    /*  Pattern must be smaller or equal in size to string                   */
    if (string_size &lt; pattern_size)
        return (NULL);                  /*  Otherwise it cannot be found     */

    if (pattern_size == 0)              /*  Empty string matches at start    */
        return (char *) string;

    /*  Build the shift table                                                */

    /*  The shift table determines how far to shift before trying to match   */
    /*  again, if a match at this point fails.  If the byte after where the  */
    /*  end of our pattern falls is not in our pattern, then we start to     */
    /*  match again after that byte; otherwise we line up the last occurence */
    /*  of that byte in our pattern under that byte, and try match again.    */

    for (byte_nbr = 0; byte_nbr &lt; 256; byte_nbr++)
        shift [byte_nbr] = pattern_size + 1;

    for (byte_nbr = 0; byte_nbr &lt; pattern_size; byte_nbr++)
        shift [(byte) tolower (pattern [byte_nbr])] = pattern_size - byte_nbr;

    /*  Search for the string.  If we don't find a match, move up by the     */
    /*  amount we computed in the shift table above, to find location of     */
    /*  the next potiental match.                                            */

    limit = string + (string_size - pattern_size + 1);
    ASSERT (limit &gt; string);

    for (match_base = string;
         match_base &lt; limit;
         match_base += shift [(byte) tolower (*(match_base + pattern_size))])
      {
        match_ptr  = match_base;
        match_size = 0;

        /*  Compare pattern until it all matches, or we find a difference    */
        while (tolower (*match_ptr++) == tolower (pattern [match_size++]))
          {
            ASSERT (match_size &lt;= pattern_size &amp;&amp;
                    match_ptr == (match_base + match_size));

            /*  If we found a match, return the start address                */
            if (match_size &gt;= pattern_size)
                return ((char *)(match_base));
          }
      }
    return (NULL);                      /*  Found nothing                    */
}
</PRE>
<H2><A NAME="TOC110">File-access functions</A></H2>
<P>Filename: sflfile.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 92/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/08/30
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read and write files with explicit new-
   line/carriage-return control; to find files on a path; to copy
   files, check files' protection, etc.
<H4>List of Functions</H4>
<UL>
<LI>FILE * <A HREF="sfldoc.htm#file_open">file open</A><BR>
   (const char *filename, char mode);
</LI>
<LI>FILE * <A HREF="sfldoc.htm#file_locate">file locate</A><BR>
   (const char *path, const char *name, const char *ext);
</LI>
<LI>int <A HREF="sfldoc.htm#file_close">file close</A><BR>
   (FILE *stream);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_read">file read</A><BR>
   (FILE *stream, char *string);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_readn">file readn</A><BR>
   (FILE *stream, char *string, int line_max);
</LI>
<LI>char * <A HREF="sfldoc.htm#file_write">file write</A><BR>
   (FILE *stream, const char *string);
</LI>
<LI>int <A HREF="sfldoc.htm#file_copy">file copy</A><BR>
   (const char *dest, const char *src, char mode);
</LI>
<LI>int <A HREF="sfldoc.htm#file_concat">file concat</A><BR>
   (const char *dest, const char *src);
</LI>
<LI>int <A HREF="sfldoc.htm#file_rename">file rename</A><BR>
   (const char *oldname, const char *newname);
</LI>
<LI>int <A HREF="sfldoc.htm#file_delete">file delete</A><BR>
   (const char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#file_where">file where</A><BR>
   (char mode, const char *path, const char *name, const char
   *ext);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_exists">file exists</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_cycle">file cycle</A><BR>
   (const char *filename, int how);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_cycle_needed">file cycle needed</A><BR>
   (const char *filename, int how);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_has_changed">file has changed</A><BR>
   (const char *filename, long old_date, long old_time);
</LI>
<LI>Bool <A HREF="sfldoc.htm#safe_to_extend">safe to extend</A><BR>
   (const char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#default_extension">default extension</A><BR>
   (char *dest, const char *src, const char *ext);
</LI>
<LI>char * <A HREF="sfldoc.htm#fixed_extension">fixed extension</A><BR>
   (char *dest, const char *src, const char *ext);
</LI>
<LI>char * <A HREF="sfldoc.htm#strip_extension">strip extension</A><BR>
   (char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#strip_file_path">strip file path</A><BR>
   (char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#strip_file_name">strip file name</A><BR>
   (char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_readable">file is readable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_writeable">file is writeable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_executable">file is executable</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_directory">file is directory</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_program">file is program</A><BR>
   (const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_is_legal">file is legal</A><BR>
   (const char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#file_exec_name">file exec name</A><BR>
   (const char *filename);
</LI>
<LI>long <A HREF="sfldoc.htm#get_file_size">get file size</A><BR>
   (const char *filename);
</LI>
<LI>time_t <A HREF="sfldoc.htm#get_file_time">get file time</A><BR>
   (const char *filename);
</LI>
<LI>long <A HREF="sfldoc.htm#get_file_lines">get file lines</A><BR>
   (const char *filename);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#file_slurp">file slurp</A><BR>
   (const char *filename);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#file_slurpl">file slurpl</A><BR>
   (const char *filename);
</LI>
<LI>dbyte <A HREF="sfldoc.htm#file_set_eoln">file set eoln</A><BR>
   (char *dest, const char *src, dbyte src_size, Bool add_cr);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_tmp_file_name">get tmp file name</A><BR>
   (const char *path, qbyte *index, const char *ext);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflfile.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FILE_DIR_MAX</B>  </TT>
<TD ALIGN="LEFT">64 /* Max size of directory name */
<TR><TD ALIGN="LEFT"><TT><B>FILE_NAME_MAX</B>  </TT>
<TD ALIGN="LEFT">160 /* Max size of filename */
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_APPEND_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_APPEND_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_READ_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_READ_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_WRITE_BINARY</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FOPEN_WRITE_TEXT</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>_SFLFILE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>file_lines(f)</B>  </TT>
<TD ALIGN="LEFT">get_file_lines(f) /* Changed 98/07/23 */
</TABLE>
<A NAME="file_open">&nbsp;</A>
<H3><A NAME="TOC111"><TT>file_open</TT></A></H3>
<PRE>
#include "sflfile.h"
FILE *
file_open (
    const char *filename,               /*  Name of file to open             */
    char mode)                          /*  'r', 'w', or 'a'                 */
</PRE>
<H4>Synopsis</H4>
<P>opens a text file for reading or writing. Use in combination
   with the <A HREF="sfldoc.htm#file_read">file read</A>() and <A HREF="sfldoc.htm#file_write">file write</A>() functions. These
   functions handle end-of-line sequences using a heuristic that
   works as follows. ... (at this point the author went for a pint
   of beer and has not been seen since. We're hoping that the old
   version - following - is ok.)Opens the specified file for input
   or output. If you use the file_read / file_write functions you
   must open the file using this function. This set of functions
   lets you read files without concern for the line format (CRLF
   or LF). Mode should be one of 'r' 'w' 'a'. Returns a FILE
   pointer if the file is opened correctly; else NULL. Sets the
   global variable file_crlf to FALSE on all systems except MS-DOS
   (and Windows by inheritence) where it is set to TRUE by
   default. When opening a file in append mode, automatically
   removes any Ctrl-Z character under MS-DOS or OS/2.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);

#   if (defined (MSDOS_FILESYSTEM))
    file_crlf = TRUE;
#   else
    file_crlf = FALSE;
#   endif

    if (mode == 'r')
        return (fopen (filename, FOPEN_READ_BINARY));
    else
    if (mode == 'w')
        return (fopen (filename, FOPEN_WRITE_BINARY));
    else
    if (mode == 'a'
    &amp;&amp;  <A HREF="sfldoc.htm#safe_to_extend">safe to extend</A> (filename))
        return (fopen (filename, FOPEN_APPEND_BINARY));
    else
        return (NULL);                  /*  Invalid mode                     */
}
</PRE>
<A NAME="file_locate">&nbsp;</A>
<H3><A NAME="TOC112"><TT>file_locate</TT></A></H3>
<PRE>
#include "sflfile.h"
FILE *
file_locate (
    const char *path,
    const char *name,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Combines the functions of <A HREF="sfldoc.htm#file_where">file where</A>() and file_open when
   you want to read a file. Searches for a file on a specified
   path, opens the file if found, and returns a FILE * for the
   open file. Returns NULL if the file was not found or could not
   be opened for reading.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (name);
    filename = <A HREF="sfldoc.htm#file_where">file where</A> ('r', path, name, ext);
    if (filename)
        return (<A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r'));
    else
        return (NULL);
}
</PRE>
<A NAME="file_close">&nbsp;</A>
<H3><A NAME="TOC113"><TT>file_close</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_close (
    FILE *stream)
</PRE>
<H4>Synopsis</H4>
<P>Closes an open file stream. Returns 0 if okay, -1 if there was
   an error. For now, equivalent to fclose, and supplied because
   it looks nice when you use <A HREF="sfldoc.htm#file_open">file open</A>() and <A HREF="sfldoc.htm#file_close">file close</A>()
   together.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (stream);
    return (fclose (stream));
}
</PRE>
<A NAME="file_read">&nbsp;</A>
<H3><A NAME="TOC114"><TT>file_read</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_read (
    FILE *stream,
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Reads a line of text delimited by newline from the stream. The
   string must be LINE_MAX + 1 long. Places a null byte in place
   of the newline character. Expands tab characters to every 8th
   column. Returns TRUE when there is more input waiting; FALSE
   when the last line of the file has been read. Sets the global
   variable file_crlf to TRUE if CR was found in the file. This
   variable is by default FALSE. It is also used by file_write.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int
        ch,                             /*  Character read from file         */
        cnbr;                           /*  Index into returned string       */

    ASSERT (stream);
    ASSERT (string);

    cnbr = 0;                           /*  Start at the beginning...        */
    memset (string, ' ', LINE_MAX);     /*    and prepare entire line        */
    for (;;)
      {
        ch = fgetc (stream);            /*  Get next character from file     */
        if (ch == '\t')                 /*  Jump if tab                      */
            cnbr = ((cnbr &gt;&gt; 3) &lt;&lt; 3) + 8;
        else
        if (ch == '\r')                 /*  Found carriage-return            */
            file_crlf = TRUE;           /*    Set flag and ignore CR         */
        else
        if ((ch == '\n')                /*  Have end of line                 */
        ||  (ch == EOF)                 /*    or end of file                 */
        ||  (ch == 26))                 /*    or MS-DOS Ctrl-Z               */
          {
            string [cnbr] = '\0';       /*  Terminate string                 */
            return (ch == '\n' || cnbr);    /*  and return TRUE/FALSE        */
          }
        else
        if (cnbr &lt; LINE_MAX)
            string [cnbr++] = (char) ch;    /*  Else add char to string      */

        if (cnbr &gt;= LINE_MAX)           /*  Return in any case if line is    */
          {                             /*    too long - the line will be    */
            string [LINE_MAX] = '\0';   /*    cut into pieces                */
            return (TRUE);
          }
      }
}
</PRE>
<A NAME="file_readn">&nbsp;</A>
<H3><A NAME="TOC115"><TT>file_readn</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_readn (
    FILE *stream,
    char *string,
    int   line_max)
</PRE>
<H4>Synopsis</H4>
<P>Works as <A HREF="sfldoc.htm#file_read">file read</A>() but with a maximum line-length
   specified by the caller. The supplied buffer must be at least
   as large as the specified line_max + 1.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int
        ch,                             /*  Character read from file         */
        cnbr;                           /*  Index into returned string       */

    ASSERT (stream);
    ASSERT (string);

    cnbr = 0;                           /*  Start at the beginning...        */
    memset (string, ' ', line_max);     /*    and prepare entire line        */
    for (;;)
      {
        ch = fgetc (stream);            /*  Get next character from file     */
        if (ch == '\t')                 /*  Jump if tab                      */
            cnbr = ((cnbr &gt;&gt; 3) &lt;&lt; 3) + 8;
        else
        if (ch == '\r')                 /*  Found carriage-return            */
            file_crlf = TRUE;           /*    Set flag and ignore CR         */
        else
        if ((ch == '\n')                /*  Have end of line                 */
        ||  (ch == EOF)                 /*    or end of file                 */
        ||  (ch == 26))                 /*    or MS-DOS Ctrl-Z               */
          {
            string [cnbr] = '\0';       /*  Terminate string                 */
            return (ch == '\n' || cnbr);    /*  and return TRUE/FALSE        */
          }
        else
        if (cnbr &lt; line_max)
            string [cnbr++] = (char) ch;    /*  Else add char to string      */

        if (cnbr &gt;= line_max)           /*  Return in any case if line is    */
          {                             /*    too long - the line will be    */
            string [line_max] = '\0';   /*    cut into pieces                */
            return (TRUE);
          }
      }
}
</PRE>
<A NAME="file_write">&nbsp;</A>
<H3><A NAME="TOC116"><TT>file_write</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_write (
    FILE *stream,
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Writes a line of text to the specified output stream. If the
   variable file_crlf is TRUE, adds a carriage-return to the line
   being written to the output stream. This variable is supplied
   so that you can either ignore crlf issues (do nothing), or
   handle them explicitly (play with file_crlf). Returns the
   string written, or NULL if no data could be written to the
   file.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (stream);
    ASSERT (string);

    fputs (string, stream);
    if (file_crlf)
        fputc ('\r', stream);

    if (fputc ('\n', stream) == EOF)
        return (NULL);
    else
        return ((char *) string);
}
</PRE>
<A NAME="file_copy">&nbsp;</A>
<H3><A NAME="TOC117"><TT>file_copy</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_copy (
    const char *dest,
    const char *src,
    char mode)
</PRE>
<H4>Synopsis</H4>
<P>Copies a file called src to one called dest. The dest file may
   not already exist. If mode is 'b', copies a binary file; if
   mode is 't', copies a text file. This distinction only applies
   to MS-DOS file systems; on other platforms the two modes are
   equivalent. Returns 0 if no problems occurred, -1 if an error
   occurred, 1 if the destination file already exists.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    FILE *inf, *outf;
    char *buffer,
         openmode [3] = "??";
    size_t chars_read;                  /*  Amount read from stream          */
    int  feedback = 0;

    ASSERT (dest);
    ASSERT (src);
    if (<A HREF="sfldoc.htm#file_exists">file exists</A> (dest))
        return (1);                     /*  Cancel: dest already exists      */

#   if (defined (MSDOS_FILESYSTEM))
    openmode [1] = mode;
#   else
    openmode [1] = 0;
#   endif
    openmode [0] = 'r';
    if ((inf = fopen (src, openmode)) == NULL)
        return (-1);                    /*  Input file not found             */

    if ((buffer = mem_alloc (SHRT_MAX)) == NULL)
        feedback = -1;                  /*  Insufficient memory for buffer   */
    else
      {
        openmode [0] = 'w';
        if ((outf = fopen (dest, openmode)) == NULL)
          {
            mem_free (buffer);
            return (-1);                /*  Could not create output file     */
          }
        while ((chars_read = fread (buffer, 1, SHRT_MAX, inf)) != 0)
            if (fwrite (buffer, 1, chars_read, outf) != chars_read)
              {
                feedback = -1;
                break;
              }
        fclose (outf);
        mem_free (buffer);
      }
    fclose (inf);
    return (feedback);
}
</PRE>
<A NAME="file_concat">&nbsp;</A>
<H3><A NAME="TOC118"><TT>file_concat</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_concat (
    const char *dest,
    const char *src)
</PRE>
<H4>Synopsis</H4>
<P>Copies the contents of dest onto src. If src does not exist, it
   is created. Returns 0 if the concatenation operation succeeded,
   or -1 if some error occurred.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    FILE *inf, *outf;
    char *buffer;
    size_t chars_read;                  /*  Amount read from stream          */
    int  feedback = 0;

    ASSERT (dest);
    ASSERT (src);

    if ((inf = fopen (src, FOPEN_READ_BINARY)) == NULL)
        return (-1);                    /*  Input file not found             */

    if ((buffer = mem_alloc (SHRT_MAX)) == NULL)
        feedback = -1;                  /*  Insufficient memory for buffer   */
    else
      {
        if ((outf = fopen (dest, FOPEN_APPEND_BINARY)) == NULL)
          {
            mem_free (buffer);
            return (-1);                /*  Could not create output file     */
          }
        while ((chars_read = fread (buffer, 1, SHRT_MAX, inf)) != 0)
            if (fwrite (buffer, 1, chars_read, outf) != chars_read)
              {
                feedback = -1;
                break;
              }
        fclose (outf);
        mem_free (buffer);
      }
    fclose (inf);
    return (feedback);
}
</PRE>
<A NAME="file_rename">&nbsp;</A>
<H3><A NAME="TOC119"><TT>file_rename</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_rename (
    const char *oldname,
    const char *newname)
</PRE>
<H4>Synopsis</H4>
<P>Renames a file from oldname to newname. Returns 0 if okay, or -
   1 if there was an error. Does not overwrite existing files.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#   if (defined (MSDOS_FILESYSTEM))
    char *dos_newname;
    int   feedback;

    ASSERT (oldname);
    ASSERT (newname);

    dos_newname = mem_strdup (newname);
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (dos_newname, '/', '\\');
    feedback = rename (oldname, dos_newname);
    mem_free (dos_newname);
    return (feedback);

#   else
    ASSERT (oldname);
    ASSERT (newname);

    return (rename (oldname, newname));
#   endif
}
</PRE>
<A NAME="file_delete">&nbsp;</A>
<H3><A NAME="TOC120"><TT>file_delete</TT></A></H3>
<PRE>
#include "sflfile.h"
int
file_delete (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Deletes the specified file. Returns 0 if okay, -1 in case of an
   error.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__VMS__))
    ASSERT (filename);
    return (remove (filename));

#elif (defined (WIN32))
    int
        rc;

    ASSERT (filename);
    rc = !DeleteFile (filename);
    if (rc &amp;&amp; errno == EACCES)
      {
        /*  Under WinNT and Win95, a delete of a freshly-created file can
         *  sometimes fail with a permission error which passes after a
         *  short delay.  Ugly but it seems to work.
         */
        Sleep (200);
        rc = !DeleteFile (filename);
      }
    return (rc);
#else

    ASSERT (filename);
    return (unlink (filename));
#endif
}
</PRE>
<A NAME="file_exists">&nbsp;</A>
<H3><A NAME="TOC121"><TT>file_exists</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_exists (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the file exists, or FALSE if it does not.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);
    return (file_mode (filename) &gt; 0);
}
</PRE>
<A NAME="file_where">&nbsp;</A>
<H3><A NAME="TOC122"><TT>file_where</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_where (
    char mode,
    const char *path,
    const char *name,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Scans a user-specified path symbol for a specific file, and
   returns the fully-specified filename. Also adds an extension if
   this is required. The mode argument can be one of: r, w, a, or
   s for read, write, append, or static. The function tries to
   locate existing files somewhere on the path. New files are
   always created in the current directory. Static files are
   created in the first directory on the path. The path argument
   is only used when more is r, a, or s. If the path is NULL or
   empty, it is ignored. Otherwise, the path is translated as an
   environment variable, and cut into a list of directory names.
   The path is cut up as follows: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>MS-DOS</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>OS/2</B>  <TD ALIGN="LEFT">directory names
   separated by ';'. ;; means current. <TR><TD
   ALIGN="LEFT"><B>Unix</B>  <TD ALIGN="LEFT">directory names
   separated by ':'. :: means current. <TR><TD
   ALIGN="LEFT"><B>VMS</B>  <TD ALIGN="LEFT">directory names
   separated by ','. " ", means current. <TR><TD
   ALIGN="LEFT"><B>Other</B>  <TD ALIGN="LEFT">single directory
   name. </TABLE> When the mode is 'r' or 'a', searches the
   current directory before considering the path value. When the
   path cannot be translated, and is not null or empty, it is used
   as a literal value. The name argument is the filename with or
   without extension. It will be prefixed by the path and suffixed
   by the extension, if required. The ext argument is a default or
   mandatory extension. If ext starts with a dot, it is mandatory
   and always used. Otherwise it is used only if the name does not
   already have an extension. If ext is NULL or empty, it is
   ignored. The total length of a name including path, name,
   extension, and any delimiters is FILE_NAME_MAX. Names are
   truncated if too long. The maximum size of one directory
   component is FILE_DIR_MAX chars. All parameters are case-
   sensitive; the precise effect of this depends on the system. On
   MS-DOS, filenames are always folded to uppercase, but the path
   must be supplied in uppercase correctly. On UNIX, all
   parameters are case sensitive. On VMS, path and filenames are
   folded into uppercase. Returns a pointer to a static character
   array containing the filename; if mode is 'r' and the file does
   not exist, returns NULL. If the mode is 'w', 'a', or 's',
   always returns a valid filename. Under VMS, all filenames are
   handled in POSIX mode, i.e. /disk/path/file instead of
   $disk:[path]file.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    const char
        *pathptr;                       /*  End of directory in path         */
    char
        *curdir;
    Bool
        search_curdir = TRUE;           /*  Look in current directory?       */

    ASSERT (name);
    if (ext != NULL &amp;&amp; *ext)            /*  Append extension if not null     */
      {                                 /*    to get name + ext into         */
        if (ext [0] == '.')             /*    work_name.                     */
            <A HREF="sfldoc.htm#fixed_extension">fixed extension</A> (work_name, name, ext);
        else
            <A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, name, ext);
      }
    else
        strcpy (work_name, name);
#if (NAMEFOLD == TRUE)
    <A HREF="sfldoc.htm#strupc">strupc</A> (work_name);                 /*  Fold to uppercase if needed      */
#endif

    if (path != NULL &amp;&amp; *path)          /*  Get value of path, or NULL       */
      {
        pathptr = getenv (path);        /*  Translate path symbol            */
        if (pathptr == NULL)
          {
            pathptr = path;             /*  If not found, use literally      */
            search_curdir = FALSE;      /*  Path now takes priority          */
          }
#if (PATHFOLD == TRUE)                  /*  Fold to uppercase if necessary   */
        if (pathptr)
          {
            ASSERT (strlen (pathptr) &lt; PATH_MAX);
            strcpy (path_name, pathptr);
            <A HREF="sfldoc.htm#strupc">strupc</A> (path_name);
            pathptr = path_name;        /*  Redirect to uppercase version    */
          }
#endif
      }
    else
        pathptr = NULL;

#if (defined (MSDOS_FILESYSTEM))
    /*  Normalise the path value by changing any slashes to backslashes      */
    if (pathptr)
      {
        if (pathptr != path_name)
          {
            strcpy (path_name, pathptr);
            pathptr = path_name;
          }
        <A HREF="sfldoc.htm#strconvch">strconvch</A> (path_name, '/', '\\');
      }
#endif

    /*  Take care of 'w' and 's' options first                               */
    if (mode == 'w')                    /*  Create output file locally       */
        return (work_name);

    if (mode == 's')                    /*  Get specific directory name      */
      {
        if (pathptr &amp;&amp; <A HREF="sfldoc.htm#file_is_directory">file is directory</A> (pathptr))
            build_next_path (full_name, pathptr, work_name);
        else
            build_next_path (full_name, ".\\", work_name);
        return (full_name);
      }

    /*  If file exists as defined, prefix with current directory if not an   */
    /*  absolute filename, then return the resulting filename                */
    if (search_curdir &amp;&amp; <A HREF="sfldoc.htm#file_exists">file exists</A> (work_name))
      {
#if (defined (MSDOS_FILESYSTEM))
        /*  Under MSDOS we have a full path if we have any of:
         *     /directory/directory/filename
         *     D:/directory/directory/filename
         *     the variations of those with backslashes.
         */
        if (work_name [0] == '\\'   || work_name [0] == '/' ||
           (isalpha (work_name [0]) &amp;&amp; work_name [1] == ':' &amp;&amp;
           (work_name [2] == '\\'   || work_name [2] == '/')))

#else
        /*  Under UNIX, VMS, or OS/2, we have a full path if the path starts
         *  with the directory marker
         */
        if (work_name [0] == PATHEND)
#endif
            strcpy (full_name, work_name);
        else
          {
            curdir = <A HREF="sfldoc.htm#get_curdir">get curdir</A> ();
            sprintf (full_name, "%s%c%s", curdir, PATHEND, work_name);
            mem_free (curdir);
          }
#if (defined (MSDOS_FILESYSTEM))
        <A HREF="sfldoc.htm#strconvch">strconvch</A> (full_name, '/', '\\');
#endif
        return (full_name);             /*  Then return path + name + ext    */
      }
    if (!pathptr)                       /*  Now we need a path               */
        return (NULL);                  /*   - if none defined, give up      */

    for (;;)                            /*  Try each path component          */
      {
        pathptr = build_next_path (full_name, pathptr, work_name);
        if (<A HREF="sfldoc.htm#file_exists">file exists</A> (full_name))
            return (full_name);         /*  Until we find one,               */

        if (*pathptr == '\0')           /*    or we come to the end of       */
          {                             /*    the path                       */
            if (mode == 'r')
                return (NULL);          /*  Input file was not found...      */
            else
                return (full_name);
          }
      }
}
</PRE>
<A NAME="file_cycle">&nbsp;</A>
<H3><A NAME="TOC123"><TT>file_cycle</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_cycle (
    const char *filename,
    int how)
</PRE>
<H4>Synopsis</H4>
<P>Cycles the file: if the file already exists, renames the
   existing file. This function tries to rename the file using the
   date of creation of the file; if this fails because an existing
   file had the same name, generates a guaranteed unique file
   name. Returns TRUE if the cycle operation succeeded, or FALSE
   if it failed (e.g. due to a protection problem). The how
   argument must be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CYCLE ALWAYS</B>  <TD ALIGN="LEFT">Cycle file
   unconditionally <TR><TD ALIGN="LEFT"><B>CYCLE HOURLY</B>  <TD
   ALIGN="LEFT">Cycle file if hour has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE DAILY</B>  <TD ALIGN="LEFT">Cycle file if
   day has changed <TR><TD ALIGN="LEFT"><B>CYCLE WEEKLY</B>  <TD
   ALIGN="LEFT">Cycle file if week has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE MONTHLY</B>  <TD ALIGN="LEFT">Cycle file
   if month has changed <TR><TD ALIGN="LEFT"><B>CYCLE NEVER</B>
   <TD ALIGN="LEFT">Don't cycle the file </TABLE>
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_date;                      /*  Datestamp of file                */
    char
        *point,
        *insert_at;                     /*  Where we start messing name      */
    int
        unique_nbr;                     /*  To generate a unique name        */

    ASSERT (filename);

    /*  If no cycling needed, do nothing                                     */
    if (!<A HREF="sfldoc.htm#file_cycle_needed">file cycle needed</A> (filename, how))
        return (TRUE);                  /*  No errors, nothing in fact       */

    file_date = <A HREF="sfldoc.htm#timer_to_date">timer to date</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename));
    strcpy (full_name, filename);
    point = strrchr (full_name, '.');
    if (point)
      {
        strcpy (work_name, point);      /*  Save extension, if any           */
        *point = '\0';                  /*    and truncate original name     */
      }
    else
        strclr (work_name);

    /*  We leave up to 2 original letters of the filename, then stick-in     */
    /*  the 6-digit timestamp.                                               */
    insert_at = strrchr (full_name, '/');
#if (defined (MSDOS_FILESYSTEM))
    if (!insert_at)
        insert_at = strrchr (full_name, '\\');
#endif
    if (insert_at)
        insert_at++;                    /*  Bump past slash, if found        */
    else
        insert_at = full_name;

    if (*insert_at)                     /*  Bump insert_at twice, to leave   */
        insert_at++;                    /*    up to 2 letters before we      */
    if (*insert_at)                     /*    stick-in the date stamp        */
        insert_at++;

    /*  Format new name for file and make sure it does not already exist     */
    sprintf (insert_at, "%06d", (int) (file_date % 1000000L));
    strcat  (insert_at, work_name);
    if (<A HREF="sfldoc.htm#file_exists">file exists</A> (full_name))
      {
        point = strrchr (full_name, '.') + 1;
        for (unique_nbr = 0; unique_nbr &lt; 1000; unique_nbr++)
          {
            sprintf (point, "%03d", unique_nbr);
            if (!<A HREF="sfldoc.htm#file_exists">file exists</A> (full_name))
                break;
          }
      }
    if (<A HREF="sfldoc.htm#file_exists">file exists</A> (full_name))
        return (FALSE);                 /*  We give up!                      */

    if (<A HREF="sfldoc.htm#file_rename">file rename</A> (filename, full_name))
        return (FALSE);                 /*  No permission                    */
    else
        return (TRUE);                  /*  Okay, it worked                  */
}
</PRE>
<A NAME="file_cycle_needed">&nbsp;</A>
<H3><A NAME="TOC124"><TT>file_cycle_needed</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_cycle_needed (
    const char *filename,
    int how)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether the file should be cycled or not. Returns TRUE
   if the file needs to be cycled, FALSE if not. The how argument
   must be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CYCLE ALWAYS</B>  <TD ALIGN="LEFT">Cycle file
   unconditionally <TR><TD ALIGN="LEFT"><B>CYCLE HOURLY</B>  <TD
   ALIGN="LEFT">Cycle file if hour has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE DAILY</B>  <TD ALIGN="LEFT">Cycle file if
   day has changed <TR><TD ALIGN="LEFT"><B>CYCLE WEEKLY</B>  <TD
   ALIGN="LEFT">Cycle file if week has changed <TR><TD
   ALIGN="LEFT"><B>CYCLE MONTHLY</B>  <TD ALIGN="LEFT">Cycle file
   if month has changed <TR><TD ALIGN="LEFT"><B>CYCLE NEVER</B>
   <TD ALIGN="LEFT">Don't cycle the file </TABLE> If the specified
   file does not exist or is not accessible, returns FALSE.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        curr_time,                      /*  Current time                     */
        curr_date,                      /*  Current date                     */
        file_date,                      /*  Timestamp of file                */
        file_time;                      /*  Datestamp of file                */
    Bool
        cycle;                          /*  Do we want to cycle the file?    */

    ASSERT (filename);
    if (!<A HREF="sfldoc.htm#file_exists">file exists</A> (filename))        /*  Not found - nothing more to do   */
        return (FALSE);

    file_time = <A HREF="sfldoc.htm#timer_to_time">timer to time</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename));
    file_date = <A HREF="sfldoc.htm#timer_to_date">timer to date</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename));
    curr_time = <A HREF="sfldoc.htm#time_now">time now</A> ();
    curr_date = <A HREF="sfldoc.htm#date_now">date now</A> ();

    switch (how)
      {
        case CYCLE_ALWAYS:
            cycle = TRUE;
            break;
        case CYCLE_HOURLY:
            cycle = GET_HOUR (file_time) != GET_HOUR (curr_time);
            break;
        case CYCLE_DAILY:
            cycle = GET_DAY (file_date) != GET_DAY (curr_date);
            break;
        case CYCLE_WEEKLY:
            cycle = <A HREF="sfldoc.htm#week_of_year">week of year</A> (file_date) != <A HREF="sfldoc.htm#week_of_year">week of year</A> (curr_date);
            break;
        case CYCLE_MONTHLY:
            cycle = GET_MONTH (file_date) != GET_MONTH (curr_date);
            break;
        case CYCLE_NEVER:
            cycle = FALSE;
            break;
        default:
            cycle = FALSE;
      }
    return (cycle);
}
</PRE>
<A NAME="file_has_changed">&nbsp;</A>
<H3><A NAME="TOC125"><TT>file_has_changed</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_has_changed (
    const char *filename,
    long old_date,
    long old_time)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the file has changed since it was last read.
   The calling program must supply the date and time of the file
   as it was read. If the file is not present or accessible,
   returns FALSE.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_date,                      /*  Timestamp of file                */
        file_time;                      /*  Datestamp of file                */

    ASSERT (filename);
    if (!<A HREF="sfldoc.htm#file_exists">file exists</A> (filename))        /*  Not found - nothing more to do   */
        return (FALSE);

    file_time = <A HREF="sfldoc.htm#timer_to_time">timer to time</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename));
    file_date = <A HREF="sfldoc.htm#timer_to_date">timer to date</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename));
    if (file_date  &gt; old_date
    || (file_date == old_date &amp;&amp; file_time &gt; old_time))
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="safe_to_extend">&nbsp;</A>
<H3><A NAME="TOC126"><TT>safe_to_extend</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
safe_to_extend (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Handles system-specific case of extending a file that may not
   be in a valid state for such an operation. Returns TRUE if the
   extend can go ahead; returns FALSE if the extend cannot be
   permitted. Under MS-DOS and Windows, if the last byte in the
   file is Ctrl-Z (26) the file is truncated by 1 position to
   remove this character.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (MSDOS_FILESYSTEM))
    int  handle;                        /*  Opened file handle               */
    char endoffile;                     /*  Last character in file           */

    ASSERT (filename);

    handle = open (filename, O_RDWR + O_BINARY, S_IREAD | S_IWRITE);
    if (handle)                         /*  If not found, ignore             */
      {
        lseek (handle, -1, SEEK_END);
        read  (handle, &amp;endoffile, 1);
        if (endoffile == 26)
            chsize (handle, filelength (handle) - 1);

        close (handle);
      }
#endif
    return (TRUE);
}
</PRE>
<A NAME="default_extension">&nbsp;</A>
<H3><A NAME="TOC127"><TT>default_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
default_extension (
    char *dest,
    const char *src,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Copies src to dest and adds ext if necessary. Returns dest.
   Dest must be large enough for a fully-formatted filename;
   define it as char [FILE_NAME_MAX + 1]. The ext argument can
   start with or without If ext is null or empty, does nothing.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    int len, i;
    char *ptr;

    ASSERT (dest);
    ASSERT (src);

    if (dest != src)                    /*  Copy src to dest if not same     */
        strcpy (dest, src);

    if (ext != NULL &amp;&amp; *ext != 0)
      {
        len = strlen (dest);
        for (i = len - 1, ptr = dest + i; i &gt;= 0; i--, ptr--)
            if (*ptr == '\\' || *ptr == '/' || *ptr == '.')
                break;

        if (i &lt; 0 || *ptr != '.')
          {
            if (*ext != '.')
              {
                dest [len++] = '.';
                dest [len] = '\0';
              }
            strcat (dest + len, ext);
          }
      }
    return (dest);
}
</PRE>
<A NAME="fixed_extension">&nbsp;</A>
<H3><A NAME="TOC128"><TT>fixed_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
fixed_extension (
    char *dest,
    const char *src,
    const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Copies src to dest and enforces ext extension. Returns dest.
   Dest must be large enough for a fully-formatted filename;
   define it as char [FILE_NAME_MAX + 1]. The ext argument can
   start with or without If ext is null or empty, does nothing.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (dest);
    ASSERT (src);

    if (dest != src)                    /*  Copy src to dest if not same     */
        strcpy (dest, src);

    <A HREF="sfldoc.htm#strip_extension">strip extension</A> (dest);
    return (<A HREF="sfldoc.htm#default_extension">default extension</A> (dest, dest, ext));
}
</PRE>
<A NAME="strip_extension">&nbsp;</A>
<H3><A NAME="TOC129"><TT>strip_extension</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
strip_extension (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Removes dot and extension from the name, if any was present. If
   the name contained multiple extensions, removes the last one
   only. Returns name.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *dot, *slash;

    ASSERT (name);

    dot   = strrchr (name, '.');        /*  Find dot in name, if any         */
    slash = strrchr (name, '\\');       /*  Find last slash (DOS or Unix)    */
    if (slash == NULL)
        slash = strrchr (name, '/');
    if (dot &gt; slash)
        *dot = 0;                       /*  If we had a dot, truncate name   */

    return (name);
}
</PRE>
<A NAME="strip_file_path">&nbsp;</A>
<H3><A NAME="TOC130"><TT>strip_file_path</TT></A></H3>
<PRE>
#include "sflfile.h"
char
*strip_file_path (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Removes the leading path from the filename, if any path was
   present. Returns name. The path can be specified using the
   local operating system syntax; under MS-DOS, / and \ are
   interchangeable.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *path_end;

    ASSERT (name);

    path_end = strrchr (name, PATHEND); /*  Find end of path, if any         */
#if (defined (MSDOS_FILESYSTEM))
    if (path_end == NULL)
        path_end = strrchr (name, '/');
#endif
    if (path_end != NULL)
        memmove (name, path_end + 1, strlen (path_end));
    return (name);
}
</PRE>
<A NAME="strip_file_name">&nbsp;</A>
<H3><A NAME="TOC131"><TT>strip_file_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char
*strip_file_name (
    char *name)
</PRE>
<H4>Synopsis</H4>
<P>Returns the path for a fully-qualified filename. The path is
   cleaned-up and resolved. The returned string is held in a
   static area that should be copied directly after calling this
   function. The returned path does not end in '/' unless that is
   the entire path. If the supplied name contains no path, the
   returned path is ".".
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char *path_end;

    ASSERT (name);
    ASSERT (strlen (name) &lt;= LINE_MAX);

    strcpy (work_name, name);
    path_end = strrchr (work_name, PATHEND);
#if (defined (MSDOS_FILESYSTEM))
    if (path_end == NULL)
        path_end = strrchr (work_name, '/');
#endif
    if (path_end == NULL)
        return (".");
    else
      {
        path_end [1] = '\0';
        return (<A HREF="sfldoc.htm#clean_path">clean path</A> (work_name));
      }
}
</PRE>
<A NAME="file_is_readable">&nbsp;</A>
<H3><A NAME="TOC132"><TT>file_is_readable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_readable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can read the specified file
   or directory. The filename may end in a slash (/ or \).
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);
    return ((file_mode (<A HREF="sfldoc.htm#clean_path">clean path</A> (filename)) &amp; S_IREAD) != 0);
}
</PRE>
<A NAME="file_is_writeable">&nbsp;</A>
<H3><A NAME="TOC133"><TT>file_is_writeable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_writeable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can write the specified
   file or directory. The filename may end in a slash (/ or \).
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    ASSERT (filename);

    return ((file_mode (<A HREF="sfldoc.htm#clean_path">clean path</A> (filename)) &amp; S_IWRITE) != 0);
}
</PRE>
<A NAME="file_is_executable">&nbsp;</A>
<H3><A NAME="TOC134"><TT>file_is_executable</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_executable (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the current process can execute the specified
   file. Directories are _not_ considered to be executable. Under
   DOS, Windows, appends ".com", ".exe", and ".bat" to the
   filename, in that order, to build a possible executable
   filename. If this fails, opens the file (if it exists) and
   examines the first few bytes of the file: if these are "#!", or
   '/'*! or "MZ" then the file is assumed to be executable. #! is
   a standard mechanism under Unix for indicating executable
   files. Note that <A HREF="sfldoc.htm#process_create">process create</A>() uses a compatible
   mechanism to launch the correct interpreter for such
   'executable' scripts. NOTE: '/'*! is provided for REXX. [XXX]
   Under OS/2 appends ".exe" and ".cmd" to the filename, in that
   order, to be a possible executable filename. If this fails, it
   opens the file (if it exists) and examines the first few bytes
   of the file: if these are "#!" then the file is assumed to be
   executable. NOTE: REXX scripts MUST be in files named
   script.cmd in order to be found. BAT files are not considered,
   nor are COM files, since at present process_create does not
   support launching DOS processes. Under VMS, appends .exe and
   .com, in that order to build a possible executable filename.
   Does not search the PATH symbol; the filename must be specified
   with a path if necessary.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__UNIX__))
    ASSERT (filename);

    return ((file_mode (filename) &amp; S_IEXEC) != 0
         &amp;&amp; (file_mode (filename) &amp; S_IFDIR) == 0);

#elif (defined (MSDOS_FILESYSTEM))
    Bool
        executable;                     /*  Return code                      */
    FILE
        *stream;                        /*  Opened file stream               */
    char
        input_char = 0,                 /*  First and second bytes of file   */
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension; if not found, set extension to empty string     */
    extension = strrchr (filename, '.');
    if (extension == NULL
    ||  strchr (extension, '/')         /*  If last '.' is part of the path  */
    ||  strchr (extension, '\\'))       /*  then the filename has no ext.    */
        extension = "";

    /*  Windows: If extension is .exe/.com/.bat, the file is an executable   */
    /*  OS/2:    If the extension is .exe/.cmd, the file is an executable    */
#if (defined ( __OS2__))
    if (<A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".cmd") == 0)
#else /* DOS, WINDOWS */
    if (<A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".com") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".bat") == 0)
#endif
        executable = <A HREF="sfldoc.htm#file_exists">file exists</A> (filename);
    else
    /*  Windows: If the extension is empty, try .com, .exe, .bat             */
    /*  OS/2:    If the extension is empty, try .exe, .cmd                   */
    if (strnull (extension)
#if (defined( __OS2__))
    &amp;&amp; (<A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "cmd"))))
#else /* DOS, WINDOWS */
    &amp;&amp; (<A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "com"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "bat"))))
#endif
        executable = TRUE;              /*  Executable file found            */
    else
      {
        /*  Look for magic header at start of file                           */
        stream = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r');
        if (stream)
          {
            input_char = fgetc (stream);
            executable = ((input_char == '#' &amp;&amp; fgetc (stream) == '!')
#   if (defined (__WINDOWS__))
                       || (input_char == '/' &amp;&amp; fgetc (stream) == '*'
                                             &amp;&amp; fgetc (stream) == '!')
                       || (input_char == 'M' &amp;&amp; fgetc (stream) == 'Z')
#   endif
            );
            <A HREF="sfldoc.htm#file_close">file close</A> (stream);
          }
        else
            executable = FALSE;
      }
    return (executable);

#elif (defined (__VMS__))
    Bool
        executable;                     /*  Return code                      */
    char
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension, if any                                          */
    extension = strrchr (filename, '.');
    if ((file_mode (filename) &amp; S_IEXEC) != 0)
        executable = TRUE;
    else
    /*  If the extension is empty, try .exe and .com                         */
    if (!extension)
      {
        <A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "exe");
        if ((file_mode (work_name) &amp; S_IEXEC) != 0)
            executable = TRUE;
        else
          {
            <A HREF="sfldoc.htm#default_extension">default extension</A> (work_name, filename, "com");
            if ((file_mode (work_name) &amp; S_IEXEC) != 0)
                executable = TRUE;
            else
                executable = FALSE;
          }
      }
    else
        executable = FALSE;

    return (executable);

#else
    return (FALSE);                     /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="file_is_program">&nbsp;</A>
<H3><A NAME="TOC135"><TT>file_is_program</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_program (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified filename is an executable program
   on the PATH. Under DOS, and Windows, appends ".com", ".exe",
   and ".bat" to the file, in that order, to build an executable
   filename, then searches the PATH definition for the executable
   filename. Under OS/2, appends ".exe", and ".cmd" to the file,
   in that order, to build an executable filename, then searches
   the PATH definition for the executable filename. If the
   filename already has a path specifier, will not use the PATH
   definition. Under VMS, appends "exe" and "com" to the file, in
   that order, to build an executable filename. Searches the PATH
   if necessary.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    Bool
        executable = FALSE;             /*  Return code                      */

#if (defined (__UNIX__))
    char
        *found_file;

    ASSERT (filename);

    found_file = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, "");
    if (found_file &amp;&amp; (file_mode (found_file) &amp; S_IEXEC))
        executable = TRUE;              /*  Executable file found            */

#elif (defined (__VMS__))
    char
        *found_file;

    ASSERT (filename);

    found_file = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, "");
    if (!found_file)
        found_file = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, ".exe");
    if (!found_file)
        found_file = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", filename, ".com");

    if (found_file &amp;&amp; (file_mode (found_file) &amp; S_IEXEC))
        executable = TRUE;              /*  Executable file found            */

#elif (defined (MSDOS_FILESYSTEM))
    char
        *path;                          /*  What path do we search?          */

    ASSERT (filename);
    /*  If the filename already contains a path, don't look at PATH          */
    if (strchr (filename, '/') || strchr (filename, '\\'))
        path = NULL;
    else
        path = "PATH";

#   if (defined (__WINDOWS__))
    if (<A HREF="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".com")
    ||  <A HREF="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".exe")
    ||  <A HREF="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".bat"))
        executable = TRUE;              /*  Executable file found            */
#   else /* OS/2 */
    if (<A HREF="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".exe")
    ||  <A HREF="sfldoc.htm#file_where">file where</A> ('r', path, filename, ".cmd"))
        executable = TRUE;
#   endif
#endif

    return (executable);
}
</PRE>
<A NAME="file_is_directory">&nbsp;</A>
<H3><A NAME="TOC136"><TT>file_is_directory</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_directory (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified file is a directory. The filename
   may end in a slash (/ or \). Under MS-DOS/OS2/Windows, a
   directory name may consist solely of a disk-drive specifier.
   Under VMS the directory may optionally take the extension
   '.dir'.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    static char
        dir_name [LINE_MAX + 1];

    ASSERT (filename);

    strcpy (dir_name, <A HREF="sfldoc.htm#clean_path">clean path</A> (filename));
#if (defined (__VMS__))
    if (!<A HREF="sfldoc.htm#file_exists">file exists</A> (dir_name))
        <A HREF="sfldoc.htm#default_extension">default extension</A> (dir_name, dir_name, "dir");
#endif
    return ((file_mode (dir_name) &amp; S_IFDIR) != 0);
}
</PRE>
<A NAME="file_is_legal">&nbsp;</A>
<H3><A NAME="TOC137"><TT>file_is_legal</TT></A></H3>
<PRE>
#include "sflfile.h"
Bool
file_is_legal (
    const char *arg_filename)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether the specified file is 'legal', which is a
   system-dependent definition. Under 32-bit Windows, a legal file
   is one who's name is not a shortened 8.3 version of a long
   name. This can be used to bypass filename-based security
   schemes. On other systems, the notion of 'illegal' is not
   defined. Returns TRUE if the file exists and is legal. Returns
   FALSE otherwise.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (WIN32))
    static WIN32_FIND_DATA
        found;
    HANDLE
        handle;
    char
        *filename,                      /*  Our copy of arg_filename         */
        *slash,                         /*  Position of '\' in filename      */
        *component;                     /*  Component to compare             */
    Bool
        feedback;                       /*  Function feedback                */

    /*  For each path component of the filename, check that the long form
     *  of the name is the same as the short form.  We scan backwards
     *  from the end of the filename, get the full pathname, and compare
     *  the last component each time:
     *
     *      aaa\bbb\ccc\name.ext    name.ext
     *      aaa\bbb\ccc             ccc
     *      aaa\bbb                 bbb
     *      aaa                     aaa
     */

    filename = mem_strdup (arg_filename);
    feedback = TRUE;                    /*  Assume we match everything       */
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (filename, '/', '\\');
    if (strlast (filename) == '\\')
        strlast (filename) = '\0';      /*  Drop any trailing slash          */

    do
      {
        slash     = strrchr (filename, '\\');
        component = slash? slash + 1: filename;
        handle    = FindFirstFile (filename, &amp;found);

        if (handle == INVALID_HANDLE_VALUE
        ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (component, found.cFileName))
          {
            feedback = FALSE;
            break;
          }
        FindClose (handle);
        if (slash)
          {
            *slash = '\0';              /*  Cut filename at slash            */
            if (filename [1] == ':'
            &amp;&amp;  filename [2] == '\0')   /*  We're at a disk specifier        */
                break;                  /*    which is okay by now           */
          }
      }
    while (slash &amp;&amp; *filename);
    mem_free (filename);
    return (feedback);

#else
    return (<A HREF="sfldoc.htm#file_exists">file exists</A> (arg_filename));
#endif
}
</PRE>
<A NAME="file_exec_name">&nbsp;</A>
<H3><A NAME="TOC138"><TT>file_exec_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
file_exec_name (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>If the specified filename is an executable program, formats a
   filename including any required extension and returns a static
   string with that value. If the specified filename is not an
   executable program, returns NULL. Under DOS, and Windows,
   appends ".com", ".exe", and ".bat" to the filename, in that
   order, to build a possible executable filename. Under OS/2,
   appends ".exe", and ".cmd" to the filename, in that order, to
   build a possible executable filename. If this fails, returns
   NULL. Does not search the PATH symbol; the filename must be
   specified with a path if necessary. The returned filename (if
   not NULL) points to a static string.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__VMS__))
    ASSERT (filename);

    strcpy (exec_name, filename);

    if (file_mode (exec_name) &amp; S_IEXEC)
        return (exec_name);
    else
        return (NULL);

#elif (defined (MSDOS_FILESYSTEM))
    char
        *extension;                     /*  File extension, if any           */

    ASSERT (filename);

    /*  Find file extension; if not found, set extension to empty string     */
    extension = strrchr (filename, '.');
    if (extension == NULL
    ||  strchr (extension, '/')         /*  If last '.' is part of the path  */
    ||  strchr (extension, '\\'))       /*  then the filename has no ext.    */
        extension = "";

    /*  Windows: If extension is .exe/.com/.bat, the file is an executable   */
    /*  OS/2:    If extension is .exe/.cmd, the file is executable           */
#   if (defined (__OS2__))
    if (<A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".cmd") == 0
#   else /* DOS, WINDOWS */
    if (<A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".com") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".exe") == 0
    ||  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (extension, ".bat") == 0
#     if (defined (__WINDOWS__))
    ||  is_exe_file (filename)
#     endif
#   endif
    )
      {
        strcpy (exec_name, filename);
        return (exec_name);
      }
    else
    /*  Windows: If the extension is empty, try .com, .exe, .bat             */
    /*  OS/2:    If the extension is empty, try .exe, .cmd                   */
    if (strnull (extension)
#   if (defined (__OS2__))
    &amp;&amp; (<A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "exe"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "cmd"))))
#   else /* DOS, WINDOWS */
    &amp;&amp; (<A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "com"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "exe"))
    ||  <A HREF="sfldoc.htm#file_exists">file exists</A> (<A HREF="sfldoc.htm#default_extension">default extension</A> (exec_name, filename, "bat"))))
#   endif
        return (exec_name);             /*  Executable file found            */
    else
        return (NULL);
#else
    return (NULL);                      /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="get_file_size">&nbsp;</A>
<H3><A NAME="TOC139"><TT>get_file_size</TT></A></H3>
<PRE>
#include "sflfile.h"
long
get_file_size (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns the size, in bytes, of the specified file or directory.
   The size of a directory is not a portable concept. If there is
   an error, returns -1.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (WIN32_NOT_IMPLEMENTED))
    /*  This code has been disactivated because it cannot work with a file
        that is opened by another function.
     */
    HANDLE
        handle;                         /*  We open file to get its size     */
    long
        size;

    ASSERT (filename);
    handle = CreateFile (filename, 0, FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, 0, 0);
    if (handle == INVALID_HANDLE_VALUE)
        return (-1);

    size = GetFileSize (handle, NULL);
    CloseHandle (handle);
    return (size);

#else
    struct stat
        stat_buf;

    ASSERT (filename);

    if (stat ((char *) filename, &amp;stat_buf) == 0)
        return ((long) stat_buf.st_size);
    else
        return (-1);
#endif
}
</PRE>
<A NAME="get_file_time">&nbsp;</A>
<H3><A NAME="TOC140"><TT>get_file_time</TT></A></H3>
<PRE>
#include "sflfile.h"
time_t
get_file_time (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Returns the modification time of the specified file or
   directory. The returned time is suitable for feeding to
   localtime().
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
#if (defined (WIN32_NOT_IMPLEMENTED))
    /*  This code has been disactivated because it returns incorrect
        values depending on the seasonal clock change.
     */
    unsigned long thi,tlo;
    double  dthi,dtlo;
    double  secs_since_1601, secs_time_t;
    double  delta = 11644473600.;
    double  two_to_32 = 4294967296.;
    HANDLE  handle;
    FILETIME creation, last_access, last_write;

    handle = CreateFile (filename, GENERIC_READ, FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, 0, 0);
    if (handle == INVALID_HANDLE_VALUE)
        return (0);
    GetFileTime (handle, &amp;creation, &amp;last_access, &amp;last_write);
    CloseHandle (handle);
    thi = last_write.dwHighDateTime;
    tlo = last_write.dwLowDateTime;
    dthi = (double) thi;
    dtlo = (double) tlo;
    secs_since_1601 = (dthi * two_to_32 + dtlo) / 1.0e7;
    secs_time_t     = secs_since_1601 - delta;
    return ((time_t) secs_time_t);

#else
    struct stat
        stat_buf;

    ASSERT (filename);

    if (stat ((char *) filename, &amp;stat_buf) == 0)
        return (stat_buf.st_mtime &gt; 0? stat_buf.st_mtime: 0);
    else
        return (0);
#endif
}
</PRE>
<A NAME="get_file_lines">&nbsp;</A>
<H3><A NAME="TOC141"><TT>get_file_lines</TT></A></H3>
<PRE>
#include "sflfile.h"
long
get_file_lines (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns the number of lines in the
   file. The file should be normal text. Returns 0 if the file
   cannot be opened for reading. May be a bit slow on large files.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    long
        file_size;
    FILE
        *file_stream;
    int
        ch;

    ASSERT (filename);

    file_stream = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r');
    if (file_stream == NULL)
        return (0);

    file_size = 0;
    while ((ch = fgetc (file_stream)) != EOF)
        if (ch == '\n')
            file_size++;

    fclose (file_stream);
    return (file_size);
}
</PRE>
<A NAME="file_slurp">&nbsp;</A>
<H3><A NAME="TOC142"><TT>file_slurp</TT></A></H3>
<PRE>
#include "sflfile.h"
DESCR *
file_slurp (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns a DESCR containing the file
   data. The file is read as binary data. The returned DESCR
   should be freed using the mem_free() call. if the file is &gt;
   64K long, only the first 64K bytes are read into memory. This
   is to stop really silly things from happening. Returns NULL if
   the file cannot be found. Appends a null byte to the data in
   any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    return (file_load_data (filename, 65535UL));
}
</PRE>
<A NAME="file_slurpl">&nbsp;</A>
<H3><A NAME="TOC143"><TT>file_slurpl</TT></A></H3>
<PRE>
#include "sflfile.h"
DESCR *
file_slurpl (
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Reads an entire file, and returns a DESCR containing the file
   data. The file is read as binary data. The returned DESCR
   should be freed using the mem_free() call. Does not impose any
   limit on the size of the file (unlike <A HREF="sfldoc.htm#file_slurp">file slurp</A>() which
   stops at 64K bytes). Returns NULL if the file cannot be found.
   Appends a null byte to the data in any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    return (file_load_data (filename, 0));
}
</PRE>
<A NAME="file_set_eoln">&nbsp;</A>
<H3><A NAME="TOC144"><TT>file_set_eoln</TT></A></H3>
<PRE>
#include "sflfile.h"
dbyte
file_set_eoln (char *dst, const char *src, dbyte src_size, Bool add_cr)
</PRE>
<H4>Synopsis</H4>
<P>Formats any end-of-line sequences in the buffer according to
   the value of the add_cr argument. If this is TRUE, all end-of-
   lines (LF or CRLF or LFCR) are represented by a CRLF sequence.
   If FALSE, all end-of-lines are represented by LF by itself. The
   target buffer must be large enough to accomodate the resulting
   line (twice the size of the source data). Returns the size of
   the resulting data in the target buffer not counting the final
   trailing null byte. The input data does not need to be null-
   terminated, but the output data is terminated with an extra
   null in any case.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    char
        *srcptr,                        /*  Current character in src         */
        *dstptr,                        /*  Current character in dst         */
        *last;                          /*  Last character in src            */

    ASSERT (src);
    ASSERT (dst);

    srcptr = (char *) src;
    dstptr = dst;
    last   = (char *) src + src_size;

    while (*srcptr &amp;&amp; srcptr &lt; last)
      {
        if (*srcptr == '\n'
        ||  *srcptr == EOF)
          {
            if (add_cr)
                *dstptr++ = '\r';
            *dstptr++ = '\n';
          }
        else
        if (*srcptr != '\r' &amp;&amp; *srcptr != 26)
            *dstptr++ = *srcptr;
        srcptr++;
      }
    *dstptr = '\0';
    return ((dbyte) (dstptr - dst));
}
</PRE>
<A NAME="get_tmp_file_name">&nbsp;</A>
<H3><A NAME="TOC145"><TT>get_tmp_file_name</TT></A></H3>
<PRE>
#include "sflfile.h"
char *
get_tmp_file_name (const char *path, qbyte *index, const char *ext)
</PRE>
<H4>Synopsis</H4>
<P>Get a temporary file name.
<H4>Source Code - (sflfile.c)</H4>
<PRE>
{
    static char
        file_name [LINE_MAX + 1];

    do
      {
        if (path)
            sprintf (file_name, "%s%c%08lX.%s", path, PATHEND, *index, ext);
        else
            sprintf (file_name, "%08lX.%s", *index++, ext);
        (*index)++;
      } while (<A HREF="sfldoc.htm#file_exists">file exists</A> (file_name));
    return (file_name);
}
</PRE>
<H2><A NAME="TOC146">Initialisation file access functions</A></H2>
<P>Filename: sflini.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 94/01/08 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read an initialisation file that follows
   the MS-Windows style, i.e. consists of [Sections] followed by
   keyword = value lines.
<H4>List of Functions</H4>
<UL>
<LI>Bool <A HREF="sfldoc.htm#ini_find_section">ini find section</A><BR>
   (FILE *inifile, char *section, Bool top);
</LI>
<LI>Bool <A HREF="sfldoc.htm#ini_scan_section">ini scan section</A><BR>
   (FILE *inifile, char **keyword, char **value);
</LI>
<LI>SYMTAB * <A HREF="sfldoc.htm#ini_dyn_load">ini dyn load</A><BR>
   (SYMTAB *symtab, const char *filename);
</LI>
<LI>int <A HREF="sfldoc.htm#ini_dyn_save">ini dyn save</A><BR>
   (SYMTAB *symtab, const char *filename);
</LI>
<LI>Bool <A HREF="sfldoc.htm#ini_dyn_changed">ini dyn changed</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>Bool <A HREF="sfldoc.htm#ini_dyn_refresh">ini dyn refresh</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>char * <A HREF="sfldoc.htm#ini_dyn_value">ini dyn value</A><BR>
   (SYMTAB *symtab, const char *section, const char *keyword,
   const char *default_value);
</LI>
<LI>char * <A HREF="sfldoc.htm#ini_dyn_values">ini dyn values</A><BR>
   (SYMTAB *symtab, const char *section, const char *keyword,
   const char *default_value);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflini.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SLFINI_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="ini_find_section">&nbsp;</A>
<H3><A NAME="TOC147"><TT>ini_find_section</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_find_section (
    FILE *inifile,
    char *section,
    Bool top)
</PRE>
<H4>Synopsis</H4>
<P> Finds a specific section in the ini file. An ini file contains
   lines as shown below. The section name can be any mix of upper
   or lowercase. You should open the ini file using file_open
   before you call this function. If the 'top' argument is TRUE,
   repositions to the start of the file before reading, else reads
   from the current file offset. Returns TRUE if the section was
   found, and positions on the line that follows the section.
   Returns FALSE if the section was not found, and positions at
   the end of the file.
<H4>Examples</H4>
<PRE>
    ;   comments like this, or
    #   comments like this if you prefer
    !   Text is echoed to console using trace()
    [Section]
        keyword = key_value; comments
        keyword = "key_value"; comments
        keyword = 'key_value'; comments
        ...
    [Section]
        keyword = key_value; comments
        ...
</PRE>
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *first;

    ASSERT (inifile != NULL);
    ASSERT (section != NULL);

    if (top)                            /*  Reposition at top if wanted      */
        fseek (inifile, 0, SEEK_SET);

    /*  Read through file until we find what we are looking for              */
    while (<A HREF="sfldoc.htm#file_read">file read</A> (inifile, iniline))
      {
        first = <A HREF="sfldoc.htm#strskp">strskp</A> (iniline);       /*  Skip leading spaces              */
        if (*first == ';' || *first == '#' || *first == 0)
            continue;                   /*  Comment line                     */
        else
        if (*first == '!')
          {
            first = <A HREF="sfldoc.htm#strskp">strskp</A> (first + 1);
            <A HREF="sfldoc.htm#trace">trace</A> (first);
          }
        else
        if (sscanf (first, "[%[^]]", ini_section) == 1
        &amp;&amp;  <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (ini_section, section) == 0)
            return (TRUE);
      }
    return (FALSE);
}
</PRE>
<A NAME="ini_scan_section">&nbsp;</A>
<H3><A NAME="TOC148"><TT>ini_scan_section</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_scan_section (
    FILE *inifile,
    char **keyword,
    char **value)
</PRE>
<H4>Synopsis</H4>
<P> Scans the current section of the ini file, and returns a
   keyword and value if such was found. Returns the address of
   these values in the supplied arguments. The addresses point to
   static values that are overwritten with each call. Returns TRUE
   when a keyword/value pair is found. Returns FALSE if a new
   section name or end of file is found. In the first case, sets
   the keyword to the section name; in the second case sets the
   keyword to NULL. Ignores blank and comment lines, and lines
   that look like junk. Keyword and section names are returned as
   lower-case; values are returned exactly as specified in the ini
   file.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *first;

    /*  Read through file until we find what we are looking for              */
    while (<A HREF="sfldoc.htm#file_read">file read</A> (inifile, iniline))
      {
        first = <A HREF="sfldoc.htm#strskp">strskp</A> (iniline);       /*  Skip leading spaces              */
        if (*first == ';' || *first == '#' || *first == 0)
            continue;                   /*  Comment line                     */
        else
        if (*first == '!')
          {
            first = <A HREF="sfldoc.htm#strskp">strskp</A> (first + 1);
            <A HREF="sfldoc.htm#trace">trace</A> (first);
          }
        else
        if (sscanf (first, "[%[^]]", ini_section) == 1)
          {
            *keyword = <A HREF="sfldoc.htm#strlwc">strlwc</A> (ini_section);
            *value   = NULL;
            return (FALSE);             /*  New section name                 */
          }
        else
        if (streq (first, "[]"))        /*  Allow empty section names        */
          {
            strcpy (ini_section, "");
            *keyword = ini_section;
            *value   = NULL;
            return (FALSE);             /*  New section name                 */
          }
        else
        if (sscanf (first, "%[^=] = \"%[^\"]\"", ini_keyword, ini_value) == 2
        ||  sscanf (first, "%[^=] = '%[^\']'",   ini_keyword, ini_value) == 2
        ||  sscanf (first, "%[^=] = %[^;#]",     ini_keyword, ini_value) == 2)
          {
            <A HREF="sfldoc.htm#strcrop">strcrop</A> (<A HREF="sfldoc.htm#strlwc">strlwc</A> (ini_keyword));
            <A HREF="sfldoc.htm#strcrop">strcrop</A> (ini_value);
            /*  sscanf can't handle "" or '' as an empty value, so we do this
             *  ourselves.  Note that this breaks '""' and "''".  :-(
             */
            if (streq (ini_value, "\"\"")
            ||  streq (ini_value, "''"))
                strclr (ini_value);

            *keyword = ini_keyword;
            *value   = ini_value;
            return (TRUE);              /*  Found keyword = value            */
          }
      }
    *keyword = NULL;
    return (FALSE);                     /*  End of file                      */
}
</PRE>
<A NAME="ini_dyn_load">&nbsp;</A>
<H3><A NAME="TOC149"><TT>ini_dyn_load</TT></A></H3>
<PRE>
#include "sflini.h"
SYMTAB *
ini_dyn_load (
    SYMTAB *load_symtab,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Loads the contents of an .ini file into a symbol table. If no
   symbol table is specified, creates a new symbol table. The ini
   file data is loaded as a set of symbols and values, where the
   symbol name is built from the section name and keyword like
   this: "section:keyword". The symbol name is always stored in
   lowercase, with no trailing spaces. If the same keyword occurs
   several times in a section, earlier symbols are overwritten.
   Ignores all comments and blank lines. Returns NULL if there is
   not enough memory. Stores these control variables in the symbol
   table if the table was freshly created or the file was loaded:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>filename</B>  <TD
   ALIGN="LEFT">Name of input file <TR><TD
   ALIGN="LEFT"><B>filetime</B>  <TD ALIGN="LEFT">Time of input
   file, as 8-digit string "HHMMSSCC" <TR><TD
   ALIGN="LEFT"><B>filedate</B>  <TD ALIGN="LEFT">Date of input
   file, as 8-digit string "YYYYMMDD" </TABLE> Also creates a
   symbol for each section, with name equal to the section name,
   and value equal to a null string. Looks for the .ini file on
   the current PATH. The table is sorted after loading.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    FILE
        *inifile;
    SYMTAB
        *symtab,                        /*  Symbol table to populate         */
        *envtab;                        /*  Environment, as symbol table     */
    char
        *section = NULL,                /*  Filled as we scan through        */
        *keyword = NULL,                /*    the ini file                   */
        *value   = NULL,
        *section_end;                   /*  Null byte at end of section      */

    ASSERT (filename);
    inifile = <A HREF="sfldoc.htm#file_locate">file locate</A> ("PATH", filename, NULL);

    if (load_symtab)                    /*  Use specified symbol table       */
        symtab = load_symtab;           /*    or create a new one            */
    else
      {
        symtab = <A HREF="sfldoc.htm#sym_create_table">sym create table</A> ();
        if (symtab == NULL)
            return (NULL);              /*  Quit if insufficient memory      */
      }
    /*  Store control variables in symbol table                              */
    if (inifile || load_symtab == NULL)
      {
        <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filename", filename);
        sprintf (iniline, "%ld", <A HREF="sfldoc.htm#timer_to_date">timer to date</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename)));
        <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filedate", iniline);
        sprintf (iniline, "%ld", <A HREF="sfldoc.htm#timer_to_time">timer to time</A> (<A HREF="sfldoc.htm#get_file_time">get file time</A> (filename)));
        <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, "filetime", iniline);
      }
    if (!inifile)
        return (symtab);                /*  File not found; empty table      */

    /*  Now load the ini file, starting from the beginning                   */
    envtab = <A HREF="sfldoc.htm#env2symb">env2symb</A> ();
    fseek (inifile, 0, SEEK_SET);
    FOREVER
      {
        if (<A HREF="sfldoc.htm#ini_scan_section">ini scan section</A> (inifile, &amp;keyword, &amp;value))
          {
            if (section)
              {
                section_end = strchr (section, '\0');
                ASSERT (section_end);
                <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (section, ":", keyword, NULL);
                value = <A HREF="sfldoc.htm#tok_subst">tok subst</A> (value, envtab);
                <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, section, value);
                mem_strfree (&amp;value);
                *section_end = '\0';
              }
          }
        else
        if (keyword)                    /*  Found new section                */
          {
            section = keyword;
            <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, section, "");
          }
        else
            break;
      }
    <A HREF="sfldoc.htm#file_close">file close</A> (inifile);
    <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (envtab);
    <A HREF="sfldoc.htm#sym_sort_table">sym sort table</A> (symtab, NULL);      /*  Sort table by symbol name        */
    return (symtab);
}
</PRE>
<A NAME="ini_dyn_save">&nbsp;</A>
<H3><A NAME="TOC150"><TT>ini_dyn_save</TT></A></H3>
<PRE>
#include "sflini.h"
int
ini_dyn_save (
    SYMTAB *symtab,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Saves a symbol table to the specified file. The symbol table
   entries must be formatted as "section:name=value" - see
   <A HREF="sfldoc.htm#ini_dyn_load">ini dyn load</A>(). Scans the ini file for a line containing
   only "#*END", then writes the symbol data to the file from that
   point. Returns the number of symbols saved, or -1 if there was
   an error. As a side-effect, sorts the table on the symbol name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    FILE
        *inifile,
        *wrkfile;
    SYMBOL
        *symbol;                        /*  Next symbol in table             */
    Bool
        header_found;                   /*  Did we find a file header?       */
    int
        count;                          /*  How many symbols did we save?    */
    char
        *colon;                         /*  Points to ':' in symbol name     */

    ASSERT (filename);
    ASSERT (symtab);

    /*  Copy ini file header to temporary file                               */
    wrkfile = tmpfile ();
    header_found = FALSE;
    if ((inifile = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r')) != NULL)
      {
        while (<A HREF="sfldoc.htm#file_read">file read</A> (inifile, iniline))
          {
            if (streq (iniline, "#*END"))
              {
                header_found = TRUE;
                break;
              }
            <A HREF="sfldoc.htm#file_write">file write</A> (wrkfile, iniline);
          }
        <A HREF="sfldoc.htm#file_close">file close</A> (inifile);
      }
    /*  Now rewrite ini file                                                 */
    if ((inifile = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'w')) == NULL)
      {
        fclose (wrkfile);
        return (-1);                    /*  No permission to write file      */
      }
    if (header_found)
      {
        fseek (wrkfile, 0, SEEK_SET);
        while (<A HREF="sfldoc.htm#file_read">file read</A> (wrkfile, iniline))
            <A HREF="sfldoc.htm#file_write">file write</A> (inifile, iniline);
      }
    <A HREF="sfldoc.htm#file_close">file close</A> (wrkfile);               /*  Finished with temporary file     */

    /*  Output ini file values                                               */
    <A HREF="sfldoc.htm#file_write">file write</A> (inifile, "#*END");
    strclr (ini_section);               /*  Current section                  */
    count = 0;

    <A HREF="sfldoc.htm#sym_sort_table">sym sort table</A> (symtab, NULL);      /*  Sort table by symbol name        */
    for (symbol = symtab-&gt; symbols; symbol; symbol = symbol-&gt; next)
      {
        /*  Output symbols formatted as key:name                             */
        colon = strrchr (symbol-&gt; name, ':');
        if (colon)
          {
            memcpy (ini_value, symbol-&gt; name, colon - symbol-&gt; name);
            ini_value [colon - symbol-&gt; name] = '\0';
            strcpy (ini_keyword, colon + 1);

            /*  If we start a new section, output the section header         */
            *ini_value   = toupper (*ini_value);
            *ini_keyword = toupper (*ini_keyword);
            if (strneq (ini_section, ini_value))
              {
                strcpy (ini_section, ini_value);
                sprintf (iniline, "[%s]", ini_section);
                <A HREF="sfldoc.htm#file_write">file write</A> (inifile, "");
                <A HREF="sfldoc.htm#file_write">file write</A> (inifile, iniline);
              }
            if (strnull (symbol-&gt; value))
                sprintf (iniline, "    %s=\"\"", ini_keyword);
            else
            if (strpbrk (symbol-&gt; value, ";#="))
                sprintf (iniline, "    %s=\"%s\"", ini_keyword, symbol-&gt; value);
            else
                sprintf (iniline, "    %s=%s", ini_keyword, symbol-&gt; value);
            <A HREF="sfldoc.htm#file_write">file write</A> (inifile, iniline);
          }
      }
    <A HREF="sfldoc.htm#file_close">file close</A> (inifile);
    return (count);
}
</PRE>
<A NAME="ini_dyn_changed">&nbsp;</A>
<H3><A NAME="TOC151"><TT>ini_dyn_changed</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_dyn_changed (
    SYMTAB *symtab)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the ini file loaded into the specified table
   has in the meantime been changed. Returns FALSE if not.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (symtab);

    /*  Date, time, and name of original ini file are in the table           */
    filename = <A HREF="sfldoc.htm#sym_get_value">sym get value</A> (symtab, "filename", NULL);
    if (filename
    &amp;&amp;  <A HREF="sfldoc.htm#file_has_changed">file has changed</A> (filename,
                          <A HREF="sfldoc.htm#sym_get_number">sym get number</A> (symtab, "filedate", 0),
                          <A HREF="sfldoc.htm#sym_get_number">sym get number</A> (symtab, "filetime", 0)))
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="ini_dyn_refresh">&nbsp;</A>
<H3><A NAME="TOC152"><TT>ini_dyn_refresh</TT></A></H3>
<PRE>
#include "sflini.h"
Bool
ini_dyn_refresh (
    SYMTAB *symtab)
</PRE>
<H4>Synopsis</H4>
<P>Refreshes a symbol table created by <A HREF="sfldoc.htm#ini_dyn_load">ini dyn load</A>(). If the
   original file (as specified by the 'filename' symbol) has been
   modified, reloads the whole ini file. You would typically call
   this function at regular intervals to permit automatic
   reloading of an ini file in an application. Returns TRUE if the
   ini file was actually reloaded, or FALSE if the file had not
   changed or could not be accessed, or if the symbol table was
   incorrectly created. If the symbol table is reloaded from the
   ini file, all previous symbols are deleted.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (symtab);
    if (<A HREF="sfldoc.htm#ini_dyn_changed">ini dyn changed</A> (symtab))
      {
        filename = mem_strdup (<A HREF="sfldoc.htm#sym_get_value">sym get value</A> (symtab, "filename", NULL));
        <A HREF="sfldoc.htm#sym_empty_table">sym empty table</A> (symtab);       /*  Delete previous table contents   */
        <A HREF="sfldoc.htm#ini_dyn_load">ini dyn load</A> (symtab, filename);
        mem_free (filename);
        return (TRUE);
      }
    return (FALSE);
}
</PRE>
<A NAME="ini_dyn_value">&nbsp;</A>
<H3><A NAME="TOC153"><TT>ini_dyn_value</TT></A></H3>
<PRE>
#include "sflini.h"
char *
ini_dyn_value (
    SYMTAB *symtab,
    const char *section,
    const char *keyword,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>Finds a section:keyword in the symbol table and returns a
   pointer to its value. Returns the default value if the symbol
   is not defined in the table. The default value may be NULL. The
   specified section and keyword can be in any case; they are
   converted internally to lowercase to match the symbol table. If
   the keyword is empty or NULL, no ':keyword' is appended to the
   section name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (section);
    if (keyword &amp;&amp; *keyword)
        sprintf (ini_keyword, "%s:%s", section, keyword);
    else
        strcpy  (ini_keyword, section);

    <A HREF="sfldoc.htm#strlwc">strlwc</A> (ini_keyword);
    return (<A HREF="sfldoc.htm#sym_get_value">sym get value</A> (symtab, ini_keyword, default_value));
}
</PRE>
<A NAME="ini_dyn_values">&nbsp;</A>
<H3><A NAME="TOC154"><TT>ini_dyn_values</TT></A></H3>
<PRE>
#include "sflini.h"
char **
ini_dyn_values (
    SYMTAB *symtab,
    const char *section,
    const char *keyword,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>Finds a section:keyword in the symbol table and returns a
   pointer to a string table containing the values, delimited by
   commas. When finished with the string table you should call
   <A HREF="sfldoc.htm#tok_free">tok free</A>() to free the memory allocated for it. The default
   value may not be NULL. Returns a pointer to a table of string
   tokens (see <A HREF="sfldoc.htm#tok_split">tok split</A>()), or NULL if there was insufficient
   memory. The specified section and keyword can be in any case;
   they are converted internally to lowercase to match the symbol
   table. If the keyword is empty or NULL, no ':keyword' is
   appended to the section name.
<H4>Source Code - (sflini.c)</H4>
<PRE>
{
    ASSERT (section);
    ASSERT (default_value);

    if (keyword &amp;&amp; *keyword)
        sprintf (ini_keyword, "%s:%s", section, keyword);
    else
        strcpy  (ini_keyword, section);

    <A HREF="sfldoc.htm#strlwc">strlwc</A> (ini_keyword);
    strcpy (iniline, <A HREF="sfldoc.htm#sym_get_value">sym get value</A> (symtab, ini_keyword, default_value));
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (iniline, ',', ' ');
    return (<A HREF="sfldoc.htm#tok_split">tok split</A> (iniline));
}
</PRE>
<H2><A NAME="TOC155">Multilanguage support</A></H2>
<P>Filename: sfllang.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/06/04 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/05/31
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides hard-coded multilanguage dictionaries for dates and
   numbers, The hard-coded dictionaries work with most European
   languages.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#set_userlang">set userlang</A><BR>
   (int language);
</LI>
<LI>int <A HREF="sfldoc.htm#set_userlang_str">set userlang str</A><BR>
   (const char *language);
</LI>
<LI>int <A HREF="sfldoc.htm#get_userlang">get userlang</A><BR>
   (void);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_userlang_str">get userlang str</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_accents">set accents</A><BR>
   (Bool accents);
</LI>
<LI>Bool <A HREF="sfldoc.htm#get_accents">get accents</A><BR>
   (void);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_units_name">get units name</A><BR>
   (int units);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_tens_name">get tens name</A><BR>
   (int tens);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_day_name">get day name</A><BR>
   (int day);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_day_abbrev">get day abbrev</A><BR>
   (int day, Bool upper);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_month_name">get month name</A><BR>
   (int month);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_month_abbrev">get month abbrev</A><BR>
   (int month, Bool upper);
</LI>
<LI>char * <A HREF="sfldoc.htm#timestamp_string">timestamp string</A><BR>
   (char *buffer, const char *pattern);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllang.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>USERLANG_TOP</B>  </TT>
<TD ALIGN="LEFT">USERLANG_SV + 1
<TR><TD ALIGN="LEFT"><TT><B>_SFLLANG_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="set_userlang">&nbsp;</A>
<H3><A NAME="TOC156"><TT>set_userlang</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_userlang (int language)
</PRE>
<H4>Synopsis</H4>
<P>Sets language used for date and numeric translation. The valid
   user languages are: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>USERLANG DEFAULT</B>  <TD ALIGN="LEFT">Default
   language (use hard-coded values) <TR><TD
   ALIGN="LEFT"><B>USERLANG DA</B>  <TD ALIGN="LEFT">Danish
   <TR><TD ALIGN="LEFT"><B>USERLANG DE</B>  <TD
   ALIGN="LEFT">German <TR><TD ALIGN="LEFT"><B>USERLANG EN</B>
   <TD ALIGN="LEFT">English <TR><TD ALIGN="LEFT"><B>USERLANG
   ES</B>  <TD ALIGN="LEFT">Castillian Spanish <TR><TD
   ALIGN="LEFT"><B>USERLANG FB</B>  <TD ALIGN="LEFT">Belgian or
   Swiss French <TR><TD ALIGN="LEFT"><B>USERLANG FR</B>  <TD
   ALIGN="LEFT">French <TR><TD ALIGN="LEFT"><B>USERLANG IS</B>
   <TD ALIGN="LEFT">Icelandic <TR><TD ALIGN="LEFT"><B>USERLANG
   IT</B>  <TD ALIGN="LEFT">Italian <TR><TD
   ALIGN="LEFT"><B>USERLANG NL</B>  <TD ALIGN="LEFT">Dutch <TR><TD
   ALIGN="LEFT"><B>USERLANG NO</B>  <TD ALIGN="LEFT">Norwegian
   <TR><TD ALIGN="LEFT"><B>USERLANG PO</B>  <TD
   ALIGN="LEFT">Portuguese <TR><TD ALIGN="LEFT"><B>USERLANG SV</B>
   <TD ALIGN="LEFT">Swedish </TABLE> Returns 0 if okay, -1 if an
   unsupported language was specified.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    /*  Order of this table is not critical                                  */
    static struct {
        int  language;
        char **units;
        char **tens;
        char **days;
        char **months;
    } languages [] =
    {
        { USERLANG_DEFAULT, EN_units, EN_tens, EN_days, EN_months },
        { USERLANG_DA,      DA_units, DA_tens, EN_days, DA_months },
        { USERLANG_DE,      DE_units, DE_tens, EN_days, DE_months },
        { USERLANG_EN,      EN_units, EN_tens, EN_days, EN_months },
        { USERLANG_ES,      ES_units, ES_tens, EN_days, ES_months },
        { USERLANG_FB,      FR_units, FB_tens, FR_days, FR_months },
        { USERLANG_FR,      FR_units, FR_tens, FR_days, FR_months },
        { USERLANG_IS,      IS_units, IS_tens, EN_days, IS_months },
        { USERLANG_IT,      IT_units, IT_tens, EN_days, IT_months },
        { USERLANG_NL,      NL_units, NL_tens, NL_days, NL_months },
        { USERLANG_NO,      NO_units, NO_tens, EN_days, NO_months },
        { USERLANG_PO,      PO_units, PO_tens, EN_days, PO_months },
        { USERLANG_SV,      SV_units, SV_tens, EN_days, SV_months },
        { -1,               NULL,     NULL,    NULL,    NULL      }
    };

    int
        index;

    for (index = 0; languages [index].language != -1; index++)
        if (languages [index].language == language)
          {
            user_language = language;
            units_table   = languages [index].units;
            tens_table    = languages [index].tens;
            day_table     = languages [index].days;
            month_table   = languages [index].months;
            return (0);
          }
    return (-1);
}
</PRE>
<A NAME="set_userlang_str">&nbsp;</A>
<H3><A NAME="TOC157"><TT>set_userlang_str</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_userlang_str (const char *language)
</PRE>
<H4>Synopsis</H4>
<P>Sets language used for date and numeric translation, using a
   string representation of the language. The valid user languages
   are: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>""</B>  <TD
   ALIGN="LEFT">Default language (use hard-coded values) <TR><TD
   ALIGN="LEFT"><B>"--"</B>  <TD ALIGN="LEFT">Alternative form for
   default language <TR><TD ALIGN="LEFT"><B>"DA"</B>  <TD
   ALIGN="LEFT">Danish <TR><TD ALIGN="LEFT"><B>"DE"</B>  <TD
   ALIGN="LEFT">German <TR><TD ALIGN="LEFT"><B>"EN"</B>  <TD
   ALIGN="LEFT">English <TR><TD ALIGN="LEFT"><B>"ES"</B>  <TD
   ALIGN="LEFT">Castillian Spanish <TR><TD
   ALIGN="LEFT"><B>"FB"</B>  <TD ALIGN="LEFT">Belgian or Swiss
   French <TR><TD ALIGN="LEFT"><B>"FR"</B>  <TD
   ALIGN="LEFT">French <TR><TD ALIGN="LEFT"><B>"IS"</B>  <TD
   ALIGN="LEFT">Icelandic <TR><TD ALIGN="LEFT"><B>"IT"</B>  <TD
   ALIGN="LEFT">Italian <TR><TD ALIGN="LEFT"><B>"NL"</B>  <TD
   ALIGN="LEFT">Dutch <TR><TD ALIGN="LEFT"><B>"NO"</B>  <TD
   ALIGN="LEFT">Norwegian <TR><TD ALIGN="LEFT"><B>"PO"</B>  <TD
   ALIGN="LEFT">Portuguese <TR><TD ALIGN="LEFT"><B>"SV"</B>  <TD
   ALIGN="LEFT">Swedish </TABLE> Returns 0 if okay, -1 if an
   unsupported language was specified.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    int
        index;

    if (strnull (language))
        return (<A HREF="sfldoc.htm#set_userlang">set userlang</A> (USERLANG_DEFAULT));

    for (index = 0; index &lt; USERLANG_TOP; index++)
        if (streq (language, language_str [index]))
            return (<A HREF="sfldoc.htm#set_userlang">set userlang</A> (index));

    return (-1);
}
</PRE>
<A NAME="get_userlang">&nbsp;</A>
<H3><A NAME="TOC158"><TT>get_userlang</TT></A></H3>
<PRE>
#include "sfllang.h"
int
get_userlang (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current user language code.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (user_language);
}
</PRE>
<A NAME="get_userlang_str">&nbsp;</A>
<H3><A NAME="TOC159"><TT>get_userlang_str</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_userlang_str (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current user language as a 2-character string.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (language_str [user_language]);
}
</PRE>
<A NAME="set_accents">&nbsp;</A>
<H3><A NAME="TOC160"><TT>set_accents</TT></A></H3>
<PRE>
#include "sfllang.h"
int
set_accents (Bool accents)
</PRE>
<H4>Synopsis</H4>
<P>Enables or disables native-language accents. If enabled,
   accented characters in translated words are produced in the
   current system character set, if possible. Otherwise, suitable
   translations are made into the 26-letter English alphabet. By
   default, accents are enabled.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    use_accents = accents;
    return (0);
}
</PRE>
<A NAME="get_accents">&nbsp;</A>
<H3><A NAME="TOC161"><TT>get_accents</TT></A></H3>
<PRE>
#include "sfllang.h"
Bool
get_accents (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if accents are enabled, FALSE if not.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    return (use_accents);
}
</PRE>
<A NAME="get_units_name">&nbsp;</A>
<H3><A NAME="TOC162"><TT>get_units_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_units_name (int units)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified units, which is a value from
   zero to 19. Accented characters are formatted according to the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (units &gt;= 0 &amp;&amp; units &lt;= 19);
    return (handle_accents (units_table [units]));
}
</PRE>
<A NAME="get_tens_name">&nbsp;</A>
<H3><A NAME="TOC163"><TT>get_tens_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_tens_name (int tens)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified tens, which is a value from
   10 to 90; it is rounded as required. Accented characters are
   formatted according to the current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (tens &gt;= 10 &amp;&amp; tens &lt; 100);
    return (handle_accents (tens_table [tens / 10 - 1]));
}
</PRE>
<A NAME="get_day_name">&nbsp;</A>
<H3><A NAME="TOC164"><TT>get_day_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_day_name (int day)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified day, which must be a value
   from 0 (Sunday) to 6 (Saturday). Accented characters are
   formatted according to the current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (day &gt;= 0 &amp;&amp; day &lt;= 6);
    return (handle_accents (day_table [day]));
}
</PRE>
<A NAME="get_day_abbrev">&nbsp;</A>
<H3><A NAME="TOC165"><TT>get_day_abbrev</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_day_abbrev (int day, Bool upper)
</PRE>
<H4>Synopsis</H4>
<P>Returns the abbreviation for the specified day, which must be a
   value from 0 (Sunday) to 6 (Saturday). The abbreviation (3
   letters) is converted into uppercase if the 'upper' argument is
   true. Accented characters are formatted according to the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    char
        abbrev [4];

    ASSERT (day &gt;= 0 &amp;&amp; day &lt;= 6);

    strncpy (abbrev, day_table [day], 3);
    abbrev [3] = '\0';
    if (upper)
        <A HREF="sfldoc.htm#strupc">strupc</A> (abbrev);
    return (handle_accents (abbrev));
}
</PRE>
<A NAME="get_month_name">&nbsp;</A>
<H3><A NAME="TOC166"><TT>get_month_name</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_month_name (int month)
</PRE>
<H4>Synopsis</H4>
<P>Returns the name for the specified month, which must be a value
   from 1 to 12. Accented characters are handled as per the
   current accents setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    ASSERT (month &gt;= 1 &amp;&amp; month &lt;= 12);
    return (handle_accents (month_table [month - 1]));
}
</PRE>
<A NAME="get_month_abbrev">&nbsp;</A>
<H3><A NAME="TOC167"><TT>get_month_abbrev</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
get_month_abbrev (int month, Bool upper)
</PRE>
<H4>Synopsis</H4>
<P>Returns the abbreviation for the specified month, which must be
   a value from 1 to 12. The abbreviation (3 letters) is converted
   into uppercase if the 'upper' argument is true. Accented
   characters are formatted according to the current accents
   setting.
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    char
        abbrev [4];

    ASSERT (month &gt;= 1 &amp;&amp; month &lt;= 12);

    strncpy (abbrev, month_table [month - 1], 3);
    abbrev [3] = '\0';
    if (upper)
        <A HREF="sfldoc.htm#strupc">strupc</A> (abbrev);

    return (handle_accents (abbrev));
}
</PRE>
<A NAME="timestamp_string">&nbsp;</A>
<H3><A NAME="TOC168"><TT>timestamp_string</TT></A></H3>
<PRE>
#include "sfllang.h"
char *
timestamp_string (char *buffer, const char *pattern)
</PRE>
<H4>Synopsis</H4>
<P>Formats a timestamp according to a user-supplied pattern. The
   result is returned in a buffer supplied by the caller; if this
   argument is NULL, allocates a buffer and returns that (the
   caller must then free the buffer using mem_free()). The pattern
   consists of arbitrary text mixed with insertion symbols
   indicated by '%': <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>%y</B>  <TD ALIGN="LEFT">day of year, 001-366
   <TR><TD ALIGN="LEFT"><B>%yy</B>  <TD ALIGN="LEFT">year 2
   digits, 00-99 <TR><TD ALIGN="LEFT"><B>%yyyy</B>  <TD
   ALIGN="LEFT">year 4 digits, 100-9999 <TR><TD
   ALIGN="LEFT"><B>%mm</B>  <TD ALIGN="LEFT">month, 01-12 <TR><TD
   ALIGN="LEFT"><B>%mmm</B>  <TD ALIGN="LEFT">month, Jan <TR><TD
   ALIGN="LEFT"><B>%mmmm</B>  <TD ALIGN="LEFT">month, January
   <TR><TD ALIGN="LEFT"><B>%MMM</B>  <TD ALIGN="LEFT">month, JAN
   <TR><TD ALIGN="LEFT"><B>%MMMM</B>  <TD ALIGN="LEFT">month,
   JANUARY <TR><TD ALIGN="LEFT"><B>%dd</B>  <TD ALIGN="LEFT">day,
   01-31 <TR><TD ALIGN="LEFT"><B>%ddd</B>  <TD ALIGN="LEFT">day of
   week, Sun <TR><TD ALIGN="LEFT"><B>%dddd</B>  <TD
   ALIGN="LEFT">day of week, Sunday <TR><TD
   ALIGN="LEFT"><B>%DDD</B>  <TD ALIGN="LEFT">day of week, SUN
   <TR><TD ALIGN="LEFT"><B>%DDDD</B>  <TD ALIGN="LEFT">day of
   week, SUNDAY <TR><TD ALIGN="LEFT"><B>%w</B>  <TD
   ALIGN="LEFT">day of week, 1-7 (1=Sunday) <TR><TD
   ALIGN="LEFT"><B>%ww</B>  <TD ALIGN="LEFT">week of year, 01-53
   <TR><TD ALIGN="LEFT"><B>%q</B>  <TD ALIGN="LEFT">year quarter,
   1-4 <TR><TD ALIGN="LEFT"><B>%h</B>  <TD ALIGN="LEFT">hour, 00-
   23 <TR><TD ALIGN="LEFT"><B>%m</B>  <TD ALIGN="LEFT">minute, 00-
   59 <TR><TD ALIGN="LEFT"><B>%s</B>  <TD ALIGN="LEFT">second, 00-
   59 <TR><TD ALIGN="LEFT"><B>%c</B>  <TD
   ALIGN="LEFT">centisecond, 00-99 <TR><TD ALIGN="LEFT"><B>%%</B>
   <TD ALIGN="LEFT">literal character % </TABLE>
<H4>Source Code - (sfllang.c)</H4>
<PRE>
{
    long
        date,                           /*  Current date                     */
        time;                           /*    and time                       */
    int
        century,                        /*  Century component of date        */
        year,                           /*  Year component of date           */
        month,                          /*  Month component of date          */
        day,                            /*  Day component of date            */
        hour,                           /*  Hour component of time           */
        minute,                         /*  Minute component of time         */
        second,                         /*  Second component of time         */
        centi,                          /*  1/100 sec component of time      */
        cursize;                        /*  Size of current component        */
    char
       *dest,                           /*  Store formatted data here        */
        ch;                             /*  Next character in picture        */

    date = <A HREF="sfldoc.htm#date_now">date now</A> ();
    time = <A HREF="sfldoc.htm#time_now">time now</A> ();

    century = GET_CENTURY (date);
    year    = GET_YEAR    (date);
    month   = GET_MONTH   (date);
    day     = GET_DAY     (date);
    hour    = GET_HOUR    (time);
    minute  = GET_MINUTE  (time);
    second  = GET_SECOND  (time);
    centi   = GET_CENTI   (time);

    if (buffer == NULL)
        buffer = mem_alloc (strlen (pattern) * 2);

    /*  Scan through picture, converting each component                      */
    dest = buffer;
    *dest = 0;                          /*  String is empty                  */
    while (*pattern)
      {
        ch = *pattern++;
        if (ch == '%' &amp;&amp; *pattern)
          {
            ch = *pattern++;            /*  Count size of pattern after %    */
            for (cursize = 1; *pattern == ch; cursize++)
                pattern++;
          }
        else
          {
            *dest++ = ch;               /*  Something else - store and next  */
            *dest = 0;                  /*  Terminate the string nicely      */
            continue;
          }

        /*  Now process pattern itself                                       */
        switch (ch)
          {
            case 'y':
                if (cursize == 1)       /*  y     day of year, 001-366       */
                    sprintf (dest, "%03d", <A HREF="sfldoc.htm#julian_date">julian date</A> (date));
                else
                if (cursize == 2)       /*  yy    year 2 digits, 00-99       */
                    sprintf (dest, "%02d", year);
                else
                if (cursize == 4)       /*  yyyy  year 4 digits, 0100-9999   */
                    sprintf (dest, "%02d%02d", century, year);
                break;

            case 'm':
                if (cursize == 1)       /*  m     minute, 00-59              */
                    sprintf (dest, "%02d", minute);
                else
                if (cursize == 2)       /*  mm    month, 01-12               */
                    sprintf (dest, "%02d", month);
                else
                if (cursize == 3)       /*  mmm   month, 3 letters           */
                    strcpy (dest, <A HREF="sfldoc.htm#get_month_abbrev">get month abbrev</A> (month, FALSE));
                else
                if (cursize == 4)       /*  mmmm  month, full name           */
                    strcpy (dest, <A HREF="sfldoc.htm#get_month_name">get month name</A> (month));
                break;

            case 'M':
                if (cursize == 3)       /*  MMM   month, 3-letters, ucase    */
                    strcpy (dest, <A HREF="sfldoc.htm#get_month_abbrev">get month abbrev</A> (month, TRUE));
                else
                if (cursize == 4)       /*  MMMM  month, full name, ucase    */
                  {
                    strcpy (dest, <A HREF="sfldoc.htm#get_month_name">get month name</A> (month));
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            case 'd':
                if (cursize == 2)       /*  dd    day, 01-31                 */
                    sprintf (dest, "%02d", day);
                else
                if (cursize == 3)       /*  ddd   day of week, Sun           */
                    strcpy (dest, <A HREF="sfldoc.htm#get_day_abbrev">get day abbrev</A> (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date), FALSE));
                else
                if (cursize == 4)       /*  dddd  day of week, Sunday        */
                    strcpy (dest, <A HREF="sfldoc.htm#get_day_name">get day name</A> (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date)));
                break;

            case 'D':
                if (cursize == 3)       /*  DDD   day of week, SUN           */
                    strcpy (dest, <A HREF="sfldoc.htm#get_day_abbrev">get day abbrev</A> (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date), TRUE));
                else
                if (cursize == 4)       /*  DDDD  day of week, SUNDAY        */
                  {
                    strcpy (dest, <A HREF="sfldoc.htm#get_day_name">get day name</A> (<A HREF="sfldoc.htm#day_of_week">day of week</A> (date)));
                    <A HREF="sfldoc.htm#strupc">strupc</A> (dest);
                  }
                break;

            case 'w':
                if (cursize == 1)       /*  w     day of week, 1-7 (1=Sun)   */
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#day_of_week">day of week</A> (date) + 1);
                else
                if (cursize == 2)       /*  ww    week of year, 01-53        */
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#week_of_year">week of year</A> (date));
                break;

            case 'q':
                if (cursize == 1)       /*  q     year quarter, 1-4          */
                    sprintf (dest, "%d", <A HREF="sfldoc.htm#year_quarter">year quarter</A> (date));
                break;

            case 'h':
                if (cursize == 1)       /*  h     hour, 00-23                */
                    sprintf (dest, "%02d", hour);
                break;

            case 's':
                if (cursize == 1)       /*  s     second, 00-59              */
                    sprintf (dest, "%02d", second);
                break;

            case 'c':
                if (cursize == 1)       /*  c     centisecond, 00-99         */
                    sprintf (dest, "%02d", centi);
                break;

            case '%':
                if (cursize == 1)       /*  %     literal '%'                */
                    strcpy (dest, "%");
                break;
        }
        if (*dest)                      /*  If something was output,         */
            while (*dest)               /*    skip to end of string          */
                dest++;
        else
          {
            while (cursize--)           /*  Else output ch once or more      */
                *dest++ = ch;           /*    and bump dest pointer          */
            *dest = 0;                  /*  Terminate the string nicely      */
          }
    }
    return (buffer);
}
</PRE>
<H2><A NAME="TOC169">Line buffering functions</A></H2>
<P>Filename: sfllbuf.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/09/07 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides circular line buffering functions. A line buffer is a
   data structure that holds a fixed amount of data in a serial
   fashion; the oldest data gets discarded as new data is added.
<H4>List of Functions</H4>
<UL>
<LI>LINEBUF * <A HREF="sfldoc.htm#linebuf_create">linebuf create</A><BR>
   (size_t maxsize);
</LI>
<LI>void <A HREF="sfldoc.htm#linebuf_destroy">linebuf destroy</A><BR>
   (LINEBUF *buffer);
</LI>
<LI>void <A HREF="sfldoc.htm#linebuf_reset">linebuf reset</A><BR>
   (LINEBUF *buffer);
</LI>
<LI>void <A HREF="sfldoc.htm#linebuf_append">linebuf append</A><BR>
   (LINEBUF *buffer, const char *line);
</LI>
<LI>char * <A HREF="sfldoc.htm#linebuf_first">linebuf first</A><BR>
   (LINEBUF *buffer, DESCR *line);
</LI>
<LI>char * <A HREF="sfldoc.htm#linebuf_next">linebuf next</A><BR>
   (LINEBUF *buffer, DESCR *line, const char *cur);
</LI>
<LI>char * <A HREF="sfldoc.htm#linebuf_last">linebuf last</A><BR>
   (LINEBUF *buffer, DESCR *line);
</LI>
<LI>char * <A HREF="sfldoc.htm#linebuf_prev">linebuf prev</A><BR>
   (LINEBUF *buffer, DESCR *line, const char *cur);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllbuf.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLLBUF_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="linebuf_create">&nbsp;</A>
<H3><A NAME="TOC170"><TT>linebuf_create</TT></A></H3>
<PRE>
#include "sfllbuf.h"
LINEBUF *
linebuf_create (size_t maxsize)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new line buffer with the specified size. The size
   must be at least LINE_MAX + 1 characters long. Returns the
   address of the newly-created buffer, or NULL if there was
   insufficient memory. The fresh line buffer is set to empty
   (tail == head).
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    LINEBUF
        *buffer;

    ASSERT (maxsize &gt; LINE_MAX);

    buffer = mem_alloc (sizeof (LINEBUF));
    if (!buffer)
        return (NULL);

    buffer-&gt; data = mem_alloc (maxsize);
    if (!buffer-&gt; data)
      {
        free (buffer);
        return (NULL);
      }

    buffer-&gt; head = buffer-&gt; data;
    buffer-&gt; tail = buffer-&gt; data;
    buffer-&gt; top  = buffer-&gt; data + maxsize;
    buffer-&gt; size = maxsize;
    return (buffer);
}
</PRE>
<A NAME="linebuf_destroy">&nbsp;</A>
<H3><A NAME="TOC171"><TT>linebuf_destroy</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_destroy (LINEBUF *buffer)
</PRE>
<H4>Synopsis</H4>
<P>Destroys a line buffer and frees its memory.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);

    mem_free (buffer-&gt; data);
    mem_free (buffer);
}
</PRE>
<A NAME="linebuf_reset">&nbsp;</A>
<H3><A NAME="TOC172"><TT>linebuf_reset</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_reset (LINEBUF *buffer)
</PRE>
<H4>Synopsis</H4>
<P>Resets a line buffer; i.e. empties it of all data. This is done
   simply by setting the tail and head to the start of the buffer.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    buffer-&gt; head = buffer-&gt; data;
    buffer-&gt; tail = buffer-&gt; data;
}
</PRE>
<A NAME="linebuf_append">&nbsp;</A>
<H3><A NAME="TOC173"><TT>linebuf_append</TT></A></H3>
<PRE>
#include "sfllbuf.h"
void
linebuf_append (LINEBUF *buffer, const char *line)
</PRE>
<H4>Synopsis</H4>
<P>Appends a line to the line buffer. If the buffer was full, the
   oldest line is lost. Updates the buffer head and tail as
   needed.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    int
        length,                         /*  Size of line to insert           */
        room_left,                      /*  Space left between head and top  */
        tail_old,                       /*  Offset of tail into buffer       */
        head_old,                       /*  Offset of head before insert     */
        head_new;                       /*  Offset of head after insert      */
    char
        *linedata;                      /*  Address of data to store         */

    ASSERT (buffer);
    ASSERT (line);

    linedata  = (char *) line;
    length    = strlen (line) + 1;      /*  Include trailing null            */
    room_left = (int) (buffer-&gt; top - buffer-&gt; head);

    /*  We need to make space for the new line; we calculate the new head
     *  and if the tail falls between the old and new head, it must be moved
     *  up to the next line start.  We compare 'ints' not 'char *' because
     *  they can be negative.
     */
    tail_old = (int) (buffer-&gt; tail - buffer-&gt; data);
    head_old = (int) (buffer-&gt; head - buffer-&gt; data);
    if (head_old &gt; tail_old)            /*  Shift head_old down to get it    */
        head_old -= buffer-&gt; size;      /*    somewhere before tail_old      */
    head_new = head_old + length;       /*  And calculate head_new           */

    /*  If the line is too large for the remaining space, copy what we can   */
    if (length &gt; room_left)
      {
        memcpy (buffer-&gt; head, linedata, room_left);
        linedata += room_left;
        length   -= room_left;
        buffer-&gt; head = buffer-&gt; data;  /*  Bump head to start of buffer     */
      }
    /*  Copy rest of line to buffer                                          */
    memcpy (buffer-&gt; head, linedata, length);
    buffer-&gt; head += length;            /*  Bump head past string            */
    if (buffer-&gt; head == buffer-&gt; top)  /*    and maybe wrap-around          */
        buffer-&gt; head = buffer-&gt; data;

    ASSERT (buffer-&gt; head &lt;= buffer-&gt; top);

    if (head_old &lt;  tail_old            /*  If tail falls between head_old   */
    &amp;&amp;  tail_old &lt;= head_new)           /*    and/on head_new, bump it up    */
        buffer-&gt; tail = start_next_line (buffer, buffer-&gt; head);
}
</PRE>
<A NAME="linebuf_first">&nbsp;</A>
<H3><A NAME="TOC174"><TT>linebuf_first</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_first (LINEBUF *buffer, DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the oldest line in the buffer. Returns a pointer that
   may be used in calls to <A HREF="sfldoc.htm#linebuf_next">linebuf next</A>(). Returns NULL if the
   buffer is empty. The line is stored in the supplied descriptor,
   and is truncated if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);

    return (<A HREF="sfldoc.htm#linebuf_next">linebuf next</A> (buffer, descr, buffer-&gt; tail));
}
</PRE>
<A NAME="linebuf_next">&nbsp;</A>
<H3><A NAME="TOC175"><TT>linebuf_next</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_next (LINEBUF *buffer, DESCR *descr, const char *curline)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the next line in the buffer, using the pointer that was
   returned by <A HREF="sfldoc.htm#linebuf_first">linebuf first</A>(). Returns NULL if there are no
   more lines in the buffer, or a pointer for further calls. The
   line is stored in the supplied descriptor, and is truncated if
   the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);
    ASSERT (curline);

    if (curline == buffer-&gt; head)
        return (NULL);                  /*  We're at the end                 */
    else
        return (get_line (buffer, descr, curline));
}
</PRE>
<A NAME="linebuf_last">&nbsp;</A>
<H3><A NAME="TOC176"><TT>linebuf_last</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_last (LINEBUF *buffer, DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the newest line in the buffer. Returns a pointer that
   may be used in calls to <A HREF="sfldoc.htm#linebuf_next">linebuf next</A>(). Returns NULL if the
   buffer is empty. The line is stored in the supplied descriptor,
   and is truncated if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);

    return (<A HREF="sfldoc.htm#linebuf_prev">linebuf prev</A> (buffer, descr, buffer-&gt; head));
}
</PRE>
<A NAME="linebuf_prev">&nbsp;</A>
<H3><A NAME="TOC177"><TT>linebuf_prev</TT></A></H3>
<PRE>
#include "sfllbuf.h"
char *
linebuf_prev (LINEBUF *buffer, DESCR *descr, const char *curline)
</PRE>
<H4>Synopsis</H4>
<P>Fetches the previous line in the buffer, using the pointer that
   was returned by <A HREF="sfldoc.htm#linebuf_last">linebuf last</A>(). Returns NULL if there are
   no more lines in the buffer, or a pointer for further calls.
   The line is stored in the supplied descriptor, and is truncated
   if the descriptor is too small.
<H4>Source Code - (sfllbuf.c)</H4>
<PRE>
{
    ASSERT (buffer);
    ASSERT (descr);
    ASSERT (curline);

    if (curline == buffer-&gt; tail)
        return (NULL);                  /*  We're at the start               */
    else
      {
        /*  We're pointing to the byte after the line's null byte            */
        buffer_dec (curline);           /*  Bump down to null                */
        ASSERT (*curline == '\0');

        do
          {
            buffer_dec (curline);       /*  And now look for previous null   */
            if (*curline == '\0')
              {
                buffer_inc (curline);   /*  Bump up to start of string       */
                break;
              }
          }
        until (curline == buffer-&gt; tail);

        get_line (buffer, descr, curline);
        return ((char *) curline);
      }
}
</PRE>
<H2><A NAME="TOC178">Linked-list functions</A></H2>
<P>Filename: sfllist.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/07/28 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/07/26
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to maintain doubly-linked lists. You can use
   these functions to work with lists of any structure. To make
   this work, all structures must start with two pointers, "void
   *next, *prev;". When you want to attach a linked-list to
   another structure, declare the list head as a list. You can
   then refer to this variable when you attach items to the list
   head. The code sets the global list_unsafe to TRUE whenever it
   is changing a list.
<H4>List of Functions</H4>
<UL>
<LI>void * <A HREF="sfldoc.htm#list_relink">list relink</A><BR>
   (void *left, void *list, void *right);
</LI>
<LI>void * <A HREF="sfldoc.htm#list_unlink">list unlink</A><BR>
   ( void *list );
</LI>
<LI>void * <A HREF="sfldoc.htm#list_add">list add</A><BR>
   (LIST *list, void *data, size_t size);
</LI>
<LI>void <A HREF="sfldoc.htm#list_remove">list remove</A><BR>
   (LIST *list, void *data, size_t size);
</LI>
<LI>void <A HREF="sfldoc.htm#list_sort">list sort</A><BR>
   (void *list, NODE_COMPARE comp);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfllist.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FORLIST(node,root)</B>  </TT>
<TD ALIGN="LEFT">for ((node) = (root).next; <TR><TD ALIGN="LEFT"><TT><B>_SFLLIST_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>list_create(node,size)</B>  </TT>
<TD ALIGN="LEFT">if (((node) = mem_alloc (size)) != NULL) <TR><TD ALIGN="LEFT"><TT><B>list_empty(list)</B>  </TT>
<TD ALIGN="LEFT">((list)-&gt; prev == (list))
<TR><TD ALIGN="LEFT"><TT><B>list_pop(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_remove (list, <TR><TD ALIGN="LEFT"><TT><B>list_push(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_add (list, <TR><TD ALIGN="LEFT"><TT><B>list_queue(list,item)</B>  </TT>
<TD ALIGN="LEFT">list_add (((LIST *)list)-&gt; prev, <TR><TD ALIGN="LEFT"><TT><B>list_relink_after(l,a)</B>  </TT>
<TD ALIGN="LEFT">(list_relink (a, l, ((LIST *) a)-&gt; next))
<TR><TD ALIGN="LEFT"><TT><B>list_relink_before(l,b)</B>  </TT>
<TD ALIGN="LEFT">(list_relink (((LIST *) b)-&gt; prev, l, b))
<TR><TD ALIGN="LEFT"><TT><B>list_reset(list)</B>  </TT>
<TD ALIGN="LEFT">(list)-&gt; prev = (list)-&gt; next = (list)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>NODE_COMPARE</B>  </TT>
<TD ALIGN="LEFT">Bool (*) (LIST *t1, LIST *t2)
</TABLE>
<A NAME="list_unlink">&nbsp;</A>
<H3><A NAME="TOC179"><TT>list_unlink</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_unlink (
    void *list)
</PRE>
<H4>Synopsis</H4>
<P>Unlinks the list from any list it may be in. Returns list.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    list_unsafe = TRUE;

    /*  Join together next and previous nodes */
    ((LIST *) ((LIST *) list)-&gt; prev)-&gt; next = ((LIST *) list)-&gt; next;
    ((LIST *) ((LIST *) list)-&gt; next)-&gt; prev = ((LIST *) list)-&gt; prev;

    /*  The list is now empty */
    list_reset ((LIST *) list);

    list_unsafe = FALSE;
    return (list);
}
</PRE>
<A NAME="list_relink">&nbsp;</A>
<H3><A NAME="TOC180"><TT>list_relink</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_relink (
    void *left,
    void *list,
    void *right)
</PRE>
<H4>Synopsis</H4>
<P>Links the list into a linked list. This is a general-purpose
   function that can be used to attach and remove lists anywhere
   in a list. Sets the global variable 'list_unsafe' while the
   list is being changed. Returns the address of list.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    LIST *swap;

    list_unsafe = TRUE;
    swap = ((LIST *) left)-&gt; next;      /*  Exchange left pointers           */
           ((LIST *) left)-&gt; next = list;
    ((LIST *) ((LIST *) list)-&gt; prev)-&gt; next = swap;

    swap = ((LIST *) right)-&gt; prev;     /*  Exchange right pointers          */
           ((LIST *) right)-&gt; prev = ((LIST *) list)-&gt; prev;
                                     ((LIST *) list)-&gt; prev = swap;

    list_unsafe = FALSE;
    return (list);
}
</PRE>
<A NAME="list_add">&nbsp;</A>
<H3><A NAME="TOC181"><TT>list_add</TT></A></H3>
<PRE>
#include "sfllist.h"
void *
list_add (LIST *list, void *data, size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Creates a node at the head of a list of a specified size and
   copies the specified data into it. Use with the stack &amp;
   queue macros list_push and list_queue.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
LIST
    *node;

    node = mem_alloc (sizeof (LIST) + size);
    if (node)
      {
	list_reset (node);
	list_relink_after (node, list);
	memcpy ((char *) node + sizeof (LIST), (char *) data, size);
      }
    return node;
}
</PRE>
<A NAME="list_remove">&nbsp;</A>
<H3><A NAME="TOC182"><TT>list_remove</TT></A></H3>
<PRE>
#include "sfllist.h"
void
list_remove (LIST *list, void *data, size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Removes the node at the head of a list, copying the specified
   amount of data to the specified data block. This size must be
   exactly equal to the size of the data block. The list may not
   be empty. Use this with the macro list_pop.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
LIST
    *node;

    ASSERT (!list_empty (list));

    node = list-&gt; next;
    ASSERT (mem_size (node) - sizeof (LIST) == size);

    memcpy ((char *) data, (char *) node + sizeof (LIST), size);
    <A HREF="sfldoc.htm#list_unlink">list unlink</A> (node);
    mem_free (node);
}
</PRE>
<A NAME="list_sort">&nbsp;</A>
<H3><A NAME="TOC183"><TT>list_sort</TT></A></H3>
<PRE>
#include "sfllist.h"
void list_sort (void *list, NODE_COMPARE comp)
</PRE>
<H4>Synopsis</H4>
<P>Sorts a list using the "comb-sort" algorithm.
<H4>Source Code - (sfllist.c)</H4>
<PRE>
{
    int
        jump_size,
        i;
    LIST
        *base,
        *swap,
        *temp;
    Bool
        swapped;

    jump_size = 0;
    FORLIST (base, * (LIST *) list)
        jump_size++;

    swapped = TRUE;
    while ((jump_size &gt; 1) || swapped)
      {
	jump_size = (10 * jump_size + 3) / 13;
	base = ((LIST *) list)-&gt; next;
	swap = base;
	for (i = 0; i &lt; jump_size; i++)
	    swap = swap-&gt; next;

	swapped = FALSE;
	while (swap != (LIST *) list)
	  {
	    if ((*comp) (base, swap))
	      {
		temp = base-&gt; prev;
		<A HREF="sfldoc.htm#list_unlink">list unlink</A> (base);
		list_relink_after (base, swap);
		<A HREF="sfldoc.htm#list_unlink">list unlink</A> (swap);
		list_relink_after (swap, temp);
		temp = base;
		base = swap;
		swap = temp;
		swapped = TRUE;
	      }
	    base = base-&gt; next;
	    swap = swap-&gt; next;
	  }
      }
}
</PRE>
<H2><A NAME="TOC184">SMTP mailer function</A></H2>
<P>Filename: sflmail.h
<BR>Package: standard function library (sfl)
<BR>Written: 06/18/97 Scott Beasley (jscottb@infoave.com)
<BR>Revised: 98/05/11
<BR>Copyright: Copyright (C) 1991-97 Imatix
<H3>Synopsis</H3>
<P>Functions to format and send SMTP messages. Messages can
   contain attachments, and be sent with "cc"'s "bcc"'s as well as
   the normal "to" receivers.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#smtp_send_mail_ex">smtp send mail ex</A><BR>
   (SMTP *smtp);
</LI>
<LI>int <A HREF="sfldoc.htm#smtp_send_mail">smtp send mail</A><BR>
   (char *strsmtpserver, char *strmsgbody, char *strsubject, char
   *strsenderuserid, char *strDestUserIds, char *strccuserids,
   char *strbccuserids, char *strRetPathUserId, char
   *strRrcpUserId, char *strMsgComment, char *strMailerName, char
   *strBinfiles, char *strTxtFiles);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmail.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_sflmail_included</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="smtp_send_mail_ex">&nbsp;</A>
<H3><A NAME="TOC185"><TT>smtp_send_mail_ex</TT></A></H3>
<PRE>
#include "sflmail.h"
int smtp_send_mail_ex (
   SMTP *smtp)
</PRE>
<H4>Synopsis</H4>
<P>Format and send a SMTP message. This function gives you the
   options of sneding to multi receivers, CC's, Bcc's and also
   send UUencoded attachments. Receivers and files are ";" or ","
   terminated. &lt;PRE&gt; NOTE: The sock_init function should be
   called before use of this function. &lt;/PRE&gt;
<H4>Source Code - (sflmail.c)</H4>
<PRE>
{
   FILE *fpin;
   int iCnt;
   sock_t iSocket;
   char strOut[514], strFile[256], strRetBuff[513];
   char strUUEFile[256], *strRcptUserIds;
   int iOld_ip_nonblock = ip_nonblock;

   /* Make sure we do not block. */
   ip_nonblock = FALSE;

   /* Open up the SMTP port (25 most of the time). */
   iSocket = <A HREF="sfldoc.htm#connect_socket">connect socket</A> (smtp-&gt;strSmtpServer,
                             "smtp", "tcp", NULL,
                             smtp-&gt;connect_retry_cnt,
                             smtp-&gt;retry_wait_time);

   if (getreply (iSocket, smtp) &gt; 400 || iSocket &lt; 1)
     {
       return -1;
     }

   /* Format a SMTP meassage header.  */
   /* Just say hello to the mail server. */
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "HELO ", <A HREF="sfldoc.htm#get_hostname">get hostname</A> (), "\n", NULL);
   smtp_send_data (iSocket, strOut);
   if (getreply (iSocket, smtp) &gt; 400)
       return -2;

   /* Tell the mail server who the message is from. */
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "MAIL FROM:&lt;", smtp-&gt;strSenderUserId, "&gt;\n", NULL);
   smtp_send_data (iSocket, strOut);
   if (getreply (iSocket, smtp) &gt; 400)
       return -3;

   strRcptUserIds = (char *) malloc (strlen (smtp-&gt;strDestUserIds) +
                                     strlen (smtp-&gt;strCcUserIds) +
                                     strlen (smtp-&gt;strBccUserIds) + 1);
   sprintf (strRcptUserIds, "%s;%s;%s", smtp-&gt;strDestUserIds,
            smtp-&gt;strCcUserIds, smtp-&gt;strBccUserIds);
   /* The following tells the mail server who to send it to. */
   iCnt = 0;
   while (1)
     {
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strRcptUserIds, iCnt++, 0, ",;", strRetBuff);

       if (*strRetBuff)
         {
           <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "RCPT TO:&lt;", strRetBuff, "&gt;\r\n", NULL);
           smtp_send_data (iSocket, strOut);
           if (getreply (iSocket, smtp) &gt; 400)
               return -4;
         }

       else
           break;
     }

   free (strRcptUserIds);

   /* Now give it the Subject and the message to send. */
   smtp_send_data (iSocket, "DATA\r\n");
   if (getreply (iSocket, smtp) &gt; 400)
       return -5;

   /* Set the date and time of the message. */
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> ( strOut, "Date: ", <A HREF="sfldoc.htm#encode_mime_time">encode mime time</A> (<A HREF="sfldoc.htm#date_now">date now</A> (), <A HREF="sfldoc.htm#time_now">time now</A> ()),
             " \r\n", NULL );

   /* The following shows all who it was sent to. */
   <A HREF="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strDestUserIds, ";", ',');
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "To: ", smtp-&gt;strDestUserIds, "\r\n", NULL);

   /* Set up the Reply-To path. */
   if (!smtp-&gt;strRetPathUserId || !*smtp-&gt;strRetPathUserId)
       smtp-&gt;strRetPathUserId = smtp-&gt;strSenderUserId;

   <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Reply-To:&lt;", smtp-&gt;strRetPathUserId, "&gt;\r\n", NULL);
   <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Sender:", smtp-&gt;strSenderUserId, "\r\n", NULL);
   smtp_send_data (iSocket, strOut);

   *strOut = '\0';

   /* Post any CC's. */
   if (smtp-&gt;strCcUserIds &amp;&amp; *smtp-&gt;strCcUserIds)
     {
       <A HREF="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strCcUserIds, ";", ',');
       <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Cc:", smtp-&gt;strCcUserIds, "\r\n", NULL );
     }

   /* Post any BCC's. */
   if (smtp-&gt;strBccUserIds &amp;&amp; *smtp-&gt;strBccUserIds)
     {
       <A HREF="sfldoc.htm#replacechrswith">replacechrswith</A> (smtp-&gt;strBccUserIds, ";", ',');
       <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Bcc:", smtp-&gt;strBccUserIds, "\r\n", NULL);
     }
   /* Post any Return-Receipt-To. */
   if (smtp-&gt;strRrcpUserId &amp;&amp; *smtp-&gt;strRrcpUserId)
       <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Return-Receipt-To:", smtp-&gt;strRrcpUserId, "&gt;\r\n",
                NULL);

   if (smtp-&gt;strMailerName &amp;&amp; *smtp-&gt;strMailerName)
       <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "X-Mailer: ", smtp-&gt;strMailerName, "\r\n", NULL);
   else
       strcat (strOut, "X-Mailer: sflmail function\r\n");

   /* Set the mime version. */
   strcat (strOut, "MIME-Version: 1.0\r\n");
   strcat (strOut,
   "Content-Type: Multipart/Mixed; boundary=Message-Boundary-21132\r\n");

   smtp_send_data (iSocket, strOut);

   /* Write out any message comment included. */
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (strOut, "Comments: ", smtp-&gt;strMsgComment, "\r\n", NULL);

   /* Send the subject and message body. */
   <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Subject:", smtp-&gt;strSubject, "\n\r\n", NULL);
   smtp_send_data (iSocket, strOut);

   /* Keep rfc822 in mind with all the sections. */
   if (smtp-&gt;strMessageBody &amp;&amp; *smtp-&gt;strMessageBody)
     {
       strcat (strOut, "\r\n--Message-Boundary-21132\r\n");
       strcat (strOut, "Content-Type: text/plain; charset=US-ASCII\r\n");
       strcat (strOut, "Content-Transfer-Encoding: 7BIT\r\n");
       strcat (strOut, "Content-description: Body of message\r\n\r\n");
       smtp_send_data (iSocket, strOut);
       smtp_send_data (iSocket, smtp-&gt;strMessageBody);
       smtp_send_data (iSocket, "\r\n");
     }

   /* Include any Text type files and Attach them to the message. */
   if (smtp-&gt;strTxtFiles &amp;&amp; *smtp-&gt;strTxtFiles)
     {
       iCnt = 0;
       while (1)
         {
           <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (smtp-&gt;strTxtFiles, iCnt++, 0, ",;", strFile);
           <A HREF="sfldoc.htm#trim">trim</A> (strFile);
           if (*strFile)
             {
               fpin = fopen (strFile, "rb");
               if (!fpin)
                 {
                   strcpy (smtp-&gt;strlast_smtp_message, strFile);
                   return -6;
                 }

               strcpy (strOut, "\r\n--Message-Boundary-21132\r\n");
               strcat (strOut,
                       "Content-Type: text/plain; charset=US-ASCII\r\n");
               strcat (strOut, "Content-Transfer-Encoding: 7BIT\r\n");
               <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Content-Disposition: attachment; filename=",
                        getfilename (strFile), "\r\n\n", NULL);
               smtp_send_data (iSocket, strOut);
               while (!feof (fpin))
                 {
                   memset (strRetBuff, 0, 513);
                   fread (strRetBuff, sizeof (char), 512, fpin);
                   smtp_send_data (iSocket, strRetBuff);
                 }

               fclose (fpin);
             }
           else
               break;
         }
     }

   /* Attach any bin files to the message. */
   if (smtp-&gt;strBinFiles &amp;&amp; *smtp-&gt;strBinFiles)
     {
       iCnt = 0;
       while (1)
         {
           <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (smtp-&gt;strBinFiles, iCnt++, 0, ",;", strFile);
           <A HREF="sfldoc.htm#trim">trim</A> (strFile);
           if (*strFile)
             {
               strcpy (strUUEFile, strFile);
               if (strchr (strUUEFile, '.'))
                   *((strchr (strUUEFile, '.')))= (char)NULL;
               strcat (strUUEFile, ".uue");
               uuencode (strFile, strUUEFile, smtp-&gt;strlast_smtp_message);
               fpin = fopen (strUUEFile, "rb");
               if (!fpin)
                 {
                   return -6;
                 }

               strcpy (strOut, "\r\n--Message-Boundary-21132\r\n");
               <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut,
                        "Content-Type: application/octet-stream; name=",
               getfilename (strFile), "\r\n", NULL);
               strcat (strOut, "Content-Transfer-Encoding: x-uuencode\r\n");
               <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (strOut, "Content-Disposition: attachment; filename=",
                        getfilename (strFile), "\r\n\n", NULL);
               smtp_send_data (iSocket, strOut);
               while (!feof (fpin))
                 {
                   memset (strRetBuff, 0, 513);
                   fread (strRetBuff, sizeof (char), 512, fpin);
                   smtp_send_data (iSocket, strRetBuff);
                 }

               fclose (fpin);

               if ( !smtp-&gt;debug )
                  unlink (strUUEFile);
             }
           else
               break;
         }
     }

   /* This ends the message. */
   smtp_send_data (iSocket, ".\r\n");
   if (getreply (iSocket, smtp) &gt; 400)
        return -7;

   /* Now log off the SMTP port. */
   smtp_send_data (iSocket, "QUIT\n");
   if (getreply (iSocket, smtp) &gt; 400)
        return -8;

   /*
      Clean-up.
   */
   /* Close the port up. */
   <A HREF="sfldoc.htm#close_socket">close socket</A> (iSocket);

   /* If a clean send, then reset and leave. */
   ip_nonblock = iOld_ip_nonblock;

   return 0;
}
</PRE>
<A NAME="smtp_send_mail">&nbsp;</A>
<H3><A NAME="TOC186"><TT>smtp_send_mail</TT></A></H3>
<PRE>
#include "sflmail.h"
int smtp_send_mail (
   char *strSmtpServer,
   char *strMessageBody,
   char *strSubject,
   char *strSenderUserId,
   char *strDestUserIds,
   char *strCcUserIds,
   char *strBccUserIds,
   char *strRetPathUserId,
   char *strRrcpUserId,
   char *strMsgComment,
   char *strMailerName,
   char *strBinFiles,
   char *strTxtFiles)
</PRE>
<H4>Synopsis</H4>
<P>Format and send a SMTP message, by calling the
   smtp_send_mail_ex function. This function is kept to be
   compatable with previous versions of smtp_send_mail,
   smtp_send_mail_ex should now be used, this will be deleted
   soon.
<H4>Source Code - (sflmail.c)</H4>
<PRE>
{
   SMTP smtp;

   smtp.strSmtpServer = strSmtpServer;
   smtp.strMessageBody = strMessageBody;
   smtp.strSubject = strSubject;
   smtp.strSenderUserId = strSenderUserId;
   smtp.strDestUserIds = strDestUserIds;
   smtp.strCcUserIds = strCcUserIds;
   smtp.strBccUserIds = strBccUserIds;
   smtp.strRetPathUserId = strRetPathUserId;
   smtp.strRrcpUserId = strRrcpUserId;
   smtp.strMsgComment = strMsgComment;
   smtp.strMailerName = strMailerName;
   smtp.strBinFiles = strBinFiles;
   smtp.strTxtFiles = strTxtFiles;
   smtp.connect_retry_cnt = 3;
   smtp.retry_wait_time = 0;
   smtp.debug = 0;

   return <A HREF="sfldoc.htm#smtp_send_mail_ex">smtp send mail ex</A> (&amp;smtp);
}
</PRE>
<H2><A NAME="TOC187">Mathematic functions</A></H2>
<P>Filename: sflmath.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/05/12 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides miscellaneous mathematical functions, including
   calculation of points within areas.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#point_in_rect">point in rect</A><BR>
   (const FPOINT *point, const FPOINT *coords);
</LI>
<LI>int <A HREF="sfldoc.htm#point_in_circle">point in circle</A><BR>
   (const FPOINT *point, const FPOINT *coords);
</LI>
<LI>int <A HREF="sfldoc.htm#point_in_poly">point in poly</A><BR>
   (const FPOINT *point, const FPOINT *coords, int nb_point);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmath.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLMATH_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="point_in_rect">&nbsp;</A>
<H3><A NAME="TOC188"><TT>point_in_rect</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_rect (const FPOINT *point, const FPOINT *coords)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified
   rectangle. Returns TRUE or FALSE appropriately.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    return ((point-&gt; x &gt;= coords [0].x &amp;&amp; point-&gt; x &lt;= coords [1].x)
         &amp;&amp; (point-&gt; y &gt;= coords [0].y &amp;&amp; point-&gt; y &lt;= coords [1].y));
}
</PRE>
<A NAME="point_in_circle">&nbsp;</A>
<H3><A NAME="TOC189"><TT>point_in_circle</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_circle (const FPOINT *point, const FPOINT *coords)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified circle.
   Returns TRUE or FALSE appropriately.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    double
        circle_radius,
        distance_from_centre;

    circle_radius        = ((coords [0].y - coords [1].y) *
                            (coords [0].y - coords [1].y)) +
                           ((coords [0].x - coords [1].x)  *
                            (coords [0].x - coords [1].x));

    distance_from_centre = ((coords [0].y - point-&gt; y) *
                            (coords [0].y - point-&gt; y)) +
                           ((coords [0].x - point-&gt; x) *
                            (coords [0].x - point-&gt; x));
    return (distance_from_centre &lt;= circle_radius);
}
</PRE>
<A NAME="point_in_poly">&nbsp;</A>
<H3><A NAME="TOC190"><TT>point_in_poly</TT></A></H3>
<PRE>
#include "sflmath.h"
int
point_in_poly (const FPOINT *point, const FPOINT *pgon, int nbpoints)
</PRE>
<H4>Synopsis</H4>
<P>Checks if the requested FPOINT is within the specified polygon.
   Returns TRUE or FALSE.
<H4>Source Code - (sflmath.c)</H4>
<PRE>
{
    int
        inside_flag,
        xflag0,
        crossings;
    const double
        *stop;
    double
        *p,
        tx,
        ty,
        y;

    crossings = 0;

    tx = point-&gt; x;
    ty = point-&gt; y;
    y  = pgon [nbpoints - 1].y;

    p = (double *) pgon + 1;
    if ((y &gt;= ty) != (*p &gt;= ty))
      {
        if ((xflag0 = (pgon [nbpoints - 1].x &gt;= tx)) ==
                (*(double *) pgon &gt;= tx))
          {
            if (xflag0)
               crossings++;
          }
        else
            crossings += (pgon [nbpoints - 1].x - (y - ty) *
                         (*(double *) pgon - pgon [nbpoints - 1].x) /
                         (*p - y)) &gt;= tx;
      }
     stop = &amp;pgon [nbpoints].y;
     for (y = *p, p += 2; p &lt;= stop; y = *p, p += 2)
       {
         if (y &gt;= ty)
           {
             while ((p &lt; stop) &amp;&amp; (*p &gt;= ty))
                 p += 2;
             if (p &gt;= stop)
                break;
             if ((xflag0 = (*(p - 3) &gt;= tx)) == (*(p - 1) &gt;= tx))
               {
                 if (xflag0)
                    crossings++;
               }
             else
                 crossings += (*(p - 3) - (*(p - 2) - ty) *
                              (*(p - 1) - *(p - 3)) /
                              (*p - *(p - 2))) &gt;= tx;
           }
         else
           {
             while ((p &lt; stop) &amp;&amp; (*p &lt; ty))
                p += 2;
             if (p &gt;= stop)
                break;
             if ((xflag0 = (*(p - 3) &gt;= tx)) == (*(p - 1) &gt;= tx))
               {
                 if (xflag0)
                    crossings++;
               }
             else
                 crossings += (*(p - 3) - (*(p - 2) - ty) *
                              (*(p - 1) -  *(p - 3)) /
                              (*p - *(p - 2))) &gt;= tx;
           }
       }
     inside_flag = crossings &amp; 0x01;
     return (inside_flag);
}
</PRE>
<H2><A NAME="TOC191">Message-file access functions</A></H2>
<P>Filename: sflmesg.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 92/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read and format messages from a message
   file. The intention of such a file is to provide a single
   location for all error messages: you can easier translate these
   into foreign languages, and you can control the consistency of
   an application's error messages.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#open_message_file">open message file</A><BR>
   (const char *filename);
</LI>
<LI>void <A HREF="sfldoc.htm#close_message_file">close message file</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#print_message">print message</A><BR>
   (int msgid, ...);
</LI>
<LI>char * <A HREF="sfldoc.htm#message_text">message text</A><BR>
   (int msgid);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmesg.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>ERROR_ANY</B>  </TT>
<TD ALIGN="LEFT">0000 /* Generic error message */
<TR><TD ALIGN="LEFT"><TT><B>_SFLMESG_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="open_message_file">&nbsp;</A>
<H3><A NAME="TOC192"><TT>open_message_file</TT></A></H3>
<PRE>
#include "sflmesg.h"
int
open_message_file (const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Opens the specified error message file for reading. Returns 0
   if the file exists and is readable, otherwise returns -1. Use
   this function before calling <A HREF="sfldoc.htm#print_message">print message</A>(). You can keep
   just one message file open at once; this function closes any
   previously-opened message file. This was done on purpose: it is
   common to open a message file for an entire application in the
   main function, then refer to it at other points in the code. It
   is a pain to pass file handles around the entire application,
   and global variables are generally a bad idea.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    int feedback;

    <A HREF="sfldoc.htm#close_message_file">close message file</A> ();
    msgfile = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r');

    if (msgfile)
        feedback = 0;
    else
        feedback = -1;

    return (feedback);
}
</PRE>
<A NAME="close_message_file">&nbsp;</A>
<H3><A NAME="TOC193"><TT>close_message_file</TT></A></H3>
<PRE>
#include "sflmesg.h"
void
close_message_file (void)
</PRE>
<H4>Synopsis</H4>
<P>Closes the currently open message file, if any. Does not return
   anything.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    if (msgfile)
      {
        <A HREF="sfldoc.htm#file_close">file close</A> (msgfile);
        msgfile = NULL;
      }
}
</PRE>
<A NAME="print_message">&nbsp;</A>
<H3><A NAME="TOC194"><TT>print_message</TT></A></H3>
<PRE>
#include "sflmesg.h"
void
print_message (int msgid, ...)
</PRE>
<H4>Synopsis</H4>
<P>Scans the message file for a message with the specified id.
   Each line in the message file should start with a four-digit
   id, then a space, then the message to print. The message can
   include format specifiers using '%'. Values for each format are
   passed after the msgid. Returns nothing. The message file must
   be sorted by ascending message id's. Make sure you call
   <A HREF="sfldoc.htm#open_message_file">open message file</A> () before this function. Prints the
   message on stderr.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    va_list argptr;                     /*  Argument list pointer            */

    read_msg (msgid);                   /*  Retrieve message into msgline    */
    va_start (argptr, msgid);           /*  Start variable arguments list    */
    vfprintf (stderr, msgline, argptr);
    va_end   (argptr);                  /*  End variable arguments list      */
    fprintf  (stderr, "\n");
    fflush   (stderr);
}
</PRE>
<A NAME="message_text">&nbsp;</A>
<H3><A NAME="TOC195"><TT>message_text</TT></A></H3>
<PRE>
#include "sflmesg.h"
char *
message_text (int msgid)
</PRE>
<H4>Synopsis</H4>
<P>Works like <A HREF="sfldoc.htm#print_message">print message</A>(), but returns a pointer to the
   raw message rather than printing it. The message text is stored
   in a static area that is overwritten by each call. If msgid is
   -1, retrieves the next message sequentially, ignoring any
   numbering. This is only valid after previously reading a
   message. Places "." in the message if no more are found.
<H4>Source Code - (sflmesg.c)</H4>
<PRE>
{
    read_msg (msgid);                   /*  Retrieve message into msgline    */
    return (msgline);
}
</PRE>
<H2><A NAME="TOC196">Memory allocation functions</A></H2>
<P>Filename: sflmem.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/06/08 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/08/31
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Encapsulated memory allocation functions. Based on an article
   by Jim Schimandle in DDJ August 1990. Provides 'safe' versions
   of malloc(), realloc(), free(), and strdup(). These functions
   protect the programmer from errors in calling memory
   allocation/free routines. When these calls are used, the
   allocation routines in this module add a data structure to the
   top of allocated memory blocks which tags them as legal memory
   blocks. When the free routine is called, the memory block to be
   freed is checked for legality. If the block is not legal, the
   memory list is dumped to stderr and the program is terminated.
   Some of these functions are called through macros that add the
   filename and line number of the call, for tracing. Do not call
   these functions directly.
<H4>List of Functions</H4>
<UL>
<LI>void * <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A><BR>
   (MEMTRN *trn, size_t size, const char *source_file, word
   source_line);
</LI>
<LI>void * <A HREF="sfldoc.htm#mem_realloc_">mem realloc </A><BR>
   (void *block, size_t size, const char *source_file, word
   source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_free_">mem free </A><BR>
   (void *block, const char *source_file, word source_line);
</LI>
<LI>char * <A HREF="sfldoc.htm#mem_strdup_">mem strdup </A><BR>
   (MEMTRN *trn, const char *string, const char *source_file, word
   source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_strfree_">mem strfree </A><BR>
   (char **string, const char *source_file, word source_line);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#mem_descr_">mem descr </A><BR>
   (MEMTRN *trn, const void *block, size_t size, const char
   *source_file, word source_line);
</LI>
<LI>MEMTRN * <A HREF="sfldoc.htm#mem_new_trans_">mem new trans </A><BR>
   (const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_commit_">mem commit </A><BR>
   (MEMTRN *trn, const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_rollback_">mem rollback </A><BR>
   (MEMTRN *trn, const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_checkall_">mem checkall </A><BR>
   (const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_check_">mem check </A><BR>
   (const void *block, const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_assert_">mem assert </A><BR>
   (const char *source_file, word source_line);
</LI>
<LI>size_t <A HREF="sfldoc.htm#mem_size_">mem size </A><BR>
   (const void *block, const char *source_file, word source_line);
</LI>
<LI>long <A HREF="sfldoc.htm#mem_used">mem used</A><BR>
   (void);
</LI>
<LI>long <A HREF="sfldoc.htm#mem_allocs">mem allocs</A><BR>
   (void);
</LI>
<LI>long <A HREF="sfldoc.htm#mem_frees">mem frees</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#mem_display">mem display</A><BR>
   (FILE *save_to);
</LI>
<LI>int <A HREF="sfldoc.htm#mem_scavenger">mem scavenger</A><BR>
   (scavenger scav_fct, void *scav_arg);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmem.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLMEM_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>mem_alloc(n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_assert()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_check(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_checkall()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_commit(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_descr(p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_free(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_new_trans()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_realloc(p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_rollback(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_size(p)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_strdup(s)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>mem_strfree(ps)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_alloc(t,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_descr(t,p,n)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>memt_strdup(t,s)</B>  </TT>
<TD ALIGN="LEFT">(various)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>MEMHDR</B>  </TT>
<TD ALIGN="LEFT">struct _MEMHDR
<TR><TD ALIGN="LEFT"><TT><B>MEMTRN</B>  </TT>
<TD ALIGN="LEFT">struct _MEMTRN
<TR><TD ALIGN="LEFT"><TT><B>scavenger</B>  </TT>
<TD ALIGN="LEFT">Bool (*) (void *)
</TABLE>
<A NAME="mem_alloc_">&nbsp;</A>
<H3><A NAME="TOC197"><TT>mem_alloc_</TT></A></H3>
<PRE>
#include "sflmem.h"
void *
mem_alloc_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    size_t      size,                   /*  Desired size of memory block     */
    const char *filename,               /*  Name of source file making call  */
    word        lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a memory block. Use the mem_alloc() macro to call
   this function! Use <A HREF="sfldoc.htm#mem_free_">mem free </A>() to free blocks allocated
   with this function. Returns a pointer to the allocated memory
   block, or NULL if there was not enough memory available. The
   supplied source file name is assumed to be in a static area.
   The requested block size must be greater than zero bytes.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;                            /*  Allocated memory block           */

    /*  Allocate block with extra space for the header                       */
    ASSERT (size &gt; 0);                  /*  Cannot allocate zero bytes!      */

    ptr = malloc (RESERVE_SIZE + size);
    if (ptr == NULL)                    /*  If nothing free, do a hunt       */
      {                                 /*    and try again...               */
        mem_scavenge ();
        ptr = malloc (RESERVE_SIZE + size);
        if (ptr == NULL)
            return (NULL);              /*  Really in trouble now!           */
      }
#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): alloc %d bytes-&gt;%p", filename, lineno, size, ptr);
#   endif

    ptr-&gt; tag  = MEMTAG;                /*  Initialise block header          */
    ptr-&gt; size = size;                  /*  Size of block                    */
    ptr-&gt; file = filename;              /*  Who allocated it                 */
    ptr-&gt; line = lineno;                /*    and where                      */

    if (!trn)                           /*  If no transaction then use the   */
        trn = &amp;mem_list;                /*  main block list                  */

    list_reset (ptr);                   /*  Set up new block as list         */
    list_relink_before (ptr,            /*  Add to list of blocks            */
                        &amp;trn-&gt; memhdr);

    mem_total += size;                  /*  Keep count of space used         */
    mem_alloc_count += 1;               /*    and number of allocations      */

    return (HDR_2_CLIENT (ptr));        /*   and return client address       */
}
</PRE>
<A NAME="mem_realloc_">&nbsp;</A>
<H3><A NAME="TOC198"><TT>mem_realloc_</TT></A></H3>
<PRE>
#include "sflmem.h"
void *
mem_realloc_ (
    void       *client_ptr,             /*  Block of memory to reallocate    */
    size_t      size,                   /*  Desired size of memory block     */
    const char *filename,               /*  Name of source file making call  */
    word        lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Reallocates a memory block, which remains part of the same
   transaction. Use the mem_realloc() macro to call this function!
   Accepts a pointer to a memory block and the desired size of the
   new memory block. Returns the address of the new memory block,
   or NULL if there was not enough memory available. If the
   specified block was not correctly allocated, dumps the memory
   allocation list and exits. The desired size must be greater
   than zero.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
        *ptr,
        *next;

    ASSERT (client_ptr);
    ASSERT (size &gt; 0);

    /*  Check that block is valid                                            */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

    /*  Invalidate header                                                    */
    ptr-&gt; tag = (word) ~MEMTAG;

    mem_total -= ptr-&gt; size;
    mem_free_count += 1;


    next = ptr-&gt; next;                  /*  Save where we were linked        */
    <A HREF="sfldoc.htm#list_unlink">list unlink</A> (ptr);                  /*     and unlink                    */

    /*  Reallocate memory block                                              */
    ptr = (MEMHDR *) realloc (ptr, RESERVE_SIZE + size);
    if (ptr == NULL)                    /*  If nothing free, do a hunt       */
      {                                 /*    and try again...               */
        mem_scavenge ();
        ptr = (MEMHDR *) realloc (ptr, RESERVE_SIZE + size);
        if (ptr == NULL)
            return (NULL);              /*  Really in trouble now!           */
      }

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): realloc %d bytes -&gt;%p", filename, lineno, size, ptr);
#   endif

    /*  Update header                                                        */
    ptr-&gt; tag  = MEMTAG;
    ptr-&gt; size = size;
    ptr-&gt; file = filename;
    ptr-&gt; line = lineno;

    list_reset (ptr);                   /*  Set up block as list             */
    list_relink_before (ptr, next);     /*  And link where old block was     */

    mem_total += size;                  /*  Keep count of space used         */
    mem_alloc_count += 1;               /*    and number of allocations      */

    return (HDR_2_CLIENT (ptr));
}
</PRE>
<A NAME="mem_strdup_">&nbsp;</A>
<H3><A NAME="TOC199"><TT>mem_strdup_</TT></A></H3>
<PRE>
#include "sflmem.h"
char *
mem_strdup_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    const char *string,                 /*  String to copy                   */
    const char *filename,               /*  Name of source file making call  */
    word        lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Saves a string in dynamic memory. Use the mem_strdup() macro to
   call this function! The caller is responsible for freeing the
   space allocated when it is no longer needed. Returns a pointer
   to the allocated string, which holds a copy of the parameter
   string. Returns NULL if there was insufficient heap storage
   available to allocate the string, or if the original string was
   itself NULL.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    char *copy;

    if (string)                         /*  If string not null, copy it      */
      {
        copy = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (trn, strlen (string) + 1, filename, lineno);
        if (copy)
            strcpy (copy, string);
      }
    else
        copy = NULL;                    /*  Just pass-through a NULL         */

    return (copy);
}
</PRE>
<A NAME="mem_strfree_">&nbsp;</A>
<H3><A NAME="TOC200"><TT>mem_strfree_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_strfree_ (
    char **string,                      /*  Address of string to free        */
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Releases memory occupied by a string. Use the mem_strfree()
   macro to call this function! Call this function to free strings
   allocated using <A HREF="sfldoc.htm#mem_strdup_">mem strdup </A>(). Accepts the address of a
   char pointer as argument: if the pointer is not null, the
   string is freed, and the pointer is set to null. Returns the
   address of the modified pointer.
<H4>Examples</H4>
<PRE>
    char
        *string1 = NULL,
        *string2 = NULL;
    string1 = mem_strdup ("This is a string");
    mem_strfree (&string1);
    mem_strfree (&string2);
</PRE>
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    ASSERT (string);
    if (*string)
      {
        <A HREF="sfldoc.htm#mem_free_">mem free </A> (*string, filename, lineno);
        *string = NULL;
      }
}
</PRE>
<A NAME="mem_free_">&nbsp;</A>
<H3><A NAME="TOC201"><TT>mem_free_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_free_ (
    void *client_ptr,                   /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Releases memory previously allocated by <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A>(),
   <A HREF="sfldoc.htm#mem_realloc_">mem realloc </A>(), or <A HREF="sfldoc.htm#mem_strdup_">mem strdup </A>(). Use the mem_free()
   macro to call this function! If the specified block was not
   correctly allocated, dumps the memory allocation list and
   exits. If you specify a null address, does nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): free=%p", filename, lineno, ptr);
#   endif

    /*  Invalidate header                                                    */
    ptr-&gt; tag = (word) ~MEMTAG;
    mem_total -= ptr-&gt; size;
    mem_free_count += 1;
    <A HREF="sfldoc.htm#list_unlink">list unlink</A> (ptr);                  /*  Remove block from list           */

    free (ptr);
}
</PRE>
<A NAME="mem_assert_">&nbsp;</A>
<H3><A NAME="TOC202"><TT>mem_assert_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_assert_ (
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks that all allocated memory was freed. Use the mem_assert
   macro to call this function! If any memory is still left
   allocated, displays the memory list on stderr and aborts.
   Generally we use this function at the end of a program, after
   deallocating all memory. If any memory has not been allocated,
   we get a nice list and an abort. Our principle is that any
   memory allocation must be matched by a free somewhere in the
   code.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    FILE
        *trace_file;

    if (mem_total != 0
    ||  !list_empty (&amp;tr_list))
      {
        fflush  (stdout);
        fprintf (stderr, "Clean-memory assertion failed - %s (%d)\n",
                          filename? filename: "&lt;Unknown&gt;", lineno);
        fprintf (stderr, "Details are in memtrace.lst\n");
        trace_file = fopen ("memtrace.lst", "w");
        <A HREF="sfldoc.htm#mem_display">mem display</A> (trace_file);
        fclose (trace_file);
        abort ();
      }
}
</PRE>
<A NAME="mem_checkall_">&nbsp;</A>
<H3><A NAME="TOC203"><TT>mem_checkall_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_checkall_ (
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks all allocated memory blocks; if any block was corrupted,
   aborts with an error message, else does nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
        *trn;

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): check all memory", filename, lineno);
#   endif

    mem_check_list ((MEMHDR *) &amp;mem_list.memhdr, filename, lineno);
    trn = tr_list.next;
    while (trn != (MEMTRN *) &amp;tr_list)
      {
        mem_check_list ((MEMHDR *) &amp;trn-&gt; memhdr, filename, lineno);
        trn = trn-&gt; next;
      }
}
</PRE>
<A NAME="mem_check_">&nbsp;</A>
<H3><A NAME="TOC204"><TT>mem_check_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_check_ (
    const void *client_ptr,             /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks that a block of memory has not been corrupted. If the
   block is corrupted, aborts with an error message, else does
   nothing.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);
}
</PRE>
<A NAME="mem_descr_">&nbsp;</A>
<H3><A NAME="TOC205"><TT>mem_descr_</TT></A></H3>
<PRE>
#include "sflmem.h"
DESCR *
mem_descr_ (
    MEMTRN     *trn,                    /*  Associated transaction           */
    const void *data_block,             /*  Block of memory to copy          */
    size_t      data_size,              /*  Size of memory block             */
    const char *filename,               /*  Name of source file making call  */
    word        lineno                  /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a DESCR block for a specified block of data. Use the
   mem_descr macro to call this function! Returns a pointer to an
   allocated DESCR block, or NULL if there was not enough memory.
   The DESCR block is allocated as a single block, consisting of
   the DESCR block plus the data. To free the entire block you
   need one call to mem_free(). If the data_block argument is not
   null, its contents are copied into the newly allocated memory.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    DESCR
        *descr;

    descr = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (trn, data_size + sizeof (DESCR), filename, lineno);
    if (descr == NULL)
        return (NULL);

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): allocate descr=%p", filename, lineno, descr);
#   endif

    /*  Fill-in descriptor block unless it is NULL                           */
    descr-&gt; size = data_size;
    descr-&gt; data = (byte *) descr + sizeof (DESCR);
    if (data_block)
        memcpy (descr-&gt; data, data_block, data_size);

    return (descr);
}
</PRE>
<A NAME="mem_new_trans_">&nbsp;</A>
<H3><A NAME="TOC206"><TT>mem_new_trans_</TT></A></H3>
<PRE>
#include "sflmem.h"
MEMTRN *
mem_new_trans_(
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Allocates a transaction block. Use the <A HREF="sfldoc.htm#mem_new_trans">mem new trans</A>()
   macro to call this function. Use mem_commit or
   <A HREF="sfldoc.htm#mem_rollback">mem rollback</A>() to delete the transaction. Returns a pointer
   to the allocated transaction block, or NULL if there was not
   enough memory available. The supplied source file name is
   assumed to be in a static area.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
       *trn;                            /*  Allocated transaction block      */

    /*  Allocate block                                                       */
    trn = malloc (MEMTRN_SIZE);
    if (trn == NULL)
        return (NULL);

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): new transaction", filename, lineno);
#   endif

    trn-&gt; file = (char *) filename;     /*  Who allocated it                 */
    trn-&gt; line = lineno;                /*    and where                      */
    list_reset (&amp;trn-&gt; memhdr);         /*  No memory blocks yet             */

    list_reset (trn);                   /*  Only 1 item in list              */
    list_relink_before (trn, &amp;tr_list);  /*  Add to list of transactions      */
    return (trn);                       /*   and return address              */
}
</PRE>
<A NAME="mem_commit_">&nbsp;</A>
<H3><A NAME="TOC207"><TT>mem_commit_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_commit_ (
    MEMTRN *trn,
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Commits all blocks allocated to a transaction.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    LIST
       *ptr;

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): commit transaction", filename, lineno);
#   endif

    ptr = &amp;trn-&gt; memhdr;
    if (!list_empty (ptr))              /*  Are there any blocks to commit?  */
      {
        list_relink_before (ptr,        /*  Relink list into main list       */
                            &amp;mem_list. memhdr);
        <A HREF="sfldoc.htm#list_unlink">list unlink</A> (ptr);
      }

    mem_del_trans (trn);
}
</PRE>
<A NAME="mem_rollback_">&nbsp;</A>
<H3><A NAME="TOC208"><TT>mem_rollback_</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_rollback_ (
    MEMTRN *trn,
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Rolls back allocations for a particular transaction. This frees
   up all blocks allocated by calls to mem_alloc, mem_realloc and
   mem_strdup since the last call to mem_commit. Note that for
   blocks allocated with mem_realloc, this is not really a
   rollback but a free. The <A HREF="sfldoc.htm#mem_rollback">mem rollback</A>() function must be
   used with some care... if you forget to do a <A HREF="sfldoc.htm#mem_commit">mem commit</A>(),
   a later <A HREF="sfldoc.htm#mem_rollback">mem rollback</A>() will do damage to your memory space.
   The general rule is to start your processing with
   <A HREF="sfldoc.htm#mem_commit">mem commit</A>(), then do work, and call <A HREF="sfldoc.htm#mem_rollback">mem rollback</A>()
   when there is an error. Finally, call <A HREF="sfldoc.htm#mem_commit">mem commit</A>() at the
   end, just to be sure.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr = NULL;

#   if (defined (MEM_TRACE))
    if (filename)
        <A HREF="sfldoc.htm#trace">trace</A> ("%s (%d): rollback transaction", filename, lineno);
#   endif

    while (!list_empty (&amp;trn-&gt; memhdr))
      {
        ptr = trn-&gt; memhdr. next;

        ptr-&gt; tag = (word) ~MEMTAG;
        mem_total -= ptr-&gt; size;
        mem_free_count += 1;
        <A HREF="sfldoc.htm#list_unlink">list unlink</A> (ptr);              /*  Remove block from list           */

        free (ptr);
      }
    mem_del_trans (trn);
}
</PRE>
<A NAME="mem_size_">&nbsp;</A>
<H3><A NAME="TOC209"><TT>mem_size_</TT></A></H3>
<PRE>
#include "sflmem.h"
size_t
mem_size_ (
    const void *client_ptr,             /*  Block of memory to free          */
    const char *filename,               /*  Name of source file making call  */
    word lineno                         /*  Line number in calling source    */
)
</PRE>
<H4>Synopsis</H4>
<P>Returns the size in bytes of a memory block.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMHDR
       *ptr;

    if (client_ptr == NULL)             /*  Do nothing if address is null    */
        return 0;

    /*  Check for valid block                                                */
    ptr = CLIENT_2_HDR (client_ptr);
    if (ptr-&gt; tag != MEMTAG)
        mem_tag_err (ptr, filename, lineno);

    return ptr-&gt; size;
}
</PRE>
<A NAME="mem_used">&nbsp;</A>
<H3><A NAME="TOC210"><TT>mem_used</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_used (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of bytes currently allocated using the
   memory management system. The value returned is simply the sum
   of the size requests to allocation routines. It does not
   reflect any overhead required by the memory management system.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_total);
}
</PRE>
<A NAME="mem_allocs">&nbsp;</A>
<H3><A NAME="TOC211"><TT>mem_allocs</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_allocs (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of blocks allocated in total. Use this to
   get an idea of the activity of the memory management system.
   When program ends cleanly, <A HREF="sfldoc.htm#mem_allocs">mem allocs</A> () should be equal to
   <A HREF="sfldoc.htm#mem_frees">mem frees</A>().
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_alloc_count);
}
</PRE>
<A NAME="mem_frees">&nbsp;</A>
<H3><A NAME="TOC212"><TT>mem_frees</TT></A></H3>
<PRE>
#include "sflmem.h"
long
mem_frees (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the number of blocks freed in total. Use this to get an
   idea of the activity of the memory management system. When
   program ends cleanly, <A HREF="sfldoc.htm#mem_allocs">mem allocs</A> () should be equal to
   <A HREF="sfldoc.htm#mem_frees">mem frees</A>().
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    return (mem_free_count);
}
</PRE>
<A NAME="mem_display">&nbsp;</A>
<H3><A NAME="TOC213"><TT>mem_display</TT></A></H3>
<PRE>
#include "sflmem.h"
void
mem_display (
    FILE *fp                            /*  File to dump display to          */
)
</PRE>
<H4>Synopsis</H4>
<P>Displays the contents of the memory allocation list.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    MEMTRN
        *trn;

    fprintf (fp, "Index   Size  File(Line) - total size %lu\n", mem_total);
    mem_display_list ((MEMHDR *) &amp;mem_list.memhdr, fp);

    trn = tr_list.next;
    while (trn != (MEMTRN *) &amp;tr_list)
      {
        fprintf (fp, "* Transaction %s (%d)",
                 trn-&gt; file? trn-&gt; file: "&lt;Unknown&gt;", trn-&gt; line);
        fprintf (fp, "\n");
        mem_display_list ((MEMHDR *) &amp;trn-&gt; memhdr, fp);

        trn = trn-&gt; next;
      }
    fflush (fp);
}
</PRE>
<A NAME="mem_scavenger">&nbsp;</A>
<H3><A NAME="TOC214"><TT>mem_scavenger</TT></A></H3>
<PRE>
#include "sflmem.h"
int
mem_scavenger (
    scavenger scav_fct,                 /*  File to dump display to          */
    void    * scav_arg
)
</PRE>
<H4>Synopsis</H4>
<P>Registers a memory scavenger function. A memory scavenger
   function is an application function that is invoked by
   <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A>() when memory is exhausted, so that unused
   application objects can be released. This allows you to
   allocate large amounts of memory -- for instance for caches --
   and then release them when memory runs short. When you register
   a scavenger function you may provide a void * argument; this is
   passed back to the scavenger if it is ever invoked. The
   scavenger function returns TRUE if it could release some
   memory, otherwise it returns FALSE. Note that there is no way
   to unregister such a function. Furthermore, a scavenger
   function should not itself allocate any new memory, unless it
   can definitely free excess memory first. Scavenger functions
   are called in an unspecified order. Returns 0 if the scavenger
   function could be registered, -1 if not. There is no limit to
   the number of scavenger functions you can register, except
   available memory. The same scavenger function can be registered
   several times.
<H4>Source Code - (sflmem.c)</H4>
<PRE>
{
    SCAVFCT
        *scavfct;                       /*  Allocated registry function      */

    /*  Allocate an SCAVFCT block and attach it to the scavfcts list         */
    list_create (scavfct, sizeof (SCAVFCT));
    if (scavfct == NULL)
        return (-1);
    list_relink_before (scavfct, &amp;scavfcts);

    scavfct-&gt; scav_fct = scav_fct;
    scavfct-&gt; scav_arg = scav_arg;
    return (0);
}
</PRE>
<H2><A NAME="TOC215">MIME support functions</A></H2>
<P>Filename: sflmime.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/03/28 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides various functions that support MIME encoding and
   decoding. See RFC 1521 for details.
<H3>Notes</H3>
<PRE>
    Extract from RFC1521 for Base64 Content-Transfer-Encoding
    ---------------------------------------------------------

    The Base64 Content-Transfer-Encoding is designed to represent
    arbitrary sequences of octets in a form that need not be humanly
    readable.  The encoding and decoding algorithms are simple, but the
    encoded data are consistently only about 33 percent larger than the
    unencoded data.  This encoding is virtually identical to the one used
    in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
    The base64 encoding is adapted from RFC 1421, with one change: base64
    eliminates the "*" mechanism for embedded clear text.

    A 65-character subset of US-ASCII is used, enabling 6 bits to be
    represented per printable character. (The extra 65th character, "=",
    is used to signify a special processing function.)

    \NOTE: This subset has the important property that it is
    represented identically in all versions of ISO 646, including US
    ASCII, and all characters in the subset are also represented
    identically in all versions of EBCDIC.  Other popular encodings,
    such as the encoding used by the uuencode utility and the base85
    encoding specified as part of Level 2 PostScript, do not share
    these properties, and thus do not fulfill the portability
    requirements a binary transport encoding for mail must meet.

    The encoding process represents 24-bit groups of input bits as output
    strings of 4 encoded characters. Proceeding from left to right, a
    24-bit input group is formed by concatenating 3 8-bit input groups.
    These 24 bits are then treated as 4 concatenated 6-bit groups, each
    of which is translated into a single digit in the base64 alphabet.
    When encoding a bit stream via the base64 encoding, the bit stream
    must be presumed to be ordered with the most-significant-bit first.

    That is, the first bit in the stream will be the high-order bit in
    the first byte, and the eighth bit will be the low-order bit in the
    first byte, and so on.

    Each 6-bit group is used as an index into an array of 64 printable
    characters. The character referenced by the index is placed in the
    output string. These characters, identified in Table 1, below, are
    selected so as to be universally representable, and the set excludes
    characters with particular significance to SMTP (e.g., ".", CR, LF)
    and to the encapsulation boundaries defined in this document (e.g.,
    "-").

                      Table 1: The Base64 Alphabet

      Value Encoding  Value Encoding  Value Encoding  Value Encoding
           0 A            17 R            34 i            51 z
           1 B            18 S            35 j            52 0
           2 C            19 T            36 k            53 1
           3 D            20 U            37 l            54 2
           4 E            21 V            38 m            55 3
           5 F            22 W            39 n            56 4
           6 G            23 X            40 o            57 5
           7 H            24 Y            41 p            58 6
           8 I            25 Z            42 q            59 7
           9 J            26 a            43 r            60 8
          10 K            27 b            44 s            61 9
          11 L            28 c            45 t            62 +
          12 M            29 d            46 u            63 /
          13 N            30 e            47 v
          14 O            31 f            48 w         (pad) =
          15 P            32 g            49 x
          16 Q            33 h            50 y

    The output stream (encoded bytes) must be represented in lines of no
    more than 76 characters each.  All line breaks or other characters
    not found in Table 1 must be ignored by decoding software.  In base64
    data, characters other than those in Table 1, line breaks, and other
    white space probably indicate a transmission error, about which a
    warning message or even a message rejection might be appropriate
    under some circumstances.

    Special processing is performed if fewer than 24 bits are available
    at the end of the data being encoded.  A full encoding quantum is
    always completed at the end of a body.  When fewer than 24 input bits
    are available in an input group, zero bits are added (on the right)
    to form an integral number of 6-bit groups.  Padding at the end of
    the data is performed using the '=' character.  Since all base64
    input is an integral number of octets, only the following cases can
    \arise: (1) the final quantum of encoding input is an integral
    multiple of 24 bits; here, the final unit of encoded output will be
    an integral multiple of 4 characters with no "=" padding, (2) the
    final quantum of encoding input is exactly 8 bits; here, the final
    unit of encoded output will be two characters followed by two "="
    padding characters, or (3) the final quantum of encoding input is
    exactly 16 bits; here, the final unit of encoded output will be three
    characters followed by one "=" padding character.

    Because it is used only for padding at the end of the data, the
    occurrence of any '=' characters may be taken as evidence that the
    end of the data has been reached (without truncation in transit).  No
    such assurance is possible, however, when the number of octets
    transmitted was a multiple of three.

    Any characters outside of the base64 alphabet are to be ignored in
    base64-encoded data.  The same applies to any illegal sequence of
    characters in the base64 encoding, such as "====="

    Care must be taken to use the proper octets for line breaks if base64
    encoding is applied directly to text material that has not been
    converted to canonical form.  In particular, text line breaks must be
    converted into CRLF sequences prior to base64 encoding. The important
    thing to note is that this may be done directly by the encoder rather
    than in a prior canonicalization step in some implementations.

    \NOTE: There is no need to worry about quoting apparent
    encapsulation boundaries within base64-encoded parts of multipart
    entities because no hyphen characters are used in the base64
    encoding.
</PRE>
<H4>List of Functions</H4>
<UL>
<LI>size_t <A HREF="sfldoc.htm#encode_base64">encode base64</A><BR>
   (const char *source, byte *target, size_t source_size);
</LI>
<LI>size_t <A HREF="sfldoc.htm#decode_base64">decode base64</A><BR>
   (const byte *source, char *target, size_t source_size);
</LI>
<LI>Bool <A HREF="sfldoc.htm#decode_mime_time">decode mime time</A><BR>
   (const char *mime_date, long *date, long *time);
</LI>
<LI>char * <A HREF="sfldoc.htm#encode_mime_time">encode mime time</A><BR>
   (long date, long time);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflmime.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLMIME_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="encode_base64">&nbsp;</A>
<H3><A NAME="TOC216"><TT>encode_base64</TT></A></H3>
<PRE>
#include "sflmime.h"
size_t
encode_base64 (const char *source, byte *target, size_t source_size)
</PRE>
<H4>Synopsis</H4>
<P>Encodes a source buffer in Base 64 and stores the result in the
   target buffer. The target buffer must be at least 1/3rd longer
   than the amount of data in the source buffer. The base64 data
   consists of portable printable characters as defined in RFC
   1521. Returns the number of bytes output into the target
   buffer.
<H4>Source Code - (sflmime.c)</H4>
<PRE>
{
    size_t
        target_size = 0;                /*  Length of target buffer          */
    int
        nb_block;                       /*  Total number of blocks           */
    const char
        *p_source;                      /*  Pointer to source buffer         */
    byte
        *p_target,                      /*  Pointer to target buffer         */
        value;                          /*  Value of Base64 byte             */

    ASSERT (source);
    ASSERT (target);

    if (source_size == 0)
        return (0);

    if (!tables_initialised)
        init_conversion_tables ();

    /*    Bit positions
                  | byte 1 | byte 2 | byte 3 |
    source block   87654321 87654321 87654321         -&gt; 3 bytes of 8 bits

                  | byte 1 | byte 2 | byte 3 | byte 4 |
    Encoded block  876543   218765   432187   654321  -&gt; 4 bytes of 6 bits
    */

    nb_block = (int) (source_size / 3);

    /*  Check if we have a partially-filled block                            */
    if (nb_block * 3 != (int) source_size)
        nb_block++;
    target_size = (size_t) nb_block * 4;
    target [target_size] = '\0';

    p_source = source;                  /*  Point to start of buffers        */
    p_target = target;

    while (nb_block--)
      {
        /*  Byte 1                                                           */
        value       = *p_source &gt;&gt; 2;
        *p_target++ = base64_to_char [value];

        /*  Byte 2                                                           */
        value = (*p_source++ &amp; 0x03) &lt;&lt; 4;
        if ((size_t) (p_source - source) &lt; source_size)
            value |= (*p_source &amp; 0xF0) &gt;&gt; 4;
        *p_target++ = base64_to_char [value];

        /*  Byte 3 - pad the buffer with '=' if block not completed          */
        if ((size_t) (p_source - source) &lt; source_size)
          {
            value = (*p_source++ &amp; 0x0F) &lt;&lt; 2;
            if ((size_t) (p_source - source) &lt; source_size)
                value |= (*p_source &amp; 0xC0) &gt;&gt; 6;
            *p_target++ = base64_to_char [value];
          }
        else
            *p_target++ = '=';

        /*  Byte 4 - pad the buffer with '=' if block not completed          */
        if ((size_t) (p_source - source) &lt; source_size)
          {
            value       = *p_source++ &amp; 0x3F;
            *p_target++ = base64_to_char [value];
          }
        else
            *p_target++ = '=';
     }
   return (target_size);
}
</PRE>
<A NAME="decode_base64">&nbsp;</A>
<H3><A NAME="TOC217"><TT>decode_base64</TT></A></H3>
<PRE>
#include "sflmime.h"
size_t
decode_base64 (const byte *source, char *target, size_t source_size)
</PRE>
<H4>Synopsis</H4>
<P>Decodes a block of Base 64 data and stores the resulting binary
   data in a target buffer. The target buffer must be at least 3/4
   the size of the base 64 data. Returns the number of characters
   output into the target buffer.
<H4>Source Code - (sflmime.c)</H4>
<PRE>
{
    size_t
        target_size = 0;                /*  Length of target buffer          */
    int
        nb_block;                       /*  Total number of block            */
    const byte
        *p_source;                      /*  Pointer in source buffer         */
    byte
        value;                          /*  Value of Base64 byte             */
    char
        *p_target;                      /*  Pointer in target buffer         */

    ASSERT (source);
    ASSERT (target);

    if (source_size == 0)
        return (0);

    if (!tables_initialised)
        init_conversion_tables ();

    /*  Bit positions
                  | byte 1 | byte 2 | byte 3 | byte 4 |
    Encoded block  654321   654321   654321   654321  -&gt; 4 bytes of 6 bits
                  | byte 1 | byte 2 | byte 3 |
    Decoded block  65432165 43216543 21654321         -&gt; 3 bytes of 8 bits
    */

    nb_block    = source_size / 4;
    target_size = (size_t) nb_block * 3;
    target [target_size] = '\0';

    p_source = source;                  /*  Point to start of buffers        */
    p_target = target;

    while (nb_block--)
      {
        /*  Byte 1                                                           */
        *p_target    = char_to_base64 [(byte) *p_source++] &lt;&lt; 2;
        value        = char_to_base64 [(byte) *p_source++];
        *p_target++ += ((value &amp; 0x30) &gt;&gt; 4);

        /*  Byte 2                                                           */
        *p_target    = ((value &amp; 0x0F) &lt;&lt; 4);
        value        = char_to_base64 [(byte) *p_source++];
        *p_target++ += ((value &amp; 0x3C) &gt;&gt; 2);

        /*  Byte 3                                                           */
        *p_target    = (value &amp; 0x03) &lt;&lt; 6;
        value        = char_to_base64 [(byte) *p_source++];
        *p_target++ += value;
      }
   return (target_size);
}
</PRE>
<A NAME="decode_mime_time">&nbsp;</A>
<H3><A NAME="TOC218"><TT>decode_mime_time</TT></A></H3>
<PRE>
#include "sflmime.h"
Bool
decode_mime_time (const char *mime_string, long *date, long *time)
</PRE>
<H4>Synopsis</H4>
<P>Takes a MIME date and time string in various formats and
   converts to a date and time (both long values). Returns TRUE if
   it could convert the date and time okay, else returns FALSE.
   Accepts these formats: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>Mon Jan 12 12:05:01 1995</B>  <TD
   ALIGN="LEFT">ctime format <TR><TD ALIGN="LEFT"><B>Monday, 12-
   Jan-95 12:05:01 GMT</B>  <TD ALIGN="LEFT">RFC 850 <TR><TD
   ALIGN="LEFT"><B>Mon, 12 Jan 1995 12:05:01 GMT</B>  <TD
   ALIGN="LEFT">RFC 1123 </TABLE> The returned date and time are
   in local time, not GMT.
<H4>Source Code - (sflmime.c)</H4>
<PRE>
{
    int
        cent  = 0,
        year  = 0,
        month = 0,
        day   = 0,
        hour  = 0,
        min   = 0,
        sec   = 0;
    static char
        month_name [20],
        buffer     [50],
        *p_char;

    ASSERT (mime_string);
    ASSERT (date);
    ASSERT (time);

    /*  Whatever format we're looking at, it will start with weekday.        */
    /*  Skip to first space.                                                 */
    if (!(p_char = strchr (mime_string, ' ')))
        return FALSE;
    else
        while (isspace (*p_char))
            ++p_char;

    if (isalpha (*p_char))
      {
        /*  ctime                                                            */
        sscanf (p_char, "%s %d %d:%d:%d %d",
                month_name, &amp;day, &amp;hour, &amp;min, &amp;sec, &amp;year);
        cent = (int) year / 100;
        year -= cent * 100;
      }
    else
    if (p_char [2] == '-')
      {
        /*  RFC 850                                                          */
        sscanf (p_char, "%s %d:%d:%d",
                buffer, &amp;hour, &amp;min, &amp;sec);
        buffer [2] = '\0';
        day        = atoi (buffer);
        buffer [6] = '\0';
        strcpy (month_name, &amp;buffer [3]);
        year = atoi (&amp;buffer [7]);
        /*  Prevent wraparound from ambiguity                                */
        if (year &lt; 70)
            cent = 20;
        else
            cent = 19;
      }
    else
      {
        /*  RFC 1123                                                         */
        sscanf (p_char, "%d %s %d %d:%d:%d",
                &amp;day, month_name, &amp;year, &amp;hour, &amp;min, &amp;sec);
        cent = (int) year / 100;
        year -= cent * 100;
      }
    month = find_month (month_name);
    *date = MAKE_DATE (cent, year, month, day);
    *time = MAKE_TIME (hour, min,  sec,   0  );

    <A HREF="sfldoc.htm#gmt_to_local">gmt to local</A> (*date, *time, date, time);
    return (TRUE);
}
</PRE>
<A NAME="encode_mime_time">&nbsp;</A>
<H3><A NAME="TOC219"><TT>encode_mime_time</TT></A></H3>
<PRE>
#include "sflmime.h"
char *
encode_mime_time (long date, long time)
</PRE>
<H4>Synopsis</H4>
<P>Encode date and time (in long format) in Mime RFC1123 date
   format, e.g. Mon, 12 Jan 1995 12:05:01 GMT. The supplied date
   and time are in local time. Returns the date/time string if the
   date was legal, else returns "?".
<H4>Source Code - (sflmime.c)</H4>
<PRE>
{
    int
        day_week,                       /*  Day of week number (0 is sunday) */
        month;                          /*  Month number                     */
    static char
        buffer [LINE_MAX];

    <A HREF="sfldoc.htm#local_to_gmt">local to gmt</A> (date, time, &amp;date, &amp;time);
    day_week = <A HREF="sfldoc.htm#day_of_week">day of week</A> (date);
    month    = GET_MONTH   (date);
    if (day_week &gt;= 0 &amp;&amp; day_week &lt; 7 &amp;&amp; month &gt; 0 &amp;&amp; month &lt; 13)
      {
        sprintf (buffer, "%s, %02d %s %04d %02d:%02d:%02d GMT",
                         days       [day_week],
                         GET_DAY    (date),
                         months     [month - 1],
                         GET_CCYEAR (date),
                         GET_HOUR   (time),
                         GET_MINUTE (time),
                         GET_SECOND (time)
                 );
        return (buffer);
      }
    else
        return ("?");
}
</PRE>
<H2><A NAME="TOC220">Linked-list functions</A></H2>
<P>Filename: sflnode.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/06/03 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to maintain doubly-linked lists. You can use
   these functions to work with lists of any structure. To make
   this work, all structures must start with two pointers, "void
   *next, *prev;". When you want to attach a linked-list to
   another structure, declare the list head as a NODE. You can
   then refer to this variable when you attach items to the list
   head. The code sets the global node_unsafe to TRUE whenever it
   is changing a list. NOTE: DEPRECATED IN FAVOUR OF SFLLIST.C.
<H4>List of Functions</H4>
<UL>
<LI>void * <A HREF="sfldoc.htm#node_create">node create</A><BR>
   (void *after, size_t size);
</LI>
<LI>void <A HREF="sfldoc.htm#node_destroy">node destroy</A><BR>
   (void *node);
</LI>
<LI>void * <A HREF="sfldoc.htm#node_unlink">node unlink</A><BR>
   (void *node);
</LI>
<LI>void * <A HREF="sfldoc.htm#node_relink">node relink</A><BR>
   (void *left, void *node, void *right);
</LI>
<LI>void * <A HREF="sfldoc.htm#node_relink_after">node relink after</A><BR>
   (void *node, void *after);
</LI>
<LI>void * <A HREF="sfldoc.htm#node_relink_before">node relink before</A><BR>
   (void *node, void *before);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflnode.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLNODE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>node_reset(node)</B>  </TT>
<TD ALIGN="LEFT">(node)-&gt; prev = (node)-&gt; next = (node)
</TABLE>
<A NAME="node_create">&nbsp;</A>
<H3><A NAME="TOC221"><TT>node_create</TT></A></H3>
<PRE>
#include "sflnode.h"
void *
node_create (
    void *after,
    size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new node with the specified size, and attaches it to
   the linked list after the specified node. Initialises all
   fields in the node (except the main list pointers) to binary
   zeroes. If the 'after' argument is null, initialises but does
   not attach the node. Returns a pointer to the newly-created
   node, or NULL if there was not enough memory.
<H4>Examples</H4>
<PRE>
    typedef struct {
        void *prev, *next;
        long data;
    } BLOCK;

    NODE head;
    BLOCK *pointer;

    //  Initialise head of list
    node_reset (&head);

    //  Attach new block to start of list
    pointer = (BLOCK *) node_create (&head, sizeof (BLOCK));
    pointer-&gt; data = 1;

    //  Attach new block to end of list
    pointer = (BLOCK *) node_create (head.prev, sizeof (BLOCK));
    pointer-&gt; data = 1000;
</PRE>
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    NODE
        *node;                          /*  Allocated node                   */

    ASSERT (size &gt; 0);

    if ((node = mem_alloc (size)) != NULL)
      {
        memset (node, 0, size);
        node_reset (node);              /*  Initialise node pointers         */
        if (after)                      /*  Link into list if required       */
            <A HREF="sfldoc.htm#node_relink_after">node relink after</A> (node, after);
      }
    return (node);
}
</PRE>
<A NAME="node_destroy">&nbsp;</A>
<H3><A NAME="TOC222"><TT>node_destroy</TT></A></H3>
<PRE>
#include "sflnode.h"
void
node_destroy (
    void *node)
</PRE>
<H4>Synopsis</H4>
<P>Unlinks the specified node from any list it may be in, and
   frees its memory.
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    ASSERT (node);

    <A HREF="sfldoc.htm#node_unlink">node unlink</A> (node);
    mem_free (node);
}
</PRE>
<A NAME="node_relink_after">&nbsp;</A>
<H3><A NAME="TOC223"><TT>node_relink_after</TT></A></H3>
<PRE>
#include "sflnode.h"
void *
node_relink_after (
    void *node,
    void *after)
</PRE>
<H4>Synopsis</H4>
<P>Links a node into a doubly-linked list after a point in the
   list. Generally a linked list is attached to a 'head': an empty
   list consists of just the head node. To attach a node to the
   start of the list, link after the head. To attach a node to the
   end of the list, link before the head using
   <A HREF="sfldoc.htm#node_relink_before">node relink before</A>(). In this way you can build doubly-
   ended queues, fifo queue, lists, etc. Returns the address of
   the node.
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#node_relink">node relink</A> (after, node, ((NODE *) after)-&gt; next));
}
</PRE>
<A NAME="node_relink_before">&nbsp;</A>
<H3><A NAME="TOC224"><TT>node_relink_before</TT></A></H3>
<PRE>
#include "sflnode.h"
void *
node_relink_before (
    void *node,
    void *before)
</PRE>
<H4>Synopsis</H4>
<P>Links a node into a doubly-linked list before a point in the
   list. To link a node to the end of a doubly-linked list, link
   it before the list header node.
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#node_relink">node relink</A> (((NODE *) before)-&gt; prev, node, before));
}
</PRE>
<A NAME="node_unlink">&nbsp;</A>
<H3><A NAME="TOC225"><TT>node_unlink</TT></A></H3>
<PRE>
#include "sflnode.h"
void *
node_unlink (
    void *node)
</PRE>
<H4>Synopsis</H4>
<P>Unlinks the node from any list it may be in. Returns node.
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#node_relink">node relink</A> (((NODE *) node)-&gt; prev, node,
                         ((NODE *) node)-&gt; next));
}
</PRE>
<A NAME="node_relink">&nbsp;</A>
<H3><A NAME="TOC226"><TT>node_relink</TT></A></H3>
<PRE>
#include "sflnode.h"
void *
node_relink (
    void *left,
    void *node,
    void *right)
</PRE>
<H4>Synopsis</H4>
<P>Links the node into a linked list. This is a general-purpose
   function that can be used to attach and remove nodes anywhere
   in a list. Sets the global variable 'node_unsafe' while the
   list is being changed. Returns the address of node.
<H4>Source Code - (sflnode.c)</H4>
<PRE>
{
    NODE *swap;

    node_unsafe = TRUE;
    swap = ((NODE *) left)-&gt; next;      /*  Exchange left pointers           */
           ((NODE *) left)-&gt; next = ((NODE *) node)-&gt; next;
                                    ((NODE *) node)-&gt; next = swap;

    swap = ((NODE *) right)-&gt; prev;     /*  Exchange right pointers          */
           ((NODE *) right)-&gt; prev = ((NODE *) node)-&gt; prev;
                                     ((NODE *) node)-&gt; prev = swap;
    node_unsafe = FALSE;
    return (node);
}
</PRE>
<H2><A NAME="TOC227">Directory access functions</A></H2>
<P>Filename: sfldir.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/04/02 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/06/27
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>The directory access functions provide a portable interface to
   the system's file directory structure. In general these
   functions are modelled around the UNIX opendir and readdir
   functions, but they are also similar to the DOS interface.
   These functions can fail on SVr4 if the &lt;dirent.h&gt; file
   does not match the C library. Recompile with the switch -D
   _USE_BSD_DIRENT and they should work a bit better. Tested on:
   MS-DOS (Turbo-C), Windows (MSVC 4.0), UNIX (Linux, IBM AIX,
   SunOS). OS/2 port was done by Ewen McNeill <A
   HREF=mailto:"ewen@naos.co.nz">ewen@naos.co.nz</A>. DJGPP and
   DRDOS LFN by Rob Judd <A
   HREF=mailto:"judd@alphalink.com.au">judd@alphalink.com.au</A>.
   Changes for Win32 by Will Menninger <A
   HREF=mailto:"willus@netcom.com">willus@netcom.com</A>.
<H4>List of Functions</H4>
<UL>
<LI>Bool <A HREF="sfldoc.htm#open_dir">open dir</A><BR>
   (DIRST *dir, const char *dir_name);
</LI>
<LI>Bool <A HREF="sfldoc.htm#read_dir">read dir</A><BR>
   (DIRST *dir);
</LI>
<LI>Bool <A HREF="sfldoc.htm#close_dir">close dir</A><BR>
   (DIRST *dir);
</LI>
<LI>char * <A HREF="sfldoc.htm#format_dir">format dir</A><BR>
   (DIRST *dir, Bool full);
</LI>
<LI>int <A HREF="sfldoc.htm#fix_dir">fix dir</A><BR>
   (DIRST *dir);
</LI>
<LI>int <A HREF="sfldoc.htm#free_dir">free dir</A><BR>
   (DIRST *dir);
</LI>
<LI>char * <A HREF="sfldoc.htm#resolve_path">resolve path</A><BR>
   (const char *path);
</LI>
<LI>char * <A HREF="sfldoc.htm#locate_path">locate path</A><BR>
   (const char *root, const char *path);
</LI>
<LI>char * <A HREF="sfldoc.htm#clean_path">clean path</A><BR>
   (const char *path);
</LI>
<LI>NODE * <A HREF="sfldoc.htm#load_dir_list">load dir list</A><BR>
   (const char *dir_name, const char *sort);
</LI>
<LI>void <A HREF="sfldoc.htm#sort_dir_list">sort dir list</A><BR>
   (NODE *filelist, const char *sort);
</LI>
<LI>FILEINFO * <A HREF="sfldoc.htm#add_dir_list">add dir list</A><BR>
   (NODE *filelist, const DIRST *dir);
</LI>
<LI>Bool <A HREF="sfldoc.htm#free_dir_list">free dir list</A><BR>
   (NODE *filelist);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_curdir">get curdir</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_curdir">set curdir</A><BR>
   (const char *path);
</LI>
<LI>Bool <A HREF="sfldoc.htm#file_matches">file matches</A><BR>
   (const char *filename, const char *pattern);
</LI>
<LI>int <A HREF="sfldoc.htm#make_dir">make dir</A><BR>
   (const char *path);
</LI>
<LI>int <A HREF="sfldoc.htm#remove_dir">remove dir</A><BR>
   (const char *path);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfldir.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>ATTR_HIDDEN</B>  </TT>
<TD ALIGN="LEFT">0x02 /* Hidden file */
<TR><TD ALIGN="LEFT"><TT><B>ATTR_MASK</B>  </TT>
<TD ALIGN="LEFT">0x17 /* All bits together */
<TR><TD ALIGN="LEFT"><TT><B>ATTR_RDONLY</B>  </TT>
<TD ALIGN="LEFT">0x01 /* Read only file */
<TR><TD ALIGN="LEFT"><TT><B>ATTR_SUBDIR</B>  </TT>
<TD ALIGN="LEFT">0x10 /* Subdirectory */
<TR><TD ALIGN="LEFT"><TT><B>ATTR_SYSTEM</B>  </TT>
<TD ALIGN="LEFT">0x04 /* System file */
<TR><TD ALIGN="LEFT"><TT><B>DEFAULT_DIR</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>Dirent</B>  </TT>
<TD ALIGN="LEFT">dirent /* We'll always refer to Dirent */
<TR><TD ALIGN="LEFT"><TT><B>GID_CACHE_MAX</B>  </TT>
<TD ALIGN="LEFT">10 /* Max. different gid's we cache */
<TR><TD ALIGN="LEFT"><TT><B>MAXNAMLEN</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>NAME_MAX</B>  </TT>
<TD ALIGN="LEFT">MAXNAMLEN
<TR><TD ALIGN="LEFT"><TT><B>UID_CACHE_MAX</B>  </TT>
<TD ALIGN="LEFT">10 /* Max. different uid's we cache */
<TR><TD ALIGN="LEFT"><TT><B>_SFLDIR_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>stat</B>  </TT>
<TD ALIGN="LEFT">_stat
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>mode_t</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>nlink_t</B>  </TT>
<TD ALIGN="LEFT">unsigned short
<TR><TD ALIGN="LEFT"><TT><B>off_t</B>  </TT>
<TD ALIGN="LEFT">long
</TABLE>
<A NAME="open_dir">&nbsp;</A>
<H3><A NAME="TOC228"><TT>open_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
Bool
open_dir (
    DIRST *dir,
    const char *dir_name)
</PRE>
<H4>Synopsis</H4>
<P> Creates a directory stream and returns the first entry in the
   directory. The order of entries is arbitrary, and it is
   undefined whether you will get entries like '.' and '..' or
   not. Returns TRUE if something was found, else FALSE. If TRUE,
   fills-in the values in the directory stream block. Use the same
   directory stream block for the read_dir and <A HREF="sfldoc.htm#close_dir">close dir</A>()
   functions. You must supply a DIRST block when calling
   <A HREF="sfldoc.htm#open_dir">open dir</A>(). If you do not supply a dir_name (i.e. it is
   NULL or ""), <A HREF="sfldoc.htm#open_dir">open dir</A>() assumes you want to read from the
   current working directory. The strings in DIRST all point to
   static areas that may change after a further call to read_dir.
   If you need persistent data (i.e. because you want to collect a
   set of DIRSTs and then sort them, call <A HREF="sfldoc.htm#fix_dir">fix dir</A>() after each
   call to open_dir and read_dir. You should then call
   <A HREF="sfldoc.htm#free_dir">free dir</A>() to release each DIRST when you are finished.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    static char                         /*  The name of the directory that   */
        dir_spec [LINE_MAX];            /*     we are searching through      */
    char
        *dir_spec_end;                  /*  Points to NULL in dir_spec       */

    ASSERT (dir != NULL);
    memset (dir, 0, sizeof (DIRST));

    /*  Copy and prepare the directory specification                         */
    if (dir_name == NULL || *dir_name == 0)
        strcpy (dir_spec, DEFAULT_DIR);
    else
        strcpy (dir_spec, dir_name);

#if (defined (MSDOS_FILESYSTEM))
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (dir_spec, '/', '\\');
#endif
    /*  Remove a trailing slash from the directory name                      */
    dir_spec_end = dir_spec + strlen (dir_spec);
    if (dir_spec_end [-1] == PATHEND)
      {
        dir_spec_end [-1] = '\0';
        dir_spec_end--;
      }

    /*  Open directory stream or find first directory entry                  */
#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    if (strnull (dir_spec))
        strcpy (dir_spec, "/");
    if ((dir-&gt; _dir_handle = opendir (dir_spec)) == NULL)

#elif (defined (WIN32))
    strcat (dir_spec, "\\*");
    if ((dir-&gt; _dir_handle = FindFirstFile (dir_spec, &amp;dir-&gt; _dir_entry))
                           == INVALID_HANDLE_VALUE)

#elif (defined (_MSC_VER))
    strcat (dir_spec, "\\*.*");
    if ((dir-&gt; _dir_handle = _dos_findfirst (dir_spec, _A_NORMAL | _A_SUBDIR,
                                             &amp;dir-&gt; _dir_entry)) != 0)

#elif (defined (__TURBOC__) || defined (__DJGPP__))
    strcat (dir_spec, "\\*.*");
    if (findfirst (dir_spec, &amp;dir-&gt; _dir_entry, 255 - FA_LABEL) == -1)
#endif
        return (FALSE);                 /*  Could not open directory         */

    /*  Save the directory name in directory stream structure                */
#if (defined (__MSDOS__))
    *dir_spec_end = '\0';               /*  Kill the \*.* again              */
#endif
    dir-&gt; dir_name = dir_spec;

#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    /*  Under UNIX &amp; VMS we still need to fetch the first file entry         */
    return (<A HREF="sfldoc.htm#read_dir">read dir</A> (dir));

#elif (defined (WIN32))
    /*  Under Win32 we have read an entry, so return those values            */
    return (populate_entry (dir));

#elif (defined (_MSC_VER))
    /*  Under MSC we have read an entry, so return those values              */
    return (populate_entry (dir));

#elif (defined (__TURBOC__) || defined (__DJGPP__))
    /*  Under Borland C we have read an entry, so return those values        */
    return (populate_entry (dir));
#else

    return (FALSE);                     /*  Directory access not supported   */
#endif
}
</PRE>
<A NAME="read_dir">&nbsp;</A>
<H3><A NAME="TOC229"><TT>read_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
Bool
read_dir (
    DIRST *dir)
</PRE>
<H4>Synopsis</H4>
<P> Reads the next entry from the directory stream. Returns TRUE
   if there was more data to read; returns FALSE if there was
   nothing more to read. Updates the fields in the directory
   structure when it returns TRUE. The strings in DIRST all point
   to static areas that may change after a further call to
   read_dir. If you need persistent data (i.e. because you want to
   collect a set of DIRSTs and then sort them, call <A HREF="sfldoc.htm#fix_dir">fix dir</A>()
   after each call to open_dir and read_dir. You should then call
   <A HREF="sfldoc.htm#free_dir">free dir</A>() to release each DIRST when you are finished.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    ASSERT (dir != NULL);

#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    if ((dir-&gt; _dir_entry =
        (struct Dirent *) readdir (dir-&gt; _dir_handle)) != NULL)
        return (populate_entry (dir));
    else

#elif (defined (WIN32))
    if (FindNextFile (dir-&gt;_dir_handle, &amp;dir-&gt;_dir_entry))
        return (populate_entry (dir));
    else

#elif (defined (_MSC_VER))
    if (_dos_findnext (&amp;dir-&gt; _dir_entry) == 0)
        return (populate_entry (dir));
    else

#elif (defined (__TURBOC__) || defined (__DJGPP__))
    if (findnext (&amp;dir-&gt; _dir_entry) == 0)
        return (populate_entry (dir));
    else
#endif

    return (FALSE);
}
</PRE>
<A NAME="close_dir">&nbsp;</A>
<H3><A NAME="TOC230"><TT>close_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
Bool
close_dir (
    DIRST *dir)
</PRE>
<H4>Synopsis</H4>
<P> Close the directory stream, and free any allocated memory. You
   should call this function when you are done reading a
   directory, or you will get memory leaks. Returns TRUE if okay,
   FALSE if there was an error.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    Bool
        rc;

    ASSERT (dir != NULL);

#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    rc = (closedir (dir-&gt; _dir_handle) == 0);

#elif (defined (WIN32))
    rc = FindClose (dir-&gt;_dir_handle);

#elif (defined (_MSC_VER))
    rc = TRUE;                          /*  No function to close a dir       */

#elif (defined (__TURBOC__) || defined (__DJGPP__))
    rc = TRUE;                          /*  No function to close a dir       */
#else

    rc = FALSE;                         /*  Directory access not supported   */
#endif

    return (rc);
}
</PRE>
<A NAME="format_dir">&nbsp;</A>
<H3><A NAME="TOC231"><TT>format_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
char *
format_dir (
    DIRST *dir,
    Bool full)
</PRE>
<H4>Synopsis</H4>
<P> Formats the directory entry information using the same
   conventions as the UNIX 'ls -l' command. Returns a static
   buffer that contains the the formatted string. If the full
   argument is TRUE, adds cosmetic hints to indicate the file
   type; for instance '/' if the file is a directory, '*' if it is
   executable.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    static char
        buffer [LINE_MAX];              /*  Formatted directory entry        */

    ASSERT (dir != NULL);
    sprintf (buffer, "%s %3d %-8.8s %-8.8s %8ld %s %s",
                      format_mode (dir),
                      dir-&gt; file_nlink,
                      dir-&gt; owner,
                      dir-&gt; group,
                      (long) dir-&gt; file_size,
                      format_time (dir),
                      format_name (dir, full)
           );
    return (buffer);
}
</PRE>
<A NAME="fix_dir">&nbsp;</A>
<H3><A NAME="TOC232"><TT>fix_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
int
fix_dir (DIRST *dir)
</PRE>
<H4>Synopsis</H4>
<P> Converts all strings in the DIRST into permenant values, by
   allocating heap memory for each string. You must call this
   function if you intend to keep a set of DIRSTs, for searching
   or sorting. You do not need to call <A HREF="sfldoc.htm#fix_dir">fix dir</A>() if you handle
   each call to <A HREF="sfldoc.htm#read_dir">read dir</A>() independently. If you use
   <A HREF="sfldoc.htm#fix_dir">fix dir</A>(), you must call <A HREF="sfldoc.htm#free_dir">free dir</A>() for each DIRST when
   you terminate. Returns 0 if okay, -1 if there was insufficient
   memory or another fatal error.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    char
        *dir_name,
        *owner,
        *group,
        *file_name;

    /*  Allocate each string                                                 */
    dir_name  = mem_strdup (dir-&gt; dir_name);
    owner     = mem_strdup (dir-&gt; owner);
    group     = mem_strdup (dir-&gt; group);
    file_name = mem_strdup (dir-&gt; file_name);

    /*  If all okay, assign new strings and indicate everything okay         */
    if (dir_name &amp;&amp; owner &amp;&amp; group &amp;&amp; file_name)
      {
        dir-&gt; dir_name  = dir_name;
        dir-&gt; owner     = owner;
        dir-&gt; group     = group;
        dir-&gt; file_name = file_name;
        dir-&gt; _fixed    = TRUE;
        return (0);
      }
    else
      {
        /*  Otherwise patch things back the way they were                    */
        if (dir_name)
            mem_free (dir_name);
        if (owner)
            mem_free (owner);
        if (group)
            mem_free (group);
        if (file_name)
            mem_free (file_name);
        return (-1);
      }
}
</PRE>
<A NAME="free_dir">&nbsp;</A>
<H3><A NAME="TOC233"><TT>free_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
int
free_dir (DIRST *dir)
</PRE>
<H4>Synopsis</H4>
<P> Frees all strings used in the DIRST. You should call this
   function to free space allocated by <A HREF="sfldoc.htm#fix_dir">fix dir</A>(). If you try
   to call <A HREF="sfldoc.htm#free_dir">free dir</A>() for a DIRST that was not fixed, you will
   get an error feedback, and (if you compiled with DEBUG defined)
   an assertion fault. Returns 0 if okay, -1 if there was an
   error. After a call to <A HREF="sfldoc.htm#free_dir">free dir</A>(), do not try to access the
   strings in DIRST; they are all set to point to an empty string.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    static char
        *empty = "";

    ASSERT (dir-&gt; _fixed);
    if (dir-&gt; _fixed)
      {
        /*  Free allocated strings                                           */
        mem_free (dir-&gt; dir_name);
        mem_free (dir-&gt; owner);
        mem_free (dir-&gt; group);
        mem_free (dir-&gt; file_name);

        /*  Now point the strings to an empty string                         */
        dir-&gt; dir_name  = empty;
        dir-&gt; owner     = empty;
        dir-&gt; group     = empty;
        dir-&gt; file_name = empty;

        /*  And mark the DIRST as no longer 'fixed'                          */
        dir-&gt; _fixed    = FALSE;
        return (0);
      }
    else
        return (-1);
}
</PRE>
<A NAME="load_dir_list">&nbsp;</A>
<H3><A NAME="TOC234"><TT>load_dir_list</TT></A></H3>
<PRE>
#include "sfldir.h"
NODE *
load_dir_list (
    const char *dir_name,
    const char *sort)
</PRE>
<H4>Synopsis</H4>
<P> Loads and sorts the contents of a directory. Returns a NODE
   pointer to a linked list containing the directory entries. Each
   node is a FILEINFO structure (mapped onto a NODE structure for
   purposes of manipulating the linked list). You can ask for the
   directory list to be sorted in various ways; in this case
   subdirectory entries are always sorted first. To specify the
   sort order you pass a string consisting of one or more of these
   characters, which are then used in order: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>n</B>  <TD ALIGN="LEFT">Sort by
   ascending name. <TR><TD ALIGN="LEFT"><B>N</B>  <TD
   ALIGN="LEFT">Sort by descending name. <TR><TD
   ALIGN="LEFT"><B>x</B>  <TD ALIGN="LEFT">Sort by ascending
   extension. <TR><TD ALIGN="LEFT"><B>X</B>  <TD ALIGN="LEFT">Sort
   by descending extension. <TR><TD ALIGN="LEFT"><B>t</B>  <TD
   ALIGN="LEFT">Sort by ascending time and date. <TR><TD
   ALIGN="LEFT"><B>T</B>  <TD ALIGN="LEFT">Sort by descending time
   and date. <TR><TD ALIGN="LEFT"><B>s</B>  <TD ALIGN="LEFT">Sort
   by ascending size. <TR><TD ALIGN="LEFT"><B>S</B>  <TD
   ALIGN="LEFT">Sort by descending size. </TABLE> If the sort
   string is NULL, no sort is carried out.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    NODE
        *file_list;                     /*  File list head                   */
    DIRST
        dir;
    Bool
        rc;
    int
        nbr_files = 0;

    file_list = mem_alloc (sizeof (NODE));
    if (!file_list)
        return (NULL);

    node_reset (file_list);             /*  Initialise file list             */

    /* Load directory                                                        */
    rc = <A HREF="sfldoc.htm#open_dir">open dir</A> (&amp;dir, dir_name);
    while (rc)
      {
        <A HREF="sfldoc.htm#add_dir_list">add dir list</A> (file_list, &amp;dir);
        nbr_files++;
        rc = <A HREF="sfldoc.htm#read_dir">read dir</A> (&amp;dir);
      }
    <A HREF="sfldoc.htm#close_dir">close dir</A> (&amp;dir);

    if (sort &amp;&amp; nbr_files &gt; 1)
        <A HREF="sfldoc.htm#sort_dir_list">sort dir list</A> (file_list, sort);
    return (file_list);
}
</PRE>
<A NAME="free_dir_list">&nbsp;</A>
<H3><A NAME="TOC235"><TT>free_dir_list</TT></A></H3>
<PRE>
#include "sfldir.h"
Bool
free_dir_list (NODE *file_list)
</PRE>
<H4>Synopsis</H4>
<P> Frees all FILELIST blocks in the specified linked list.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    ASSERT (file_list);

    while (file_list-&gt; next != file_list)
      {
        <A HREF="sfldoc.htm#free_dir">free dir</A> (&amp;((FILEINFO *) file_list-&gt; next)-&gt; dir);
        <A HREF="sfldoc.htm#node_destroy">node destroy</A> (file_list-&gt; next);
      }
    mem_free (file_list);
    return (TRUE);
}
</PRE>
<A NAME="sort_dir_list">&nbsp;</A>
<H3><A NAME="TOC236"><TT>sort_dir_list</TT></A></H3>
<PRE>
#include "sfldir.h"
void
sort_dir_list (NODE *file_list, const char *sort)
</PRE>
<H4>Synopsis</H4>
<P>Sorts the directory list as specified. Returns the number of
   items in the list. To specify the sort order you pass a string
   holding one or more of these characters, which are then used in
   order: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>n</B>  <TD
   ALIGN="LEFT">Sort by ascending name. <TR><TD
   ALIGN="LEFT"><B>N</B>  <TD ALIGN="LEFT">Sort by descending
   name. <TR><TD ALIGN="LEFT"><B>x</B>  <TD ALIGN="LEFT">Sort by
   ascending extension. <TR><TD ALIGN="LEFT"><B>X</B>  <TD
   ALIGN="LEFT">Sort by descending extension. <TR><TD
   ALIGN="LEFT"><B>t</B>  <TD ALIGN="LEFT">Sort by ascending time
   and date. <TR><TD ALIGN="LEFT"><B>T</B>  <TD ALIGN="LEFT">Sort
   by descending time and date. <TR><TD ALIGN="LEFT"><B>s</B>  <TD
   ALIGN="LEFT">Sort by ascending size. <TR><TD
   ALIGN="LEFT"><B>S</B>  <TD ALIGN="LEFT">Sort by descending
   size. </TABLE>
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    ASSERT (file_list);
    sort_key = (char *) sort;
    <A HREF="sfldoc.htm#list_sort">list sort</A> (file_list, compare_dir);
}
</PRE>
<A NAME="add_dir_list">&nbsp;</A>
<H3><A NAME="TOC237"><TT>add_dir_list</TT></A></H3>
<PRE>
#include "sfldir.h"
FILEINFO *
add_dir_list (NODE *file_list, const DIRST *dir)
</PRE>
<H4>Synopsis</H4>
<P>Adds a node to the specified directory list. Returns the
   address of the new node, or NULL if there was insufficient
   memory.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    FILEINFO
        *file_info;

    file_info = (FILEINFO *) <A HREF="sfldoc.htm#node_create">node create</A> (file_list-&gt; prev, sizeof (FILEINFO));
    if (file_info)
      {
        memcpy  (&amp;file_info-&gt; dir, dir, sizeof (DIRST));
        <A HREF="sfldoc.htm#fix_dir">fix dir</A> (&amp;file_info-&gt; dir);
        file_info-&gt; directory = (dir-&gt; file_attrs &amp; ATTR_SUBDIR) != 0;
      }
    return (file_info);
}
</PRE>
<A NAME="resolve_path">&nbsp;</A>
<H3><A NAME="TOC238"><TT>resolve_path</TT></A></H3>
<PRE>
#include "sfldir.h"
char *
resolve_path (
    const char *old_path)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a path consisting of zero or more directory names and
   optionally a filename plus extension. Removes '.' and '..' if
   they occur in the path. '..' is resolved by also removing the
   preceding directory name, if any. Returns the address of the
   resulting path, in a static area that is overwritten by each
   call. The returned path may be empty. Under OS/2 and MS-DOS,
   treats '\' and '/' both as directory separators. A '..'
   directory at the start of the path resolves into nothing. If
   the input path started with '/', the returned path also does,
   else it does not. For compatibility with DOS-based systems,
   '...' is treated as '../..', '....' as '../../..', and so on.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (MSDOS_FILESYSTEM) || defined (__VMS__))
    static char
        new_path [PATH_MAX];            /*  Returned path value              */
    char
        *new_ptr,                       /*  Pointer into new_path            */
        last_char = '/';                /*  Start of path counts as delim    */
    int
        nbr_dots;                       /*  Size of '..', '...' specifier    */

    ASSERT (old_path);
    ASSERT (strlen (old_path) &lt; PATH_MAX);

    new_ptr = new_path;
    while (*old_path)
      {
        if (path_delimiter (last_char) &amp;&amp; *old_path == '.')
          {
            /*  Handle one or more dots followed by a path delimiter         */
            nbr_dots = 0;               /*  Count number of dots             */
            while (old_path [nbr_dots] == '.')
                nbr_dots++;

            if (path_delimiter (old_path [nbr_dots]))
              {
                old_path += nbr_dots;   /*  Skip past dots                   */
                if (*old_path)
                    old_path++;         /*    and past / if any              */

                /*  Now backtrack in new path, dropping directories as       */
                /*  many times as needed (0 or more times)                   */
                while (nbr_dots &gt; 1)
                  {
                    if (new_ptr &gt; new_path + 1)
                      {
                        new_ptr--;      /*  Drop delimiter                   */
                        while (new_ptr &gt; new_path)
                          {
                            if (path_delimiter (*(new_ptr - 1)))
                                break;  /*    and end after delimiter        */
                            new_ptr--;
                          }
                      }
                    else
                        break;          /*  At start of name - finish        */
                    nbr_dots--;
                  }
              }
            else
                /*  Handle '.something'                                      */
                last_char = *new_ptr++ = *old_path++;
          }
        else
            last_char = *new_ptr++ = *old_path++;
      }

    *new_ptr = '\0';                    /*  Terminate string nicely          */
    return (new_path);
#else

    return ((char *) old_path);         /*  Path resolution not supported    */
#endif
}
</PRE>
<A NAME="locate_path">&nbsp;</A>
<H3><A NAME="TOC239"><TT>locate_path</TT></A></H3>
<PRE>
#include "sfldir.h"
char *
locate_path (
    const char *root,
    const char *path)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a root directory and a path and locates the path with
   respect to the root. If the path looks like an absolute
   directory, returns the path after cleaning it up. Otherwise
   appends the path to the root, and returns the result. In any
   case, the resulting directory does not need to exist. Cleans-up
   the returned path by appending a '/' if necessary, and
   resolving any '..' subpaths. The returned value is held in a
   static string that is reused by each call to this function.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (MSDOS_FILESYSTEM) || defined (__VMS__))
    static char
        new_path [PATH_MAX];            /*  Returned path value              */

    ASSERT (root);
    ASSERT (path);

#if (defined (MSDOS_FILESYSTEM))
    /*  Under MSDOS, OS/2, or Windows we have a full path if we have any of:
     *  /directory
     *  D:/directory
     *  the variations of those with backslashes.
     */
    if (path [0] == '\\'   || path [0] == '/'
    || (isalpha (path [0]) &amp;&amp; path [1] == ':'
    &amp;&amp; (path [2] == '\\'   || path [2] == '/')))

#else
    /*  Under UNIX or VMS we have a full path if the path starts
     *  with the directory marker
     */
    if (path [0] == PATHEND)
#endif
        strcpy (new_path, path);        /*  Use path as supplied             */
    else
      {
        strcpy (new_path, root);        /*  Build root/path                  */
        if (!path_delimiter (strlast (new_path)))
            strcat (new_path, "/");
        strcat (new_path, path);
      }
    /*  Append slash if necessary                                            */
    if (!path_delimiter (strlast (new_path)))
        strcat (new_path, "/");
    return (<A HREF="sfldoc.htm#resolve_path">resolve path</A> (new_path));
#else
    return ((char *) path);
#endif
}
</PRE>
<A NAME="clean_path">&nbsp;</A>
<H3><A NAME="TOC240"><TT>clean_path</TT></A></H3>
<PRE>
#include "sfldir.h"
char *
clean_path (
    const char *path)
</PRE>
<H4>Synopsis</H4>
<P>Returns a clean directory name; i.e. resolves the path, removes
   a trailing slash unless the name consists just of '/'; on a MS-
   DOS file system, cleans-up a directory name consisting of a
   disk specifier. The cleaned-up directory path is in a static
   area that is overwritten by each call.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (MSDOS_FILESYSTEM) || defined (__VMS__))
    static char
        new_path [PATH_MAX + 1];        /*  Returned path value              */
    char
        *slash;

    strncpy (new_path, path, PATH_MAX);
    new_path [PATH_MAX] = '\0';
#   if (defined (MSDOS_FILESYSTEM))
    /*  For DOS filesystems, use only back slashes                           */
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (new_path, '/', '\\');
#   endif
    slash = strrchr (new_path, PATHEND);    /*  Find last slash              */

#   if (defined (MSDOS_FILESYSTEM))
    /*  If slash is last character in string, maybe squash it                */
    if (slash &amp;&amp; slash [1] == '\0')
      {
        if (slash &gt; new_path &amp;&amp; slash [-1] != ':')
            *slash = '\0';
      }
    else                                /*  Turn X: into X:\                 */
    if (new_path [1] == ':' &amp;&amp; new_path [2] == '\0')
      {
        new_path [2] = '\\';
        new_path [3] = '\0';
      }
#   else
    /*  If slash is last character in string, maybe squash it                */
    if (slash &amp;&amp; slash [1] == '\0')
        if (slash &gt; new_path)
            *slash = '\0';
#   endif
    return (new_path);
#else
    return ((char *) path);
#endif
}
</PRE>
<A NAME="get_curdir">&nbsp;</A>
<H3><A NAME="TOC241"><TT>get_curdir</TT></A></H3>
<PRE>
#include "sfldir.h"
char *
get_curdir (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a buffer containing the current working directory. This
   buffer is allocated using the mem_alloc() function and should
   be freed using mem_free() when no longer needed. Returns NULL
   if there was insufficient memory to allocate the buffer, or if
   the system does not provide the current working directory
   information. Under Windows, replaces backslash characters by
   the UNIX-like slash. Under OpenVMS, returns directory name in
   POSIX format.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    static char
        curdir [PATH_MAX + 1];          /*  String we get from the OS        */
    char
        *allocated;                     /*  Re-allocated string              */

#if (defined (__UNIX__) || defined (__OS2__))
    getcwd (curdir, PATH_MAX);

#elif (defined (__VMS__))
    getcwd (curdir, PATH_MAX, 0);

#elif (defined (WIN32))
    GetCurrentDirectory (PATH_MAX, curdir);
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (curdir, '\\', '/');

#elif (defined (MSDOS_FILESYSTEM))
    getcwd (curdir, PATH_MAX);
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (curdir, '\\', '/');

#else
    strclr (curdir);
#endif

    /*  Reallocate buffer using mem_strdup, so that any memory leaks are     */
    /*  correctly traced.                                                    */
    allocated = mem_strdup (curdir);
    return (allocated);
}
</PRE>
<A NAME="set_curdir">&nbsp;</A>
<H3><A NAME="TOC242"><TT>set_curdir</TT></A></H3>
<PRE>
#include "sfldir.h"
int
set_curdir (
    const char *path)
</PRE>
<H4>Synopsis</H4>
<P>Sets the current working directory as specified. Returns 0 if
   the directory path was found; -1 if there was an error. Under
   Windows, replaces '/' by '\' before changing directory, and
   switches to the specified disk if the path starts with a letter
   and ':'. Does nothing if the path is NULL or empty.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    int
        feedback = 0;

#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    if (path &amp;&amp; *path)
        feedback = chdir (path);

#elif (defined (MSDOS_FILESYSTEM))
    char
        *copy_path = mem_strdup (path);

    if (path == NULL || *path == '\0')
        return (0);                     /*  Do nothing if path is empty      */

    /*  MS-DOS compilers generally require a two-step process                */
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (copy_path, '/', '\\');

#   if (defined (WIN32))
    /* The drive letter does not need to be changed separately in Win32.    */
    feedback = !SetCurrentDirectory (copy_path);

#   elif (defined (__TURBOC__))
    feedback = chdir (copy_path);
    if (feedback == 0 &amp;&amp; isalpha (path [0]) &amp;&amp; path [1] == ':')
        setdisk (toupper (path [0]) - 'A');

#   elif (defined (__LCC__))
    feedback = chdir (copy_path);
    if (feedback == 0 &amp;&amp; isalpha (path [0]) &amp;&amp; path [1] == ':')
        chdrive (toupper (path [0]) - 'A' + 1);

#   elif (defined (_MSC_VER))
    feedback = _chdir (copy_path);
    if (feedback == 0 &amp;&amp; isalpha (path [0]) &amp;&amp; path [1] == ':')
        _chdrive (toupper (path [0]) - 'A' + 1);

#   endif
    mem_strfree (&amp;copy_path);
#else
    feedback = -1;
#endif

    return (feedback);
}
</PRE>
<A NAME="file_matches">&nbsp;</A>
<H3><A NAME="TOC243"><TT>file_matches</TT></A></H3>
<PRE>
#include "sfldir.h"
Bool
file_matches (
    const char *filename,
    const char *pattern)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the filename matches the pattern. The pattern
   is a character string that can contain these 'wildcard'
   characters:
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    char
        *pattern_ptr,                   /*  Points to pattern                */
        *filename_ptr;                  /*  Points to filename               */

    filename_ptr = (char *) filename;   /*  Start comparing file name        */
    pattern_ptr  = (char *) pattern;    /*  Start comparing file name        */
    FOREVER
      {
        /*  If we came to the end of the pattern and the filename, we have   */
        /*  successful match.                                                */
        if (*pattern_ptr == '\0' &amp;&amp; *filename_ptr == '\0')
            return (TRUE);              /*  Have a match                     */

        /*  Otherwise, end of either is a failed match                       */
        if (*pattern_ptr == '\0' || *filename_ptr == '\0')
            return (FALSE);             /*  Match failed                     */

        /*  If the pattern character is '?', then we matched a char          */
        if (*pattern_ptr == '?'
#if (defined (NAMEFOLD))
        ||  toupper (*pattern_ptr) == toupper (*filename_ptr))
#else
        ||  *pattern_ptr == *filename_ptr)
#endif
          {
            pattern_ptr++;
            filename_ptr++;
          }
        else
        /*  If we have a '*', match as much of the filename as we can        */
        if (*pattern_ptr == '*')
          {
            pattern_ptr++;              /*  Try to match following char      */
            while (*filename_ptr &amp;&amp; *filename_ptr != *pattern_ptr)
                filename_ptr++;
          }
        else
            return (FALSE);             /*  Match failed                     */
      }
}
</PRE>
<A NAME="make_dir">&nbsp;</A>
<H3><A NAME="TOC244"><TT>make_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
int
make_dir (
    const char *path_to_create)
</PRE>
<H4>Synopsis</H4>
<P>Create a new directory. Returns 0 if the directory was created;
   -1 if there was an error. Under Windows and OpenVMS, accepts
   directory names with '/'. Will create multiple levels of
   directory if required.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
    char
        *path,
        *slash;
    int
        rc = 0;

    path = mem_strdup (path_to_create); /*  Working copy                     */
#if (defined (MSDOS_FILESYSTEM))
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (path, '/', '\\');
#endif

    /*  Create each component of directory as required                       */
    slash = strchr (path + 1, PATHEND); /*  Find first slash                 */
    FOREVER                             /*  Create any parent directories    */
      {
        if (slash)
            *slash = '\0';              /*  Cut at slash                     */

        if (!<A HREF="sfldoc.htm#file_is_directory">file is directory</A> (path))
          {
#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
            rc = mkdir (path, 0775);    /*  User RWE Group RWE World RE      */

#elif (defined (WIN32))
            rc = !CreateDirectory (path, NULL);

#elif (defined (MSDOS_FILESYSTEM))
#   if (defined (__DJGPP__))
            rc = mkdir (path, 0775);    /*  User RWE Group RWE World RE      */
#   else
            rc = mkdir (path);          /*  Protection?  What's that?        */
#   endif
#else
            rc = -1;                    /*  Not a known system               */
#endif
            if (rc)                     /*  End if error                     */
                break;
          }
        if (slash == NULL)              /*  End if last directory            */
            break;
       *slash = PATHEND;                /*  Restore path name                */
        slash = strchr (slash + 1, PATHEND);
      }
    mem_strfree (&amp;path);
    return (rc);
}
</PRE>
<A NAME="remove_dir">&nbsp;</A>
<H3><A NAME="TOC245"><TT>remove_dir</TT></A></H3>
<PRE>
#include "sfldir.h"
int
remove_dir (
    const char *path)
</PRE>
<H4>Synopsis</H4>
<P>remove a directory. Returns 0 if the directory could be
   removed; -1 if there was an error. Under MS-DOS and OpenVMS
   accepts a directory name in UNIX format, i.e. containing '/'
   delimiters. The directory must be empty to be removed.
<H4>Source Code - (sfldir.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__VMS_XOPEN) || defined (__OS2__))
    /*  Check that directory exists                                          */
    if (!<A HREF="sfldoc.htm#file_is_directory">file is directory</A> (path))
        return (-1);

    return (rmdir (path));

#elif (defined (MSDOS_FILESYSTEM))
    int
        feedback = 0;
    char
        *copy_path;

    /*  Check that directory exists                                          */
    if (!<A HREF="sfldoc.htm#file_is_directory">file is directory</A> (path))
        return (-1);

    copy_path = mem_strdup (path);
    if (copy_path)
      {
        <A HREF="sfldoc.htm#strconvch">strconvch</A> (copy_path, '/', '\\');
#   if (defined (WIN32))
        feedback = !RemoveDirectory (copy_path);
#   else
        feedback = rmdir(copy_path);
#   endif
        mem_strfree (&amp;copy_path);
      }
    return (feedback);
#else
    return (-1);
#endif
}
</PRE>
<H2><A NAME="TOC246">Process control functions</A></H2>
<P>Filename: sflproc.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/09/09 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/01/30
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to create and manage processes. The main set
   of functions lets you create, monitor, and end processes. A
   secondary function lets you run the current process as a
   background process.
<H4>List of Functions</H4>
<UL>
<LI>PROCESS <A HREF="sfldoc.htm#process_create">process create</A><BR>
   (const char *file, char *argv [], const char *workdir, const
   char *std_in, const char *std_out, const char *std_err, char
   *envv [], Bool wait);
</LI>
<LI>int <A HREF="sfldoc.htm#process_status">process status</A><BR>
   (PROCESS process_id);
</LI>
<LI>int <A HREF="sfldoc.htm#process_kill">process kill</A><BR>
   (PROCESS process_id);
</LI>
<LI>void <A HREF="sfldoc.htm#process_close">process close</A><BR>
   (PROCESS process_id);
</LI>
<LI>int <A HREF="sfldoc.htm#process_server">process server</A><BR>
   (const char *workdir, const char *lockfile);
</LI>
<LI>Bool <A HREF="sfldoc.htm#process_alarm">process alarm</A><BR>
   (long delay);
</LI>
<LI>char * <A HREF="sfldoc.htm#process_esc">process esc</A><BR>
   (char *dest, const char *src);
</LI>
<LI>char * <A HREF="sfldoc.htm#process_unesc">process unesc</A><BR>
   (char *dest, const char *src);
</LI>
<LI>int <A HREF="sfldoc.htm#process_priority">process priority</A><BR>
   (int priority);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflproc.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FILEHANDLE_MAX</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>NULL_PROCESS</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>PRIORITY_HIGH</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>PRIORITY_LOW</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>PRIORITY_NORMAL</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>PROCESS_ENDED_ERROR</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>PROCESS_ENDED_OK</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>PROCESS_INTERRUPTED</B>  </TT>
<TD ALIGN="LEFT">3
<TR><TD ALIGN="LEFT"><TT><B>PROCESS_RUNNING</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>_SFLPROC_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>PROCESS</B>  </TT>
<TD ALIGN="LEFT">qbyte
</TABLE>
<A NAME="process_create">&nbsp;</A>
<H3><A NAME="TOC247"><TT>process_create</TT></A></H3>
<PRE>
#include "sflproc.h"
PROCESS
process_create (
    const char *filename,               /*  Name of file to execute          */
    char *argv [],                      /*  Arguments for process, or NULL   */
    const char *workdir,                /*  Working directory, or NULL       */
    const char *std_in,                 /*  Stdin device, or NULL            */
    const char *std_out,                /*  Stdout device, or NULL           */
    const char *std_err,                /*  Stderr device, or NULL           */
    char *envv [],                      /*  Environment variables, or NULL   */
    Bool  wait                          /*  Wait for process to end          */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a subprocess and returns a PROCESS identifying the new
   process. Optionally directs standard input, output, and error
   streams to specified devices. The caller can also specify
   environment symbols that the subprocess can access. Accepts
   these arguments: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>filename</B>  <TD ALIGN="LEFT">File to execute;
   if not fully specified, searches PATH. <TR><TD
   ALIGN="LEFT"><B>argv []</B>  <TD ALIGN="LEFT">List of
   arguments; argv [0] is filename; ends in a NULL. <TR><TD
   ALIGN="LEFT"><B>workdir</B>  <TD ALIGN="LEFT">Working
   directory; if NULL, remains in current directory. <TR><TD
   ALIGN="LEFT"><B>std in</B>  <TD ALIGN="LEFT">Device to use for
   standard input; NULL = no redirection. <TR><TD
   ALIGN="LEFT"><B>std out</B>  <TD ALIGN="LEFT">Device to use for
   standard output; NULL = no redirection. <TR><TD
   ALIGN="LEFT"><B>std err</B>  <TD ALIGN="LEFT">Device to use for
   standard error; NULL = no redirection. <TR><TD
   ALIGN="LEFT"><B>envs []</B>  <TD ALIGN="LEFT">List of
   environment symbols to define, or NULL. </TABLE> If argv is
   NULL, parses the filename argument into words delimited by
   whitespace and builds the necessary argv table automatically.
   Use this feature to execute a command with arguments, specified
   as one string. The envv list consists of strings in the form
   "name=value", ending in a NULL pointer. If the envv argument is
   null, the environment of the current process is passed.
   Otherwise the envv environment is used. If the process is
   started correctly, this function will sleep for 'process_delay'
   milliseconds. If the child command detects an error at startup,
   it may exit with an error status. The sleep allows this error
   to be collected by calling <A HREF="sfldoc.htm#process_status">process status</A>() after this
   call. If process_delay is 0, any child error is ignored.
   Returns child process id, or 0 if there was an error. Under
   VMS, the filename must have been defined as a command before
   the calling process was started; the path is disregarded. Under
   OS/2 the filename can be the name of a CMD script, and this
   will be run with the interpreter specified in the first line
   (EXTPROC line, or "'/'*!" line; or failing that with the
   default command interpreter. Known bugs: when parsing filename
   argument into words, does not handle quotes in any special way;
   "this text" is 2 words, '"this' and 'text"'. You should have
   passed the filename through <A HREF="sfldoc.htm#process_esc">process esc</A>() before adding any
   optional arguments.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__UNIX__))
    /*************************************************************************
     **  UNIX  ***************************************************************
     *************************************************************************/

    pid_t
        fork_result;                    /*  Result from fork()               */
    int
        pipe_handle [2],                /*  Parent-to-child pipe             */
        pipe_readsize,                  /*  Amount of data read from pipe    */
        pipe_data;                      /*  Data read from pipe              */
    struct itimerval
        timeout;                        /*  Wait for response from child     */
    struct sigaction
        old_handler;                    /*  Old handler for SIGALRM          */
    const char
        *filename_only;                 /*  Filename, without arguments      */
    char
        *clean_filename,                /*  Unescaped filename               */
        *full_filename;                 /*  File to execute, with path       */

    /*  Create pipe for feedback from child to parent; quit if this fails    */
    if (pipe (pipe_handle))
        return (0);

    /*  Create subprocess - this returns 0 if we are the child, the pid if   */
    /*  we are the parent, or -1 if there was an error (not enough memory).  */
    fork_result = fork ();

    if (fork_result &lt; 0)                /*  &lt; 0 is an error                  */
      {
        close (pipe_handle [0]);        /*  Close the pipe                   */
        close (pipe_handle [1]);
        return (0);                     /*  Could not fork                   */
      }
    else
    if (fork_result &gt; 0)                /*  &gt; 0 is the parent process        */
      {
        /*  --- PARENT PROCESS HANDLING ------------------------------------ */
        /*  If the child process has a problem with the exec() call, it      */
        /*  sends us an errno value across the pipe.  If the exec() call     */
        /*  works okay, we get no feedback across the pipe.  We wait for a   */
        /*  small time (number of msecs specified by process_delay).  If     */
        /*  nothing comes across the pipe, we assume everything went okay.   */
        /*  The FD_CLOEXEC setting *should* cause the child pipe to close    */
        /*  after exec() but this does not seem to work; the read() still    */
        /*  blocks.  Bummer.                                                 */

        if (process_delay &gt; 0)
          {
            timeout.it_interval.tv_sec  = 0;
            timeout.it_interval.tv_usec = 0;
            timeout.it_value.tv_sec     =  process_delay / 1000;
            timeout.it_value.tv_usec    = (process_delay % 1000) * 1000;

            /*  Save old signal handler to be polite to the calling program  */
            /*  then redirect the SIGALRM signal to our own (empty) handler  */
            sigaction    (SIGALRM, NULL, &amp;old_handler);
            signal       (SIGALRM, ignore_signal);
            siginterrupt (SIGALRM, TRUE);
            setitimer    (ITIMER_REAL, &amp;timeout, 0);

            /*  Now read on the pipe until data arrives or the alarm goes    */
            pipe_readsize = read (pipe_handle [0], &amp;pipe_data, sizeof (errno));
            /*  Restore old signal handler                                   */
            siginterrupt (SIGALRM, FALSE);
            sigaction (SIGALRM, &amp;old_handler, NULL);

          }
        else
            pipe_readsize = 0;

        close (pipe_handle [0]);        /*  Close the pipe                   */
        close (pipe_handle [1]);
        if (pipe_readsize == -1)
          {
            if (errno == EBADF || errno == EINTR)
              {
                /*  Normal - SIGALRM arrived or FD_CLOEXEC worked :)         */
                if (wait)
                    waitpid (fork_result, 0, 0);
                return ((PROCESS) fork_result);
              }
            else
                return (0);             /*  Error on read()                  */
          }
        else
        /*  We come here if process_delay was zero, or FD_CLOEXEC did its    */
        /*  job and the pipe was closed by the child process.                */
        if (pipe_readsize == 0)
          {
            if (wait)
                waitpid (fork_result, 0, 0);
            return ((PROCESS) fork_result);
          }
        else
          {
            /*  We read data from the pipe - this is an error feedback from  */
            /*  the child - i.e. file not found, or a permission problem.    */
            errno = pipe_data;          /*  Stuff the errno                  */
            return (0);
          }
      }
    /*  --- CHILD PROCESS HANDLING ----------------------------------------- */
    /*  Prepare the process environment and execute the file                 */
    /*  If argv[] array was not supplied, build it now from filename         */
    /*  And pull out the name of the file that we want to run.               */
    if (!argv)
      { /*  Split off the arguments, and pick out the filename to use        */
        argv = <A HREF="sfldoc.htm#tok_split">tok split</A> (filename);

        /*  The filename, and only the filename, is the 0th argument         */
        filename_only = argv[0];
      }
    else
      { /*  Already got our arguments, so the filename is just the filename  */
        filename_only = filename;
      }

    /*  If requested, close stdin, stdout, stderr, and redirect them         */
    redirect_io (std_in,  STDIN_FILENO,  pipe_handle [1], TRUE);
    redirect_io (std_out, STDOUT_FILENO, pipe_handle [1], FALSE);
    redirect_io (std_err, STDERR_FILENO, pipe_handle [1], FALSE);

    /*  Find file on path, make sure it is executable                        */
    /*  This is a good moment to unescape any spaces in the filename...      */

    clean_filename = <A HREF="sfldoc.htm#process_unesc">process unesc</A> (NULL, filename_only);
    if (strchr (clean_filename, '/')     == NULL
    &amp;&amp;  strchr (clean_filename, PATHEND) == NULL)
        full_filename = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", clean_filename, NULL);
    else
        full_filename = <A HREF="sfldoc.htm#file_where">file where</A> ('r',  NULL,  clean_filename, NULL);
    mem_free (clean_filename);

    if (full_filename == NULL)
      {
        errno = ENOENT;                 /*  No such file                     */
        write (pipe_handle [1], &amp;errno, sizeof (errno));
        exit (EXIT_FAILURE);            /*  Kill the child process           */
      }
    if (!<A HREF="sfldoc.htm#file_is_executable">file is executable</A> (full_filename))
      {
        errno = EACCES;                 /*  No permission to access file     */
        write (pipe_handle [1], &amp;errno, sizeof (errno));
        exit (EXIT_FAILURE);            /*  Kill the child process           */
      }
    /*  Tell the system to close the pipe when we've done the exec()         */
    fcntl (pipe_handle [0], F_SETFD, FD_CLOEXEC);
    fcntl (pipe_handle [1], F_SETFD, FD_CLOEXEC);

    /*  If requested, change to working directory                            */
    if (workdir)
        chdir (workdir);

    /*  Execute the program - normally this call does not return, as it      */
    /*  replaces the current process image by the new one.  If we ever do    */
    /*  return, it is because there was an error.                            */
    if (envv)                           /*  If caller provided envv, use it  */
        execve (full_filename, argv, envv);
    else                                /*  Otherwise use current values     */
        execv  (full_filename, argv);

    write (pipe_handle [1], &amp;errno, sizeof (errno));
    exit (EXIT_FAILURE);                /*  Kill the child process           */

#elif (defined (__OS2__))
    /*************************************************************************
     **  OS/2  ***************************************************************
     *************************************************************************/

    int
        process = 0;                    /*  Process number                   */
    HANDLE
        old_stdin = -1,                 /*  Dup'd handle for old stdin       */
        old_stdout = -1,                /*  Dup'd handle for old stdout      */
        old_stderr = -1;                /*  Dup'd handle for old stderr      */
    int parsedargs = 0,                 /*  argv() points at token array     */
        free_argv  = 0;                 /*  argv() points at handbuilt array */
    const char
        *filename_only = NULL,          /*  Filename, without arguments      */
        *actual_command = NULL;         /*  Actual command string to run     */
    char
        *clean_filename = NULL,         /*  Unescaped filename               */
        *full_filename = NULL,          /*  File to execute, with path       */
        *curdir = NULL,                 /*  Current working directory        */
        *strfree_this = NULL;           /*  <A HREF="sfldoc.htm#strfree">strfree</A>() this, if not NULL      */

    /*  NOTE: special care must be taken to ensure this code does not leak   */
    /*  memory, as the memory will be leaked in the main process which       */
    /*  potientally tries to run for a long period of time.  Token arrays    */
    /*  have a lot of potiental for leaks if care is not taken.  To avoid    */
    /*  these potiental problems, strings are copied a little more than      */
    /*  otherwise would have been done, and then the original token arrays   */
    /*  are freed.                                                           */

    /*  If argv[] array was not supplied, build it now from filename         */
    /*  And pull out the name of the file that we want to run.               */
    if (!argv)
    {   /*  Split off the arguments, and pick out the filename to use        */
        argv = <A HREF="sfldoc.htm#tok_split">tok split</A> (filename);

        /*  The filename, and only the filename, is the 0th argument         */
        filename_only = argv[0];

        parsedargs = 1;                 /* Yes, we split off the arguments   */
    }
    else
    {   /*  Already got our arguments, so the filename is just the filename  */
        filename_only = filename;
    }

    /*  Under OS/2, we accept the magic file headers "#!", and "'/'*!".      */
    /*  We also special case running CMD scripts, so that we invoke the      */
    /*  default command interpreter, with a "/c" parameter, and the script   */
    /*  name.  The magic file headers are checked first so can be used to    */
    /*  override the default command interpreter.                            */

    actual_command = redirect_exec (filename_only);

    if (actual_command != NULL)
    {
        /*  At this point we have a string containing the name of the        */
        /*  program to run, followed by the arguments and the scriptname,    */
        /*  if it was a script that we were going to run.  So we tokenise the*/
        /*  string we got back and arrange for those bits to end up in the   */
        /*  arguments if required.                                           */
        char **newargs = NULL;
        int num_new = 0, num_existing = 0;
        int  free_newargs = 0;

        newargs = <A HREF="sfldoc.htm#tok_split">tok split</A> (actual_command);  /*  Split off the arguments   */

        actual_command = newargs[0];

        /*  Count the number of new arguments (should be at least 1)         */
        /*  And while we are here, eliminate any double quotes around the    */
        /*  arguments (especially the script name), since they'll only get   */
        /*  in the way later.                                                */
        for (num_new = 0; newargs[num_new] != NULL; num_new++)
            if (*newargs[num_new] == '"')
            {  char *pair = NULL;
               pair = strrchr(newargs[num_new], '"');
               if (pair != NULL)
               {  *pair = '\0';                /* Eliminate the last "       */
                  newargs[num_new]++;          /* Step over the first one    */
               }
            }

        ASSERT(num_new &gt;= 1);

        /*  Count the number of existing arguments (from above), should be   */
        /*  at least 1.                                                      */
        for (num_existing = 0; argv[num_existing] != NULL; num_existing++)
            ;  /* EMPTY BODY */

        ASSERT(num_existing &gt;= 1);

        /*  Handle .CMD script files where the redirection wasn't done above */
        if (num_new == 1)
        {   /*  Okay, it didn't expand there.  But possibly we have a CMD    */
            /*  script and need to invoke the command processor.             */
            char *extension = NULL;

            /*  Find file extension; if not found, set to NULL               */
            extension = strrchr (actual_command, '.');
            if (extension == NULL
            ||  strchr (extension, '/')         /*  Last '.' is part of path */
            ||  strchr (extension, '\\'))       /*  =&gt; filename has no ext   */
                extension = NULL;

            if (extension != NULL &amp;&amp; (<A HREF="sfldoc.htm#lexcmp">lexcmp</A>(extension, ".CMD") == 0))
            {   /* This is a CMD script, and we need to invoke the command   */
                /* interpreter over it.                                      */
                char *command_processor = NULL;

                command_processor = <A HREF="sfldoc.htm#strdupl">strdupl</A> (<A HREF="sfldoc.htm#env_get_string">env get string</A> ("COMSPEC", ""));

                if (*command_processor != '\0') /*  Not an empty string      */
                {   /*  Determine command processor arguments                */
                    char **cmdargs = NULL;
                    char **tmpargs = NULL;

                    cmdargs = <A HREF="sfldoc.htm#tok_split">tok split</A> (command_processor);

                    /*  Count the number of new arguments (at least 1)       */
                    for (num_new = 0; cmdargs[num_new] != NULL; num_new++)
                        ;    /* EMPTY BODY */

                    ASSERT(num_new &gt;= 1);

                    /*  Now merge those arguments with script name           */
                    /*  Need: num_new + 1 for "/c", +1 for script name       */
                    /*        + 1 to terminate array                         */
                    tmpargs = mem_alloc((num_new+3) * sizeof(char *));

                    if (tmpargs != NULL)
                    {   /*  Okay, copy all the arguments into place          */
                        int i = 0;

                        for (i = 0; i &lt; num_new; i++)
                           tmpargs[i] = <A HREF="sfldoc.htm#strdupl">strdupl</A> (cmdargs[i]);

                        tmpargs[num_new++] = <A HREF="sfldoc.htm#strdupl">strdupl</A> ("/c");
                        tmpargs[num_new++] = <A HREF="sfldoc.htm#strdupl">strdupl</A> (actual_command);
                        tmpargs[num_new]   = NULL;

                        /*  Free the old arguments, and the old parse        */
                        <A HREF="sfldoc.htm#tok_free">tok free</A>(newargs);
                        <A HREF="sfldoc.htm#tok_free">tok free</A>(cmdargs);

                        /*  Now use that for our new arguments               */
                        newargs = tmpargs;
                        actual_command = newargs[0];
                        free_newargs = 1;       /*  Must free newargs later  */
                    }

                    /*  Free the command processor string                    */
                    <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;command_processor);
                }
            }   /* extension is .cmd                                         */
        }   /*  only one new argument (filename to run)                      */

        /*  Now collect all the arguments together into one array            */

        if (num_new &gt;= 2 &amp;&amp; num_existing &gt;= 2)
        {   /*  Okay, we've got arguments to merge together, so we put the   */
            /*  new ones first followed by the old ones.                     */
            char **tmpargs;

            ASSERT(newargs != NULL);

            /*  Allocate space for the new arguments (at start), and the     */
            /*  existing arumgnents (at end), and a terminator.              */
            tmpargs = mem_alloc((num_new+num_existing+1) * sizeof(char *));
            if (tmpargs != NULL)
            {   /*  Okay, copy all the arguments into place                  */
                int i = 0;

                for (i = 0; i &lt; num_new; i++)
                    tmpargs[i] = <A HREF="sfldoc.htm#strdupl">strdupl</A> (newargs[i]);

                /*  NOTE: We skip the first argument here, since it is the  */
                /*  name of the script, and we've got one of those above.   */
                /*  BUT we've got to put next arg in next position, hence -1*/

                for (i = 1; i &lt; num_existing; i++)
                    tmpargs[num_new + i - 1] = <A HREF="sfldoc.htm#strdupl">strdupl</A> (argv[i]);

                /*  Terminate the array of arguments                        */
                tmpargs[num_new + num_existing - 1] = NULL;

                /*  Pick up a new pointer to the command to run             */
                actual_command = tmpargs[0];

                /*  Tidy up after ourselves                                  */
                if (free_newargs)
                  {
                    int j = 0;
                    for (j = 0; newargs[j] != NULL; j++)
                        <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;newargs[j]);

                    mem_free(newargs);
                  }
                else
                    <A HREF="sfldoc.htm#tok_free">tok free</A> (newargs);

                if (parsedargs)
                  {
                    <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
                    parsedargs = 0;
                  }

                /*  Change pointer to point at the new (combined) arguments  */
                argv = tmpargs;
                free_argv = 1;
            }
            else
            {   /*  We couldn't allocate the new memory required             */
                /*  Return failure.                                          */
                <A HREF="sfldoc.htm#tok_free">tok free</A>(newargs);
                if (parsedargs)
                   <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
                errno = ENOMEM;
                return ((PROCESS)0);
            }
        }
        else if (num_new &gt;= 2 &amp;&amp; num_existing &lt;= 1)
        {   /*  There were no arguments before, there are now.  Use new ones */
            if (parsedargs)
            {  /* We parsed the arguments, free up some of the memory        */
               <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
               parsedargs = 0;
            }

            argv = newargs;
            if (free_newargs)               /* Make sure we free arguments   */
                free_argv = 1;
            else
                parsedargs = 1;
        }
        else /* (num_new &lt;= 1) */   /* num_existing is 1 or more             */
        {   /*  No expansion of the string, we just use the existing args    */
            /*  But we do use the string as returned, because it may have    */
            /*  an extension on it.                                          */
            ASSERT(num_new &lt;= 1);
            ASSERT(num_existing &gt;= 1);

            /*  Copy the string as returned, so that we can use it below     */
            strfree_this = <A HREF="sfldoc.htm#strdupl">strdupl</A> (actual_command);
            if (strfree_this != NULL)
            {
                actual_command = strfree_this;
                ASSERT(free_newargs == 0);
                <A HREF="sfldoc.htm#tok_free">tok free</A>(newargs);
            }
        }
    }   /*  Redirection found a filename to run */
    else
    {   /*  Redirection failed.  This means that it isn't executable, because*/
        /*  we should either have got a full name back, or a command string  */
        /*  to run.                                                          */

        if (parsedargs)
           <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
        errno = EACCES;                 /*  No permission to access file     */
        return (PROCESS)0;
    }

    /*  Find file on path, make sure it is executable                        */
    /*  This is a good moment to unescape any spaces in the filename...      */
    clean_filename = <A HREF="sfldoc.htm#process_unesc">process unesc</A> (NULL, actual_command);
    if (strchr (clean_filename, '/')     == NULL
    &amp;&amp;  strchr (clean_filename, PATHEND) == NULL)
        full_filename = <A HREF="sfldoc.htm#file_where">file where</A> ('r', "PATH", clean_filename, NULL);
    else
        full_filename = <A HREF="sfldoc.htm#file_where">file where</A> ('r',  NULL,  clean_filename, NULL);
    mem_free (clean_filename);

    if (full_filename == NULL)
      {
        /*  Clear out the memory that we don't need any longer               */
        if (parsedargs)
            <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
        else if (free_argv)
          {
            int j = 0;
            for (j = 0; argv[j] != NULL; j++)
                <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;argv[j]);
            mem_free(argv);
          }
        if (strfree_this != NULL)
            <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;strfree_this);

        errno = ENOENT;                 /*  No such file                     */
        return (PROCESS)0;              /*  Failed to open                   */
      }
    if (!<A HREF="sfldoc.htm#file_is_executable">file is executable</A> (full_filename))
      {
        /*  Clear out the memory that we don't need any longer               */
        if (parsedargs)
            <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
        else if (free_argv)
          {
            int j = 0;
            for (j = 0; argv[j] != NULL; j++)
                <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;argv[j]);
            mem_free(argv);
          }
        if (strfree_this != NULL)
           <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;strfree_this);

        errno = EACCES;                 /*  No permission to access file     */
        return (PROCESS)0;
      }

    /*  Redirect the IO streams, and save copies of the ones we redirect     */
    old_stdin  = redirect_io(std_in,  STDIN_FILENO,  0, TRUE);
    old_stdout = redirect_io(std_out, STDOUT_FILENO, 0, FALSE);
    old_stderr = redirect_io(std_err, STDERR_FILENO, 0, FALSE);

    if (old_stdin == -2 || old_stdout == -2 || old_stderr == -2)
    {   /* An error redirecting one of the file handles; restore them all    */
        /* and exit having failed our job.                                   */
        restore_redirection(old_stdin, old_stdout, old_stderr);

        /*  Clear out the memory that we don't need any longer               */
        if (parsedargs)
            <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
        else if (free_argv)
          {
            int j = 0;
            for (j = 0; argv[j] != NULL; j++)
                <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;argv[j]);
            mem_free(argv);
          }
        if (strfree_this != NULL)
           <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;strfree_this);

        return (PROCESS)0;
    }

    /*  If requested, change to working directory                            */
    if (workdir)
    {
        curdir = getcwd(NULL, 256);
        chdir (workdir);
    }
    else
        curdir = NULL;

    /*  Spawn the new program, and pick up its process ID.                   */
    if (envv)                           /*  If caller provided envv, use it  */
        process = spawnve (P_NOWAIT, full_filename, argv, envv);
    else                                /*  Otherwise use the current values */
        process = spawnv  (P_NOWAIT, full_filename, argv);

    /*  Put things back the way they were before                             */
    restore_redirection(old_stdin, old_stdout, old_stderr);
    if (curdir != NULL)                 /*  If directory changed, restore it */
    {
        chdir(curdir);
        free(curdir);
    }

    /*  Clear out the memory that we don't need any longer                   */
    if (parsedargs)
        <A HREF="sfldoc.htm#tok_free">tok free</A>(argv);
    else if (free_argv)
    {
        int j = 0;
        for (j = 0; argv[j] != NULL; j++)
            <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;argv[j]);

        mem_free(argv);
    }
    if (strfree_this != NULL)
        <A HREF="sfldoc.htm#strfree">strfree</A>(&amp;strfree_this);

    if (process &lt;= -1)
        return ((PROCESS)0);            /*  Error starting child process     */

    if (wait)
        waitpid (process, 0, 0);

    return ((PROCESS) process);

#elif (defined (WIN32))
    /*************************************************************************
     **  WINDOWS 32  *********************************************************
     *************************************************************************/

    PROCESS
        process;                        /*  Our created process handle       */
    STARTUPINFO
        newinfo = {0},                  /*  Specification for new process    */
        curinfo;                        /*  Specification of cur process     */
    PROCESS_INFORMATION
        procinfo;                       /*  Information about created proc   */
    DWORD
        dwCreateFlags = CREATE_NEW_CONSOLE;
    char
        *olddir,                        /*  Caller's working directory       */
        *fulldir,                       /*  Process' working directory       */
        *args,                          /*  Command arguments, if any        */
        *actual_command,                /*  Command, possibly qualified      */
        *buffer = NULL;                 /*  Working buffer                   */
    int
        argn;                           /*  Argument number                  */

    /*  Format full working directory, if specified                          */
    if (workdir)
      {
        olddir = <A HREF="sfldoc.htm#get_curdir">get curdir</A> ();         /*  Just a lazy way to let the OS    */
        <A HREF="sfldoc.htm#set_curdir">set curdir</A> (workdir);           /*  figure-out if the workdir is a   */
        fulldir = <A HREF="sfldoc.htm#get_curdir">get curdir</A> ();        /*  relative or absolute directory.  */
        <A HREF="sfldoc.htm#set_curdir">set curdir</A> (olddir);
        mem_free (olddir);
      }
    else
        fulldir = NULL;

    /*  Under Windows we accept the magic file header "#!".  If the          */
    /*  caller supplied an argument list, we attach this to the command.     */
    actual_command = redirect_exec (filename);
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (actual_command, '/', '\\');
    GetShortPathName (actual_command, actual_command,
                              strlen (actual_command) + 1);

    args = strchr (filename, ' ');      /*  Find arguments, if any           */
    if (argv)
      {                                 /*  Build full command buffer        */
        buffer = mem_alloc (<A HREF="sfldoc.htm#tok_text_size">tok text size</A> ((char **) argv)
                                + strlen (actual_command) + 1);
        strcpy (buffer, actual_command);
        for (argn = 1; argv [argn]; argn++)
            <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (buffer, " ", argv [argn], NULL);
        actual_command = buffer;
      }
    else
    if (args)
      {
        xstrcpy_debug ();
        buffer = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, actual_command, args, NULL);
        actual_command = buffer;
      }
    process = mem_alloc (sizeof (PROC_HANDLE));
    process-&gt; process = NULL;
    process-&gt; in  = redirect_io (std_in,  0, 0, TRUE);
    process-&gt; out = redirect_io (std_out, 0, 0, FALSE);
    process-&gt; err = redirect_io (std_err, 0, 0, FALSE);

    /*  Convert environment to a Windows-type packed block of strings        */
    /*  Use supplied environment, or parent environment if necessary.        */
    process-&gt; envd = <A HREF="sfldoc.htm#strt2descr">strt2descr</A> (envv? (char **) envv: environ);

    GetStartupInfo (&amp;curinfo);
    newinfo.cb          = sizeof (newinfo);
    newinfo.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    newinfo.wShowWindow = SW_HIDE;
    newinfo.hStdInput   = process-&gt; in?  process-&gt; in:  curinfo.hStdInput;
    newinfo.hStdOutput  = process-&gt; out? process-&gt; out: curinfo.hStdOutput;
    newinfo.hStdError   = process-&gt; err? process-&gt; err: curinfo.hStdError;
    newinfo.lpTitle     = NULL;

    /*  If necessary, run in separate VM, for 16-bit programs                */
    if (process_compatible)
        dwCreateFlags |= CREATE_SEPARATE_WOW_VDM;

    /*  CreateProcess returns errors sometimes, even when the process was    */
    /*  started correctly.  The cause is not evident.  For now: we detect    */
    /*  an error by checking the value of procinfo.hProcess after the call.  */
    procinfo.hProcess = NULL;
    CreateProcess (
        NULL,                           /*  Name of executable module        */
        actual_command,                 /*  Command line string              */
        NULL,                           /*  Process security attributes      */
        NULL,                           /*  Thread security attributes       */
        TRUE,                           /*  Handle inheritance flag          */
        dwCreateFlags,                  /*  Creation flags                   */
        process-&gt; envd-&gt; data,          /*  New environment block            */
        fulldir,                        /*  Current directory name           */
        &amp;newinfo,                       /*  STARTUPINFO                      */
        &amp;procinfo);                     /*  PROCESS_INFORMATION              */

    mem_strfree (&amp;fulldir);
    mem_strfree (&amp;buffer);              /*  Deallocate buffer, if used       */

    if (procinfo.hProcess == NULL)      /*  Error, we presume                */
      {
        <A HREF="sfldoc.htm#process_close">process close</A> (process);
        return (NULL);
      }

    /*  Release our hold on the thread                                       */
    CloseHandle (procinfo.hThread);
    process-&gt; process = procinfo.hProcess;

    /*  We do not need access to the files any longer in this process        */
    if (process-&gt; in)
      {
        CloseHandle (process-&gt; in);
        process-&gt; in = NULL;
      }
    if (process-&gt; out)
      {
        CloseHandle (process-&gt; out);
        process-&gt; out = NULL;
      }
    if (process-&gt; err)
      {
        CloseHandle (process-&gt; err);
        process-&gt; err = NULL;
      }

    /*  Wait for the process to finish or be cancelled                       */
    if (wait)
      {
        WaitForSingleObject (procinfo.hProcess, INFINITE);
        <A HREF="sfldoc.htm#process_close">process close</A> (process);
      }
    return (process);

#elif (defined (__VMS__))
    /*************************************************************************
     **  OPENVMS  ************************************************************
     *************************************************************************/

    PROCESS
        process;                        /*  Our created process handle       */
    char
        *curdir,                        /*  Current directory                */
        *clean_filename,                /*  Unescaped filename               */
        *full_filename = NULL,
        *full_std_in   = NULL,
        *full_std_out  = NULL;
    qbyte
        process_flags;                  /*  Process creation flags           */
    int
        argn,                           /*  Argument number                  */
        rc;                             /*  Return code from lib$spawn       */
    Bool
        rebuilt_argv = FALSE;           /*  Did we rebuild argv[]?           */

    VMS_STRING (command_dsc, "");       /*  Define string descriptors        */
    VMS_STRING (std_in_dsc,  "");
    VMS_STRING (std_out_dsc, "");

    /*  If argv[] array was not supplied, build it now from filename         */
    if (!argv)
      {
        argv = <A HREF="sfldoc.htm#tok_split">tok split</A> (filename);
        filename = argv [0];
        rebuilt_argv = TRUE;
      }
    /*  If filename contains a path or extension, disregard them             */
    clean_filename = strrchr (filename, '/');
    if (clean_filename)
        clean_filename++;
    else
        clean_filename = (char *) filename;
    if (strchr (clean_filename, '.'))
       *strchr (clean_filename, '.') = '\0';

    /*  Rebuild full command from filename and arguments                     */
    full_filename = mem_alloc (<A HREF="sfldoc.htm#tok_text_size">tok text size</A> ((char **) argv)
                               + strlen (clean_filename) + 1);
    strcpy (full_filename, clean_filename);
    for (argn = 1; argv [argn]; argn++)
        <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (full_filename, " ", argv [argn], NULL);

    /*  Free argument table if we allocated it dynamically here              */
    if (rebuilt_argv)
        <A HREF="sfldoc.htm#tok_free">tok free</A> (argv);

    command_dsc.value  = full_filename;
    command_dsc.length = strlen (full_filename);

    /*  Prepare full names for stdin and stdout                              */
    curdir = <A HREF="sfldoc.htm#get_curdir">get curdir</A> ();
    if (std_in)
      {
        if (strchr (std_in, '/'))       /*  If already with path, use as is  */
            full_std_in = mem_strdup (std_in);
        else
          {
            xstrcpy_debug ();
            full_std_in = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, curdir, "/", std_in, NULL);
          }
        translate_to_vms  (full_std_in);
        std_in_dsc.value = full_std_in;
      }
    if (std_out)
      {
        if (strchr (std_out, '/'))      /*  If already with path, use as is  */
            full_std_out = mem_strdup (std_out);
        else
          {
            xstrcpy_debug ();
            full_std_out = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, curdir, "/", std_out, NULL);
          }
        translate_to_vms   (full_std_out);
        std_out_dsc.value = full_std_out;
      }
    std_in_dsc.length  = std_in?  strlen (std_in_dsc.value): 0;
    std_out_dsc.length = std_out? strlen (std_out_dsc.value): 0;

    /*  If requested, change to working directory                            */
    if (workdir)
        chdir (workdir);

    /*  Prepare process flags                                                */
    if (wait)
        process_flags = 0;
    else
        process_flags = 1;              /*  Bit 1 = don't wait for child     */

    process = mem_alloc (sizeof (PROC_HANDLE));
    process-&gt; id     = 0;
    process-&gt; status = 0;               /*  Completion status                */

/*  char *envv [],  */                  /*  Environment variables, or NULL   */

    rc = lib$spawn (
        &amp;command_dsc,                   /*  Command to run                   */
        std_in?  &amp;std_in_dsc: NULL,     /*  Stdin descriptor                 */
        std_out? &amp;std_out_dsc: NULL,    /*  Stdout+stderr                    */
        &amp;process_flags,                 /*  Options for new process          */
        &amp;NULL,                          /*  Process name -- generated        */
        &amp;process-&gt; id,                  /*  Returned process ID              */
        &amp;process-&gt; status);

    if (workdir)                        /*  Switch back to original dir      */
        chdir (curdir);
    mem_free (curdir);

    mem_strfree (&amp;full_filename);       /*  Deallocate various buffers,      */
    mem_strfree (&amp;full_std_in);         /*    if they were used              */
    mem_strfree (&amp;full_std_out);        /*                                   */

    /*  Return process ID.  If we waited for completion, the process id      */
    /*  is always NULL.                                                      */
    if (rc != 1)                        /*  Process failed with error        */
      {
        <A HREF="sfldoc.htm#process_close">process close</A> (process);
        process = NULL;
      }
    else
    if (wait)                           /*  Finished with process            */
        <A HREF="sfldoc.htm#process_close">process close</A> (process);

    return (process);

#else
    return ((PROCESS) 0);               /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="process_status">&nbsp;</A>
<H3><A NAME="TOC248"><TT>process_status</TT></A></H3>
<PRE>
#include "sflproc.h"
int
process_status (
    PROCESS process)
</PRE>
<H4>Synopsis</H4>
<P>Returns status of process specified by process ID. Returns one
   of these values, or -1 if there was an error: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>PROCESS RUNNING</B>  <TD
   ALIGN="LEFT">Process is still running. <TR><TD
   ALIGN="LEFT"><B>PROCESS ENDED OK</B>  <TD ALIGN="LEFT">Process
   ended normally. <TR><TD ALIGN="LEFT"><B>PROCESS ENDED ERROR</B>
   <TD ALIGN="LEFT">Process ended with an error status. <TR><TD
   ALIGN="LEFT"><B>PROCESS INTERRUPTED</B>  <TD
   ALIGN="LEFT">Process was interrupted (killed). </TABLE> In the
   case of PROCESS_ENDED_ERROR, the global variable process_errno
   is set to the exit code returned by the process.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__OS2__))
    int
        status;
    pid_t
        return_pid;

    /*  waitpid() returns 0 if the child process is still running, or the    */
    /*  process id if it stopped.  It can also return -1 in case of error.   */
    /*  No other return value is possible.                                   */

    return_pid = waitpid (process, &amp;status, WNOHANG | WUNTRACED);
    if (return_pid == 0)
        return (PROCESS_RUNNING);
    else
    if (return_pid == process)
      {
        if (WIFEXITED (status))        /*  Program called exit()             */
          {
            process_errno = WEXITSTATUS (status);
            if (process_errno)         /*  Treat exit (0) as normal end      */
                return (PROCESS_ENDED_ERROR);
            else
                return (PROCESS_ENDED_OK);
          }
        else
        if (WIFSIGNALED (status))       /*  Process was interrupted          */
            return (PROCESS_INTERRUPTED);
        else
            return (PROCESS_ENDED_OK);
      }
    else
        return (-1);

#elif (defined (WIN32))
    DWORD
         status;

    ASSERT (process);
    status = WaitForSingleObject (process-&gt; process, 0);

    if (status == WAIT_TIMEOUT)
        return (PROCESS_RUNNING);
    else
    if (status == WAIT_OBJECT_0)
        return (PROCESS_ENDED_OK);
    else
    if (status == WAIT_ABANDONED)
        return (PROCESS_ENDED_ERROR);
    else
        return (-1);

#elif (defined (__VMS__))
    ASSERT (process);
    if (process-&gt; status == 0)
        return (PROCESS_RUNNING);
    else
        return (PROCESS_ENDED_OK);

#else
    return (-1);                        /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="process_kill">&nbsp;</A>
<H3><A NAME="TOC249"><TT>process_kill</TT></A></H3>
<PRE>
#include "sflproc.h"
int
process_kill (
    PROCESS process)
</PRE>
<H4>Synopsis</H4>
<P>Ends a process specified by a process id. The current process
   must have the appropriate authority to stop the specified
   process. Returns zero if the process was killed, -1 if there
   was an error.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__OS2__))
    int count = 5;

    /*  First give it a chance to gracefully exit...                         */
    kill (process, SIGTERM);
    while (<A HREF="sfldoc.htm#process_status">process status</A> (process) == PROCESS_RUNNING &amp;&amp; count--)
        sleep (1);

    /*  Then get brutal if neccessary.                                       */
    if (<A HREF="sfldoc.htm#process_status">process status</A> (process) == PROCESS_RUNNING)
      {
        kill (process, SIGKILL);
        while (<A HREF="sfldoc.htm#process_status">process status</A> (process) == PROCESS_RUNNING)
            sleep (1);
      }
    return (0);

#elif (defined (WIN32))
    ASSERT (process);
    TerminateProcess (process-&gt; process, 1);
    while (<A HREF="sfldoc.htm#process_status">process status</A> (process) == PROCESS_RUNNING)
        Sleep (100);

    <A HREF="sfldoc.htm#process_close">process close</A> (process);
    return (0);

#elif (defined (__VMS__))
    ASSERT (process);
    sys$delprc (process-&gt; id);
    <A HREF="sfldoc.htm#process_close">process close</A> (process);
    return (0);

#else
    return (-1);                        /*  Not supported on this system     */
#endif
}
</PRE>
<A NAME="process_close">&nbsp;</A>
<H3><A NAME="TOC250"><TT>process_close</TT></A></H3>
<PRE>
#include "sflproc.h"
void
process_close (
    PROCESS process)
</PRE>
<H4>Synopsis</H4>
<P>You should call this function when a process has ended
   normally, if you did not specify the wait option when calling
   the <A HREF="sfldoc.htm#process_create">process create</A>() function. On some systems, each
   created process uses some memory. <A HREF="sfldoc.htm#process_close">process close</A>()
   guarantees that this memory is correctly freed. Does nothing if
   the process handle is NULL.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (WIN32))
    if (process)
      {
        if (process-&gt; process)
            CloseHandle (process-&gt; process);
        if (process-&gt; in)
            CloseHandle (process-&gt; in);
        if (process-&gt; out)
            CloseHandle (process-&gt; out);
        if (process-&gt; err)
            CloseHandle (process-&gt; err);

        mem_free (process-&gt; envd);
        mem_free (process);
      }

#elif (defined (__VMS__))
    mem_free (process);

#endif
}
</PRE>
<A NAME="process_server">&nbsp;</A>
<H3><A NAME="TOC251"><TT>process_server</TT></A></H3>
<PRE>
#include "sflproc.h"
int
process_server (
    const char *workdir,                /*  Where server runs, or NULL/""    */
    const char *lockfile)               /*  For exclusive execution          */
</PRE>
<H4>Synopsis</H4>
<P>Converts the process from an interactive foreground process
   into a background process. The precise effect of this depends
   on the system. On UNIX, does this: <UL> <LI>Switches the
   process to run as a background job, under init; <LI>closes all
   open files; <LI>moves to a safe, known working directory, if
   required; <LI>sets the umask for new files; <LI>opens stdin,
   stdout, and stderr to the null device; <LI>enforces exclusive
   execution through a lock file, if required; <LI>logs the
   process id in the lock file; <LI>ignores the hangup unwanted
   signals. </UL> On other systems, may do nothing.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__UNIX__))
    int
        fork_result,
        file_handle;
    char
        pid_buffer [10];
    struct flock
        lock_file;                      /*  flock() argument block           */

    /*  We recreate our process as a child of init.  The process continues   */
    /*  to exit in the background.  UNIX calls wait() for all children of    */
    /*  the init process, so the server will exit cleanly.                   */

    fork_result = fork ();
    if (fork_result &lt; 0)                /*  &lt; 0 is an error                  */
        return (-1);                    /*  Could not fork                   */
    else
    if (fork_result &gt; 0)                /*  &gt; 0 is the parent process        */
        exit (EXIT_SUCCESS);            /*  End parent process               */

    /*  We close all open file descriptors that may have been inherited      */
    /*  from the parent process.  This is to reduce the resources we use.    */

    for (file_handle = FILEHANDLE_MAX - 1; file_handle &gt;= 0; file_handle--)
        close (file_handle);            /*  Ignore errors                    */

    /*  We move to a safe and known directory, which is supplied as an       */
    /*  argument to this function (or not, if workdir is NULL or empty).     */

    if (workdir &amp;&amp; strused (workdir))
        chdir (workdir);

    /*  We set the umask so that new files are given mode 750 octal          */

    umask (027);                        /*  Complement of 0750               */

    /*  We set standard input and output to the null device so that any      */
    /*  functions that assume that these files are open can still work.      */

    file_handle = open ("/dev/null", O_RDWR);    /*  stdin = handle 0        */
    dup (file_handle);                           /*  stdout = handle 1       */
    dup (file_handle);                           /*  stderr = handle 2       */

    /*  We enforce a lock on the lockfile, if specified, so that only one    */
    /*  copy of the server can run at once.  We return -1 if the lock fails. */
    /*  This locking code might be better isolated into a separate package,  */
    /*  since it is not very portable between unices.                        */

    if (lockfile &amp;&amp; strused (lockfile))
      {
        file_handle = open (lockfile, O_RDWR | O_CREAT, 0640);
        if (file_handle &lt; 0)
            return (-1);                /*  We could not open lock file      */
        else
          {
            lock_file.l_type = F_WRLCK;
            if (fcntl (file_handle, F_SETLK, &amp;lock_file))
                return (-1);            /*  We could not obtain a lock       */
          }
        /*  We record the server's process id in the lock file               */
        sprintf (pid_buffer, "%6d\n", getpid ());
        write   (file_handle, pid_buffer, strlen (pid_buffer));
      }

    /*  We ignore any hangup signal from the controlling TTY                 */
    signal (SIGHUP, SIG_IGN);

    return (0);                         /*  Initialisation completed ok      */
#else
    return (0);                         /*  Nothing to do on this system     */
#endif
}
</PRE>
<A NAME="process_alarm">&nbsp;</A>
<H3><A NAME="TOC252"><TT>process_alarm</TT></A></H3>
<PRE>
#include "sflproc.h"
Bool
process_alarm (long delay)
</PRE>
<H4>Synopsis</H4>
<P>Sets a system timer to raise a SIGALRM after a specified
   interval in milliseconds. Returns TRUE if the timer could be
   created and FALSE if there were insufficient resources, or if
   the system does not support timers. Permits a single alarm for
   the current process: any alarm that was still pending when you
   called this function is annulled. The implementation is system-
   dependent and highly non-portable. Under UNIX we use the
   setitimer() system function, which is clean and simple. Under
   16-bit Windows we use the SetTimer() call. This does not work
   in 32-bit console applications. Under 32-bit Windows we use the
   'multimedia' timer, which provides better resolution and does
   work in console applications. In both these cases we cache the
   id of the last-created alarm (and kill it before each new
   request), to avoid multiple active alarms. It is not a good
   idea to create too many concurrent timers; after 16 or so the
   alarms start to fail. This is not supposed to happen with MM
   timers, but does anyway. Under Windows, SIGALRM does not exist.
   Since signal() only accepts one of a small set of fixed
   signals, we hijack the SIGFPE signal... It's a compromise and
   requires that any code which expects a SIGALRM does not use
   SIGFPE. This can be tweaked in prelude.h. Under OS/2 we use the
   alarm() function which is accurate to one second only. The
   required accuracy of timing is not easily achieved, so
   <A HREF="sfldoc.htm#process_alarm">process alarm</A>() rounds down to whole seconds (except if
   rounding down would give 0, in which case it will delay 1
   second). This will probably cause problems in code applications
   that depends on sub-second timing resolution. Under OpenVMS 7
   and later we use the setitimer() function as for UNIX. Under
   OpenVMS 6 and earlier we use the alarm() function as for OS/2.
   This code may be tuned to use native VMS system calls.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__UNIX__) || defined (__VMS_XOPEN))
    struct itimerval
        timeout;                        /*  Timeout for setitimer            */

    /*  If the system supports interval timers, ask for a signal             */
    timeout.it_interval.tv_sec  = 0;
    timeout.it_interval.tv_usec = 0;
    timeout.it_value.tv_sec     = delay / 1000;
    timeout.it_value.tv_usec    = delay % 1000 * 1000L;
    setitimer (ITIMER_REAL, &amp;timeout, 0);
    return (TRUE);

#elif (defined (__OS2__) || defined (__VMS__))
    /*  Since we use alarm() for our timeout, we can only time to            */
    /*  the nearest second, and alarm(0) turns off the alarm.                */
    /*  NOTE: we also have only one timer -- if alarm() is called while      */
    /*  the alarm is active, then it will be reset to the new value, and     */
    /*  only a single SIGALRM will be generated.                             */
    delay = (delay &lt; 1000) ? 1 : (delay / 1000);
    alarm (delay);
    return (TRUE);

#elif (defined (__WINDOWS__))
#   if (defined (WIN32))
#   pragma comment (lib, "winmm")       /*  Link-in multimedia library       */
    /*  The multimedia timer gives the best accuracy, and works in console   */
    /*  applications                                                         */
    int rc;
    if (last_timer)
        rc = timeKillEvent (last_timer);

    last_timer = timeSetEvent (delay, 50, handle_timer, 0, TIME_ONESHOT);
    return (TRUE);

#   else
    /*  But the normal Windows timer will do if we're in 16 bits             */
    if (last_timer)
        KillTimer ((HWND) NULL, last_timer);

    last_timer = SetTimer ((HWND) NULL, 0, (UINT) delay, handle_timer);
    return (TRUE);
#   endif

#else
    return (FALSE);                     /*  No timers - function failed      */
#endif
}
</PRE>
<A NAME="process_esc">&nbsp;</A>
<H3><A NAME="TOC253"><TT>process_esc</TT></A></H3>
<PRE>
#include "sflproc.h"
char *
process_esc (char *dest, const char *src)
</PRE>
<H4>Synopsis</H4>
<P>Escapes a directory string so that <A HREF="sfldoc.htm#process_create">process create</A>() can
   handle it correctly. If you pass a command to process_create
   with a directory name that contains spaces, it will assume that
   the spaces delimit the command from its arguments. For
   instance, under Windows 95, the filename "C:\Program
   Files\Myprog.exe" will be incorrectly treated as a program
   called "C:\Program" with arguments "Files\Myprog.exe". This
   function replaces spaces by the escape character (0x1B). You
   cannot use this value in a filename and expect
   <A HREF="sfldoc.htm#process_create">process create</A>() to work correctly. On an EBCDIC system,
   the escape character (0x27) is also used. If the dest argument
   is NULL, allocates a string using mem_alloc() and returns that.
   Otherwise copies into the dest string and returns that. If the
   src string is NULL, returns an empty string.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (__EBCDIC__))
#   define ESC_CHAR   0x27
#else
#   define ESC_CHAR   0x1B
#endif
    /*  Copy to dest, allocate if necessary                                  */
    if (dest != src)
      {
        xstrcpy_debug ();
        dest = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (dest, src, NULL);
      }
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (dest, ' ', ESC_CHAR);
    return (dest);
}
</PRE>
<A NAME="process_unesc">&nbsp;</A>
<H3><A NAME="TOC254"><TT>process_unesc</TT></A></H3>
<PRE>
#include "sflproc.h"
char *
process_unesc (char *dest, const char *src)
</PRE>
<H4>Synopsis</H4>
<P>Does the reverse translaction to <A HREF="sfldoc.htm#process_esc">process esc</A>().
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
    /*  Copy to dest, allocate if necessary                                  */
    if (dest != src)
      {
        xstrcpy_debug ();
        dest = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (dest, src, NULL);
      }
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (dest, ESC_CHAR, ' ');
    return (dest);
}
</PRE>
<A NAME="process_priority">&nbsp;</A>
<H3><A NAME="TOC255"><TT>process_priority</TT></A></H3>
<PRE>
#include "sflproc.h"
int
process_priority (int priority)
</PRE>
<H4>Synopsis</H4>
<P>Sets process priority as specified, to one of PRIORITY_LOW,
   PRIORITY_NORMAL, or PRIORITY_HIGH. Currently has an effect only
   under Windows NT/95. Returns 0 if okay, -1 if there was an
   error.
<H4>Source Code - (sflproc.c)</H4>
<PRE>
{
#if (defined (WIN32))
    int
        class;

    if (priority == PRIORITY_HIGH)
        class = HIGH_PRIORITY_CLASS;
    else
    if (priority == PRIORITY_LOW)
        class = IDLE_PRIORITY_CLASS;
    else
        class = NORMAL_PRIORITY_CLASS;

    return (SetPriorityClass (GetCurrentProcess (), class));
#else
    return (0);
#endif
}
</PRE>
<H2><A NAME="TOC256">Time-slot functions</A></H2>
<P>Filename: sflslot.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/01/01 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>The time-slot functions provide long-running programs with a
   means to 'switch-on' and 'switch-off' depending on the time of
   day, and day of year. The intention is that the user can
   configure such programs to be active only between certain
   hours, on certain days, etc. The time-slot functions work with
   'range' bitmaps for a day (in seconds) and a year (in days),
   and provide functions to set, clear, and test these ranges.
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#year_range_empty">year range empty</A><BR>
   (byte *range);
</LI>
<LI>void <A HREF="sfldoc.htm#year_range_fill">year range fill</A><BR>
   (byte *range);
</LI>
<LI>int <A HREF="sfldoc.htm#year_slot_set">year slot set</A><BR>
   (byte *range, int day_from, int day_to);
</LI>
<LI>int <A HREF="sfldoc.htm#year_slot_clear">year slot clear</A><BR>
   (byte *range, int day_from, int day_to);
</LI>
<LI>Bool <A HREF="sfldoc.htm#year_slot_filled">year slot filled</A><BR>
   (const byte *range, int day);
</LI>
<LI>void <A HREF="sfldoc.htm#day_range_empty">day range empty</A><BR>
   (byte *range);
</LI>
<LI>void <A HREF="sfldoc.htm#day_range_fill">day range fill</A><BR>
   (byte *range);
</LI>
<LI>int <A HREF="sfldoc.htm#day_slot_set">day slot set</A><BR>
   (byte *range, int min_from, int min_to);
</LI>
<LI>int <A HREF="sfldoc.htm#day_slot_clear">day slot clear</A><BR>
   (byte *range, int min_from, int min_to);
</LI>
<LI>Bool <A HREF="sfldoc.htm#day_slot_filled">day slot filled</A><BR>
   (const byte *range, int minute);
</LI>
<LI>int <A HREF="sfldoc.htm#date_to_day">date to day</A><BR>
   (long date);
</LI>
<LI>int <A HREF="sfldoc.htm#time_to_min">time to min</A><BR>
   (long time);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflslot.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>MAX_DAY</B>  </TT>
<TD ALIGN="LEFT">366 /* Max. days in a normal year */
<TR><TD ALIGN="LEFT"><TT><B>MAX_MIN</B>  </TT>
<TD ALIGN="LEFT">1440 /* Max. minutes in a normal day */
<TR><TD ALIGN="LEFT"><TT><B>_SFLSLOT_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="year_range_empty">&nbsp;</A>
<H3><A NAME="TOC257"><TT>year_range_empty</TT></A></H3>
<PRE>
#include "sflslot.h"
void
year_range_empty (byte *range)
</PRE>
<H4>Synopsis</H4>
<P>Excludes all days in the year (sets all bits to zero).
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    memset (range, 0, sizeof (year_range));
}
</PRE>
<A NAME="year_range_fill">&nbsp;</A>
<H3><A NAME="TOC258"><TT>year_range_fill</TT></A></H3>
<PRE>
#include "sflslot.h"
void
year_range_fill (byte *range)
</PRE>
<H4>Synopsis</H4>
<P>Includes all days in the year (sets all bits to 1).
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    memset (range, 255, sizeof (year_range));
}
</PRE>
<A NAME="year_slot_clear">&nbsp;</A>
<H3><A NAME="TOC259"><TT>year_slot_clear</TT></A></H3>
<PRE>
#include "sflslot.h"
int
year_slot_clear (byte *range, int day_from, int day_to)
</PRE>
<H4>Synopsis</H4>
<P>Clears the slots for the specified day range. If day_to is
   zero, it is ignored; only the slot for day_from is cleared.
   Returns 0 if okay, -1 if the specified range is invalid.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    if (day_to == 0)
        day_to = day_from;              /*  Range is just one day            */

    if (day_from &gt; day_to)
        return (-1);                    /*  Bad range                        */

    while (day_from &lt;= day_to)          /*  Find and clear each bit          */
      {
        ASSERT (day_from &gt;= 0 &amp;&amp; day_from &lt; MAX_DAY);
        range [BYTE (day_from)] &amp;= 255 - BIT (day_from);
        day_from++;
      }
    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="year_slot_set">&nbsp;</A>
<H3><A NAME="TOC260"><TT>year_slot_set</TT></A></H3>
<PRE>
#include "sflslot.h"
int
year_slot_set (byte *range, int day_from, int day_to)
</PRE>
<H4>Synopsis</H4>
<P>Sets the slots for the specified day range. If day_to is zero,
   it is ignored; only the slot for day_from is set. Returns 0 if
   okay, -1 if the specified range is invalid.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    if (day_to == 0)
        day_to = day_from;              /*  Range is just one day            */

    if (day_from &gt; day_to)
        return (-1);                    /*  Bad range                        */

    while (day_from &lt;= day_to)          /*  Find and set each bit            */
      {
        ASSERT (day_from &gt;= 0 &amp;&amp; day_from &lt; MAX_DAY);
        range [BYTE (day_from)] |= BIT (day_from);
        day_from++;
      }
    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="year_slot_filled">&nbsp;</A>
<H3><A NAME="TOC261"><TT>year_slot_filled</TT></A></H3>
<PRE>
#include "sflslot.h"
Bool
year_slot_filled (const byte *range, int day)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified day slot is set; returns FALSE if
   the slot is not set.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    ASSERT (day &gt;= 0 &amp;&amp; day &lt; MAX_DAY);
    return ((range [BYTE (day)] &amp; BIT (day)) &gt; 0);
}
</PRE>
<A NAME="day_range_empty">&nbsp;</A>
<H3><A NAME="TOC262"><TT>day_range_empty</TT></A></H3>
<PRE>
#include "sflslot.h"
void
day_range_empty (byte *range)
</PRE>
<H4>Synopsis</H4>
<P>Excludes all minutes in the day (sets all bits to zero).
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    memset (range, 0, sizeof (day_range));
}
</PRE>
<A NAME="day_range_fill">&nbsp;</A>
<H3><A NAME="TOC263"><TT>day_range_fill</TT></A></H3>
<PRE>
#include "sflslot.h"
void
day_range_fill (byte *range)
</PRE>
<H4>Synopsis</H4>
<P>Includes all minutes in the day (sets all bits to 1).
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    memset (range, 255, sizeof (day_range));
}
</PRE>
<A NAME="day_slot_clear">&nbsp;</A>
<H3><A NAME="TOC264"><TT>day_slot_clear</TT></A></H3>
<PRE>
#include "sflslot.h"
int
day_slot_clear (byte *range, int min_from, int min_to)
</PRE>
<H4>Synopsis</H4>
<P>Clears the slots for the specified minute range. If min_to is
   zero, it is ignored; only the slot for min_from is cleared.
   Returns 0 if okay, -1 if the specified range is invalid.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    if (min_to == 0)
        min_to = min_from;              /*  Range is just one minute         */

    if (min_from &gt; min_to)
        return (-1);                    /*  Bad range                        */

    while (min_from &lt;= min_to)          /*  Find and clear each bit          */
      {
        ASSERT (min_from &gt;= 0 &amp;&amp; min_from &lt; MAX_MIN);
        range [BYTE (min_from)] &amp;= 255 - BIT (min_from);
        min_from++;
      }
    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="day_slot_set">&nbsp;</A>
<H3><A NAME="TOC265"><TT>day_slot_set</TT></A></H3>
<PRE>
#include "sflslot.h"
int
day_slot_set (byte *range, int min_from, int min_to)
</PRE>
<H4>Synopsis</H4>
<P>Sets the slots for the specified minute range. If min_to is
   zero, it is ignored; only the slot for min_from is set. Returns
   0 if okay, -1 if the specified range is invalid.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    if (min_to == 0)
        min_to = min_from;              /*  Range is just one minute         */

    if (min_from &gt; min_to)
        return (-1);                    /*  Bad range                        */

    while (min_from &lt;= min_to)          /*  Find and set each bit            */
      {
        ASSERT (min_from &gt;= 0 &amp;&amp; min_from &lt; MAX_MIN);
        range [BYTE (min_from)] |= BIT (min_from);
        min_from++;
      }
    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="day_slot_filled">&nbsp;</A>
<H3><A NAME="TOC266"><TT>day_slot_filled</TT></A></H3>
<PRE>
#include "sflslot.h"
Bool
day_slot_filled (const byte *range, int minute)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the specified minute slot is set; returns FALSE
   if the slot is not set.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    ASSERT (minute &gt;= 0 &amp;&amp; minute &lt; MAX_MIN);
    return ((range [BYTE (minute)] &amp; BIT (minute)) &gt; 0);
}
</PRE>
<A NAME="date_to_day">&nbsp;</A>
<H3><A NAME="TOC267"><TT>date_to_day</TT></A></H3>
<PRE>
#include "sflslot.h"
int
date_to_day (long date)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the day value (1..366) for the specified date. The
   date is an 8-digit number: YYYYMMDD.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#julian_date">julian date</A> (date));
}
</PRE>
<A NAME="time_to_min">&nbsp;</A>
<H3><A NAME="TOC268"><TT>time_to_min</TT></A></H3>
<PRE>
#include "sflslot.h"
int
time_to_min (long time)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the minute value (0..1439) for the specified time. The
   time is an 8-digit number: HHMMSSCC.
<H4>Source Code - (sflslot.c)</H4>
<PRE>
{
    int
        hour,                           /*  Hour component of time           */
        minute;                         /*  Minute component of time         */

    hour   = (int)  (time / 1000000L);
    minute = (int) ((time % 1000000L) / 10000L);
    minute += hour * 60;
    return (minute);
}
</PRE>
<H2><A NAME="TOC269">String-handling functions</A></H2>
<P>Filename: sflstr.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 92/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/06/15
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides various string-handling functions. Some of these
   functions are available on some but not all platforms; others
   are useful tools for string handling.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#strdupl">strdupl</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#strfree">strfree</A><BR>
   (char **string);
</LI>
<LI>char * <A HREF="sfldoc.htm#strskp">strskp</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#strcset">strcset</A><BR>
   (char *string, char ch);
</LI>
<LI>char * <A HREF="sfldoc.htm#strpad">strpad</A><BR>
   (char *string, char ch, int length);
</LI>
<LI>char * <A HREF="sfldoc.htm#strlwc">strlwc</A><BR>
   (char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#strupc">strupc</A><BR>
   (char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#strcrop">strcrop</A><BR>
   (char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#stropen">stropen</A><BR>
   (char *string, Bool align);
</LI>
<LI>char * <A HREF="sfldoc.htm#strclose">strclose</A><BR>
   (char *string, Bool align);
</LI>
<LI>char * <A HREF="sfldoc.htm#strunique">strunique</A><BR>
   (char *string, char unique);
</LI>
<LI>int <A HREF="sfldoc.htm#strmatch">strmatch</A><BR>
   (const char *string1, const char *string2);
</LI>
<LI>qbyte <A HREF="sfldoc.htm#strhash">strhash</A><BR>
   (const char *string);
</LI>
<LI>Bool <A HREF="sfldoc.htm#strprefixed">strprefixed</A><BR>
   (const char *string, const char *prefix);
</LI>
<LI>char * <A HREF="sfldoc.htm#strprefix">strprefix</A><BR>
   (const char *string, const char *delims);
</LI>
<LI>char * <A HREF="sfldoc.htm#strdefix">strdefix</A><BR>
   (const char *string, const char *prefix);
</LI>
<LI>char * <A HREF="sfldoc.htm#strconvch">strconvch</A><BR>
   (char *string, char from, char to);
</LI>
<LI>char * <A HREF="sfldoc.htm#xstrcat">xstrcat</A><BR>
   (char *dest, const char *src, ...);
</LI>
<LI>char * <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A><BR>
   (char *dest, const char *src, ...);
</LI>
<LI>int <A HREF="sfldoc.htm#lexcmp">lexcmp</A><BR>
   (const char *string1, const char *string2);
</LI>
<LI>int <A HREF="sfldoc.htm#lexncmp">lexncmp</A><BR>
   (const char *string1, const char *string2, const int count);
</LI>
<LI>int <A HREF="sfldoc.htm#lexwcmp">lexwcmp</A><BR>
   (const char *string1, const char *string2);
</LI>
<LI>char * <A HREF="sfldoc.htm#soundex">soundex</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#soundexn">soundexn</A><BR>
   (const char *string, int size, Bool fold);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#strt2descr">strt2descr</A><BR>
   (char **strings);
</LI>
<LI>char * <A HREF="sfldoc.htm#descr2strt">descr2strt</A><BR>
   (const DESCR *descr);
</LI>
<LI>void <A HREF="sfldoc.htm#strtfree">strtfree</A><BR>
   (char **strings);
</LI>
<LI>char * <A HREF="sfldoc.htm#removechars">removechars</A><BR>
   (char *str, char *chrs);
</LI>
<LI>char * <A HREF="sfldoc.htm#replacechrswith">replacechrswith</A><BR>
   (char *str, char *chrs, char ctorlcwth);
</LI>
<LI>char * <A HREF="sfldoc.htm#insertstring">insertstring</A><BR>
   (char *str, char *chrstoins, int pos);
</LI>
<LI>char * <A HREF="sfldoc.htm#insertchar">insertchar</A><BR>
   (char *str, char chrtoins, int pos);
</LI>
<LI>char * <A HREF="sfldoc.htm#leftfill">leftfill</A><BR>
   (char *str, char chrtofill, unsigned len);
</LI>
<LI>char * <A HREF="sfldoc.htm#rightfill">rightfill</A><BR>
   (char *str, char chrtofill, unsigned len);
</LI>
<LI>char * <A HREF="sfldoc.htm#trim">trim</A><BR>
   (char *strin);
</LI>
<LI>char * <A HREF="sfldoc.htm#ltrim">ltrim</A><BR>
   (char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#searchreplace">searchreplace</A><BR>
   (char *str, char *strtofnd, char *strtoins);
</LI>
<LI>char * <A HREF="sfldoc.htm#deletestring">deletestring</A><BR>
   (char *str, char *strtodel, int ignorecase);
</LI>
<LI>char * <A HREF="sfldoc.htm#getstrfld">getstrfld</A><BR>
   (char *str, int fln, int ofset, char *sep, char *ret);
</LI>
<LI>char * <A HREF="sfldoc.htm#setstrfld">setstrfld</A><BR>
   (char *str, int fln, int ofset, char *sep, char *ins);
</LI>
<LI>int <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A><BR>
   (char *str, int fln, int ofset, char *sep);
</LI>
<LI>char * <A HREF="sfldoc.htm#findstrinfile">findstrinfile</A><BR>
   (FILE *fp, char *find, char *retstr, int *iLnNo);
</LI>
<LI>char * <A HREF="sfldoc.htm#getequval">getequval</A><BR>
   (char *strline, char *strretstr);
</LI>
<LI>int <A HREF="sfldoc.htm#matchtable">matchtable</A><BR>
   (char *str, char *strmatch, char *strsept, int ncse);
</LI>
<LI>char * <A HREF="sfldoc.htm#stringreplace">stringreplace</A><BR>
   (char *strbuf, char *strpattern);
</LI>
<LI>char * <A HREF="sfldoc.htm#wordwrapstr">wordwrapstr</A><BR>
   (char *strbuff, int iwid);
</LI>
<LI>char * <A HREF="sfldoc.htm#stricstr">stricstr</A><BR>
   (const char *str1, const char *str2);
</LI>
<LI>int <A HREF="sfldoc.htm#strtempcmp">strtempcmp</A><BR>
   (const char *str1, const char *strPat);
</LI>
<LI>int <A HREF="sfldoc.htm#istoken">istoken</A><BR>
   (char **strLine, const char *strtoken, int *iWasToken);
</LI>
<LI>int <A HREF="sfldoc.htm#isoneoftokens">isoneoftokens</A><BR>
   (char **str, char *strmat, char *strsep, int *iWasTk);
</LI>
<LI>char * <A HREF="sfldoc.htm#eatstr">eatstr</A><BR>
   (char **strBuff, char *strToEat);
</LI>
<LI>char * <A HREF="sfldoc.htm#eatstrpast">eatstrpast</A><BR>
   (char **strBuff, char *strCharsToEatPast);
</LI>
<LI>char * <A HREF="sfldoc.htm#movestrpast">movestrpast</A><BR>
   (char **strBuff, char cCharToEatPast);
</LI>
<LI>char * <A HREF="sfldoc.htm#eatchar">eatchar</A><BR>
   (char **strBuff, char cChar);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflstr.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>IGNORECASE</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>SENSECASE</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>_SFLSTR_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>checkargcnt(reqnum)</B>  </TT>
<TD ALIGN="LEFT">((argc-1)&gt;=(reqnum)?1:0)
<TR><TD ALIGN="LEFT"><TT><B>cstrcpy(dest,src)</B>  </TT>
<TD ALIGN="LEFT">{*dest=src;*(dest+1)='\0';}
<TR><TD ALIGN="LEFT"><TT><B>deletechar(strbuf,pos)</B>  </TT>
<TD ALIGN="LEFT">strcpy((strbuf+pos),(strbuf+pos+1))
<TR><TD ALIGN="LEFT"><TT><B>deletechars(strbuf,pos,cnt)</B>  </TT>
<TD ALIGN="LEFT">strcpy((strbuf+pos),(strbuf+pos+cnt))
<TR><TD ALIGN="LEFT"><TT><B>getcommandlinearg(argnum)</B>  </TT>
<TD ALIGN="LEFT">((argnum)&lt;=(argc-1))?argv[argnum]:""
<TR><TD ALIGN="LEFT"><TT><B>mstrncpy(dest,src,len)</B>  </TT>
<TD ALIGN="LEFT">{strncpy(dest,src,len);*(dest+len)='\0';}
<TR><TD ALIGN="LEFT"><TT><B>numofcmdargs()</B>  </TT>
<TD ALIGN="LEFT">((argc-1)&gt;0?argc-1:0)
<TR><TD ALIGN="LEFT"><TT><B>xstrcpy_debug()</B>  </TT>
<TD ALIGN="LEFT">(various)
</TABLE>
<A NAME="strdupl">&nbsp;</A>
<H3><A NAME="TOC270"><TT>strdupl</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strdupl (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P> Makes a duplicate of string, obtaining space with a call to
   malloc(). The allocated space is strlen (string) + 1 bytes
   long. The caller is responsible for freeing the space allocated
   by strdup when it is no longer needed. Returns a pointer to the
   allocated string, which holds a copy of the parameter string.
   Returns NULL if there was insufficient heap storage available
   to allocate the string, or if the original string was itself
   NULL. Use this function in place of the non-portable strdup()
   function. You may also want to use the more robust
   <A HREF="sfldoc.htm#_mem_strdup"> mem strdup</A> () function.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *copy;

    if (string)
      {
        copy = malloc (strlen (string) + 1);
        if (copy)
            strcpy (copy, string);
      }
    else
        copy = NULL;

    return (copy);
}
</PRE>
<A NAME="strfree">&nbsp;</A>
<H3><A NAME="TOC271"><TT>strfree</TT></A></H3>
<PRE>
#include "sflstr.h"
char **
strfree (
    char **string)
</PRE>
<H4>Synopsis</H4>
<P> Releases memory occupied by a string. Call this function only
   when you previously allocated the string using malloc or
   <A HREF="sfldoc.htm#strdupl">strdupl</A>(). You pass the address of a char pointer; this
   function sets the pointer to NULL. This is a safety measure
   meant to make it safe to try to free non-allocated strings. In
   your code, initialise all such pointers to NULL. Returns the
   address of the modified pointer.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    ASSERT (string);
    if (*string)
      {
        free (*string);
        *string = NULL;
      }
    return (string);
}
</PRE>
<A NAME="strskp">&nbsp;</A>
<H3><A NAME="TOC272"><TT>strskp</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strskp (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Skips leading spaces in string, and returns a pointer to the
   first non-blank character. If this is a null, the end of the
   string was reached.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char
        *skip = (char *) string;

    ASSERT (string);
    while (*skip == ' ')
        skip++;
    return (skip);
}
</PRE>
<A NAME="strcset">&nbsp;</A>
<H3><A NAME="TOC273"><TT>strcset</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strcset (
    char *string,
    char ch)
</PRE>
<H4>Synopsis</H4>
<P>Sets all characters in string up to but not including the final
   null character to ch. Returns string. Use this function instead
   of the equivalent but non-portable strset() function.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *scan;

    ASSERT (string);
    scan = string;
    while (*scan)
        *scan++ = ch;
    return (string);
}
</PRE>
<A NAME="strpad">&nbsp;</A>
<H3><A NAME="TOC274"><TT>strpad</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strpad (
    char *string,
    char ch,
    int  length)
</PRE>
<H4>Synopsis</H4>
<P>Returns string of length characters, padding with ch or
   truncating if necessary. String must be at least length + 1
   long.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    int cursize;

    ASSERT (string);
    cursize = strlen (string);          /*  Get current length of string     */
    while (cursize &lt; length)            /*  Pad until at desired length      */
        string [cursize++] = ch;

    string [cursize++] = '\0';          /*  Add terminating null             */
    return (string);                    /*    and return to caller           */
}
</PRE>
<A NAME="strlwc">&nbsp;</A>
<H3><A NAME="TOC275"><TT>strlwc</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strlwc (
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts all alphabetic characters in string to lowercase,
   stopping at the final null character. Returns string. If string
   is null, returns null. We do not call this function strlwr
   because that is already provided by some systems (but not by
   ANSI C).
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *scan;

    if (string)
      {
        scan = string;
        while (*scan)
          {
            *scan = (char) tolower (*scan);
            scan++;
          }
      }
    return (string);
}
</PRE>
<A NAME="strupc">&nbsp;</A>
<H3><A NAME="TOC276"><TT>strupc</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strupc (
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Converts all alphabetic characters in string to uppercase,
   stopping at the final null character. Returns string. If string
   is null, returns null. We do not call this function strupr
   because that is already provided by some systems (but not by
   ANSI C).
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *scan;

    if (string)
      {
        scan = string;
        while (*scan)
          {
            *scan = (char) toupper (*scan);
            scan++;
          }
      }
    return (string);
}
</PRE>
<A NAME="strcrop">&nbsp;</A>
<H3><A NAME="TOC277"><TT>strcrop</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strcrop (
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Drops trailing whitespace from string by truncating string to
   the last non-whitespace character. Returns string. If string is
   null, returns null.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *last;

    if (string)
      {
        last = string + strlen (string);
        while (last &gt; string)
          {
            if (!isspace (*(last - 1)))
                break;
            last--;
          }
        *last = 0;
      }
    return (string);
}
</PRE>
<A NAME="stropen">&nbsp;</A>
<H3><A NAME="TOC278"><TT>stropen</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
stropen (
    char *string,
    Bool  align)
</PRE>
<H4>Synopsis</H4>
<P>Inserts a character at string, and places a blank in the gap.
   If align is TRUE, makes room by reducing the size of the next
   gap of 2 or more spaces. If align is FALSE, extends the size of
   the string. Returns string.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *gap;
    int  length;

    ASSERT (string);
    length = strlen (string) + 1;       /*  By default, move string + NULL   */
    if (align)                          /*  If align is TRUE, find gap       */
      {
        gap = strstr (string, "  ");
        if (gap)
            length = (int) (gap - string);
      }
    memmove (string + 1, string, length);
    string [0] = ' ';                   /*  Stick a space into string        */
    return (string);
}
</PRE>
<A NAME="strclose">&nbsp;</A>
<H3><A NAME="TOC279"><TT>strclose</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strclose (
    char *string,
    Bool align)
</PRE>
<H4>Synopsis</H4>
<P>Removes the character at string, and shifts the remainder down
   by one. If align is TRUE, only shifts up to the next gap of 2
   or more spaces. Returns string.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *gap;
    int  length;

    ASSERT (string);
    length = strlen (string);           /*  By default, move string + NULL   */
    if (align) {                        /*  If align is TRUE, find gap       */
        gap = strstr (string, "  ");
        if (gap &amp;&amp; gap != string)
            length = (int) (gap - string);
    }
    memmove (string, string + 1, length);
    return (string);
}
</PRE>
<A NAME="strunique">&nbsp;</A>
<H3><A NAME="TOC280"><TT>strunique</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strunique (
    char *string,
    char  unique)
</PRE>
<H4>Synopsis</H4>
<P>Reduces chains of some character to a single instances. For
   example: replace multiple spaces by one space. Returns string.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char
        *from,
        *to;

    ASSERT (string);
    if (strnull (string))
        return (string);                /*  Get rid of special cases         */

    from = string + 1;
    to   = string;
    while (*from)
      {
        if (*from == unique &amp;&amp; *to == unique)
            from++;
        else
            *++to = *from++;
      }
    *++to = '\0';
    return (string);
}
</PRE>
<A NAME="strmatch">&nbsp;</A>
<H3><A NAME="TOC281"><TT>strmatch</TT></A></H3>
<PRE>
#include "sflstr.h"
int
strmatch (
    const char *string1,
    const char *string2)
</PRE>
<H4>Synopsis</H4>
<P>Calculates a similarity index for the two strings. This is a
   value from 0 to 32767 with higher values indicating a closer
   match. The two strings are compared without regard for case.
   The algorithm was designed by Leif Svalgaard <A
   HREF=mailto:"leif@ibm.net">leif@ibm.net</A>.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    static int
        name_weight [30] = {
            20, 15, 13, 11, 10, 9, 8, 8, 7, 7, 7, 6, 6, 6, 6,
             6,  5,  5,  5,  5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4
        };
    int
        comp_index,
        name_index,
        start_of_string,
        longest_so_far,
        substring_contribution,
        substring_length,
        compare_length,
        longest_length,
        length_difference,
        name_length,
        char_index,
        similarity_index,
        similarity_weight;
    char
        cur_name_char;

    ASSERT (string1);
    ASSERT (string2);

    name_length    = strlen (string1);
    compare_length = strlen (string2);
    if (name_length &gt; compare_length)
      {
        length_difference = name_length - compare_length;
        longest_length    = name_length;
      }
    else
      {
        length_difference = compare_length - name_length;
        longest_length    = compare_length;
      }
    if (compare_length)
      {
        similarity_weight = 0;
        substring_contribution = 0;

        for (char_index = 0; char_index &lt; name_length; char_index++)
          {
            start_of_string = char_index;
            cur_name_char   = (char) tolower (string1 [char_index]);
            longest_so_far  = 0;
            comp_index      = 0;

            while (comp_index &lt; compare_length)
              {
                while ((comp_index &lt; compare_length)
                &amp;&amp;     (tolower (string2 [comp_index]) != cur_name_char))
                    comp_index++;

                substring_length = 0;
                name_index = start_of_string;

                while ((comp_index &lt; compare_length)
                &amp;&amp;     (tolower (string2 [comp_index])
                     == tolower (string1 [name_index])))
                  {
                    if (comp_index == name_index)
                        substring_contribution++;
                    comp_index++;
                    if (name_index &lt; name_length)
                      {
                        name_index++;
                        substring_length++;
                      }
                  }
                substring_contribution += (substring_length + 1) * 3;
                if (longest_so_far &lt; substring_length)
                    longest_so_far = substring_length;
              }
            similarity_weight += (substring_contribution
                                  + longest_so_far + 1) * 2;
            similarity_weight /= name_length + 1;
          }
        similarity_index  = (name_length &lt; 30? name_weight [name_length]: 3)
                          * longest_length;
        similarity_index /= 10;
        similarity_index += 2 * length_difference / longest_length;
        similarity_index  = 100 * similarity_weight / similarity_index;
      }
    else
        similarity_index = 0;

    return (similarity_index);
}
</PRE>
<A NAME="strprefixed">&nbsp;</A>
<H3><A NAME="TOC282"><TT>strprefixed</TT></A></H3>
<PRE>
#include "sflstr.h"
Bool
strprefixed (
    const char *string,
    const char *prefix)
</PRE>
<H4>Synopsis</H4>
<P>If string starts with specified prefix, returns TRUE. If string
   does not start with specified prefix, returns FALSE.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    ASSERT (string);
    ASSERT (prefix);

    if (*string == *prefix              /*  Check that first letters match   */
    &amp;&amp;  strlen (string) &gt;= strlen (prefix)
    &amp;&amp;  memcmp (string, prefix, strlen (prefix)) == 0)
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="strprefix">&nbsp;</A>
<H3><A NAME="TOC283"><TT>strprefix</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strprefix (
    const char *string,
    const char *delims)
</PRE>
<H4>Synopsis</H4>
<P>Looks for one of the delimiter characters in the string; if
   found, returns a string that contains the text up to that
   delimiter. If not found, returns NULL. The returned string can
   be zero or more characters long followed by a null byte. It is
   allocated using the mem_alloc() function; you should free it
   using mem_free() when finished.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    const char
        *nextch;
    char
        *token;
    int
        token_size;

    ASSERT (string);
    ASSERT (delims);

    for (nextch = string; *nextch; nextch++)
      {
        if (strchr (delims, *string))   /*  Is next character a delimiter    */
          {
            token_size = (int) (nextch - string);
            token = mem_alloc (token_size + 1);
            if (token == NULL)
                return (NULL);          /*  Not enough memory - fail         */
            memcpy (token, string, token_size);
            token [token_size] = 0;
            return (token);
          }
      }
    return (NULL);
}
</PRE>
<A NAME="strdefix">&nbsp;</A>
<H3><A NAME="TOC284"><TT>strdefix</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strdefix (
    const char *string,
    const char *prefix)
</PRE>
<H4>Synopsis</H4>
<P>If string starts with specified prefix, returns pointer to
   character after prefix. Null character is not considered part
   of the prefix. If string does not start with specified prefix,
   returns NULL.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    ASSERT (string);
    ASSERT (prefix);

    if (strlen (string) &gt;= strlen (prefix)
    &amp;&amp;  memcmp (string, prefix, strlen (prefix)) == 0)
        return ((char *) string + strlen (prefix));
    else
        return (NULL);
}
</PRE>
<A NAME="strhash">&nbsp;</A>
<H3><A NAME="TOC285"><TT>strhash</TT></A></H3>
<PRE>
#include "sflstr.h"
qbyte
strhash (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P> Calculates a 32-bit hash value for the string. The string must
   end in a null. To use the result as a hash key, take the modulo
   over the hash table size. The algorithm was designed by Peter
   Weinberger. This version was adapted from Dr Dobb's Journal
   April 1996 page 26.
<H4>Examples</H4>
<PRE>
    int index;
    index = (int) strhash (name) % TABLE_SIZE;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    qbyte
        high_bits,
        hash_value = 0;

    ASSERT (string);
    while (*string)
      {
        hash_value = (hash_value &lt;&lt; 4) + *string++;
        if ((high_bits = hash_value &amp; 0xF0000000L) != 0)
            hash_value ^= high_bits &gt;&gt; 24;
        hash_value &amp;= ~high_bits;
      }
    return (hash_value);
}
</PRE>
<A NAME="strconvch">&nbsp;</A>
<H3><A NAME="TOC286"><TT>strconvch</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
strconvch (
    char *string,
    char from,
    char to)
</PRE>
<H4>Synopsis</H4>
<P>Converts all instances of one character in a string to some
   other character. Returns string. Does nothing if the string is
   NULL.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char *scan;

    if (string)
      {
        scan = string;
        while (*scan)
          {
            if (*scan == from)
               *scan = to;
            scan++;
          }
      }
    return (string);
}
</PRE>
<A NAME="xstrcat">&nbsp;</A>
<H3><A NAME="TOC287"><TT>xstrcat</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
xstrcat (
    char *dest,
    const char *src, ...)
</PRE>
<H4>Synopsis</H4>
<P>Concatenates multiple strings into a single result. Eg.
   <A HREF="sfldoc.htm#xstrcat">xstrcat</A> (buffer, "A", "B", NULL) stores "AB" in buffer.
   Returns dest. Append the string to any existing contents of
   dest. From DDJ Nov 1992 p. 155, with adaptions.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char
        *feedback = dest;
    va_list
        va;

    ASSERT (dest);
    while (*dest)                       /*  Find end of dest string          */
        dest++;

    va_start (va, src);
    while (src)
      {
        while (*src)
            *dest++ = *src++;
        src = va_arg (va, char *);
      }
    *dest = '\0';                       /*  Append a null character          */
    va_end (va);
    return (feedback);
}
</PRE>
<A NAME="xstrcpy">&nbsp;</A>
<H3><A NAME="TOC288"><TT>xstrcpy</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
xstrcpy (
    char *dest,
    const char *src, ...)
</PRE>
<H4>Synopsis</H4>
<P>Concatenates multiple strings into a single result. Eg.
   <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (buffer, "A", "B", NULL) stores "AB" in buffer.
   Returns dest. Any existing contents of dest are cleared. If the
   dest buffer is NULL, allocates a new buffer with the required
   length and returns that. The buffer is allocated using
   mem_alloc(), and should eventually be freed using mem_free() or
   mem_strfree(). Returns NULL if there was too little memory to
   allocate the new string. We can't define macros with variable
   argument lists, so we pass the file and line number through two
   globals, xstrcpy_file and xstrcpy_line, which are reset to
   empty values after each call to xstrcpy.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    const char
        *src_ptr;
    va_list
        va;
    size_t
        dest_size;                      /*  Size of concatenated strings     */

    /*  Allocate new buffer if necessary                                     */
    if (dest == NULL)
      {
        va_start (va, src);             /*  Start variable args processing   */
        src_ptr   = src;
        dest_size = 1;                  /*  Allow for trailing null char     */
        while (src_ptr)
          {
            dest_size += strlen (src_ptr);
            src_ptr = va_arg (va, char *);
          }
        va_end (va);                    /*  End variable args processing     */

        /*  Allocate by going directly to mem_alloc_ function                */
        dest = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (NULL, dest_size, xstrcpy_file, xstrcpy_line);
        xstrcpy_file = "";
        xstrcpy_line = 0;
        if (dest == NULL)
            return (NULL);              /*  Not enough memory                */
      }

    /*  Now copy strings into destination buffer                             */
    va_start (va, src);                 /*  Start variable args processing   */
    src_ptr  = src;
    dest [0] = '\0';
    while (src_ptr)
      {
        strcat (dest, src_ptr);
        src_ptr = va_arg (va, char *);
      }
    va_end (va);                        /*  End variable args processing     */
    return (dest);
}
</PRE>
<A NAME="lexcmp">&nbsp;</A>
<H3><A NAME="TOC289"><TT>lexcmp</TT></A></H3>
<PRE>
#include "sflstr.h"
int
lexcmp (
    const char *string1,
    const char *string2)
</PRE>
<H4>Synopsis</H4>
<P>Performs an unsigned comparison of two strings without regard
   to the case of any letters in the strings. Returns a value that
   is <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>&lt; 0</B>
   <TD ALIGN="LEFT">if string1 is less than string2 <TR><TD
   ALIGN="LEFT"><B>== 0</B>  <TD ALIGN="LEFT">if string1 is equal
   to string2 <TR><TD ALIGN="LEFT"><B>&gt; 0</B>  <TD
   ALIGN="LEFT">if string1 is greater than string2 </TABLE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    int cmp;

    ASSERT (string1);
    ASSERT (string2);

    do
      {
        cmp = (byte) tolower (*string1) - (byte) tolower (*string2);
      }
    while (*string1++ &amp;&amp; *string2++ &amp;&amp; cmp == 0);
    return (cmp);
}
</PRE>
<A NAME="lexncmp">&nbsp;</A>
<H3><A NAME="TOC290"><TT>lexncmp</TT></A></H3>
<PRE>
#include "sflstr.h"
int
lexncmp (
    const char *string1,
    const char *string2,
    const int   count)
</PRE>
<H4>Synopsis</H4>
<P>Performs an unsigned comparison of two strings without regard
   to the case of specified number of letters in the strings.
   Returns a value that is <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>&lt; 0</B>  <TD ALIGN="LEFT">if string1 is less
   than string2 <TR><TD ALIGN="LEFT"><B>== 0</B>  <TD
   ALIGN="LEFT">if string1 is equal to string2 <TR><TD
   ALIGN="LEFT"><B>&gt; 0</B>  <TD ALIGN="LEFT">if string1 is
   greater than string2 </TABLE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    int
        cmp;
    char
        *end;

    ASSERT (string1);
    ASSERT (string2);

    end = (char *)string1 + count;
    do
      {
        cmp = (byte) tolower (*string1) - (byte) tolower (*string2);
      }
    while (*string1++ &amp;&amp; *string2++ &amp;&amp; cmp == 0 &amp;&amp; string1 &lt; end);
    return (cmp);
}
</PRE>
<A NAME="lexwcmp">&nbsp;</A>
<H3><A NAME="TOC291"><TT>lexwcmp</TT></A></H3>
<PRE>
#include "sflstr.h"
int
lexwcmp (
    const char *string1,
    const char *pattern)
</PRE>
<H4>Synopsis</H4>
<P>Compares two strings ignoring case, and allowing wildcards in
   the second string (the pattern). Two special characters are
   recognised in the pattern: '?' matches any character in the
   string, and '*' matches the remainder of the string. Returns a
   value that is: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>&lt; 0</B>  <TD ALIGN="LEFT">if string1 is less
   than pattern <TR><TD ALIGN="LEFT"><B>== 0</B>  <TD
   ALIGN="LEFT">if string1 is equal to pattern <TR><TD
   ALIGN="LEFT"><B>&gt; 0</B>  <TD ALIGN="LEFT">if string1 is
   greater than pattern </TABLE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    int cmp = 0;

    ASSERT (string1);
    ASSERT (pattern);

    do
      {
        if (*pattern != '?' &amp;&amp; *pattern != '*')
            cmp = (byte) tolower (*string1) - (byte) tolower (*pattern);
      }
    while (*string1++ &amp;&amp; *pattern++ &amp;&amp; cmp == 0 &amp;&amp; *pattern != '*');
    return (cmp);
}
</PRE>
<A NAME="soundex">&nbsp;</A>
<H3><A NAME="TOC292"><TT>soundex</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
soundex (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the SOUNDEX code for the string. Returns the address
   of a static area that holds the code. This area is overwritten
   by each call to the soundex function. The SOUNDEX encoding
   converts letters to uppercase, and translates each letter
   according to this table: A0 B1 C2 D3 E0 F1 G2 H0 I0 J2 K2 L4 M5
   N5 O0 P1 Q2 R6 S2 T3 U0 V1 W0 X2 Y0 Z2. Non-letters are
   ignored, letters that translate to zero, and multiple
   occurences of the same value are also ignored. This function
   always returns a 4-letter encoding: the first letter of the
   string followed by the first three significant digits.
<H4>Examples</H4>
<PRE>
    printf ("Soundex of %s = %s\n", argv [1], soundex (argv [1]));
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    ASSERT (string);
    return (<A HREF="sfldoc.htm#soundexn">soundexn</A> (string, 4, FALSE));
}
</PRE>
<A NAME="soundexn">&nbsp;</A>
<H3><A NAME="TOC293"><TT>soundexn</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
soundexn (
    const char *string, int size, Bool fold)
</PRE>
<H4>Synopsis</H4>
<P>Calculates the SOUNDEX code for the string. Returns the address
   of a static area that holds the code. This area is overwritten
   by each call to the soundex function. The SOUNDEX encoding
   converts letters to uppercase, and translates each letter
   according to this table: A0 B1 C2 D3 E0 F1 G2 H0 I0 J2 K2 L4 M5
   N5 O0 P1 Q2 R6 S2 T3 U0 V1 W0 X2 Y0 Z2. Non-letters are
   ignored, letters that translate to zero, and multiple
   occurences of the same value are also ignored. This function
   returns a N-letter encoding: the first letter of the string
   followed by the first N-1 significant digits. N may not be
   greater than SOUNDEX_MAX (100). If the fold argument is true,
   includes the first letter in the calculated digits, else starts
   with the second letter.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
#   define SOUNDEX_MAX  100
#   define SOUNDEX_TABLE                           "00000000000000000000000000000000"         "00000000000000000000000000000000"         "00123012002245501262301020200000"         "00123012002245501262301020200000"         "00000000000000000000000000000000"         "00000000000000000000000000000000"         "00000000000000000000000000000000"         "00000000000000000000000000000000"

    static char
       *soundex_table = SOUNDEX_TABLE,  /*  ASCII-SOUNDEX conversion         */
        soundex_code [SOUNDEX_MAX + 1]; /*  Letter + 3 digits                */
    int
        index;
    char
        last_value = 0,
        this_value;

    ASSERT (string);
    ASSERT (size &gt; 0 &amp;&amp; size &lt;= SOUNDEX_MAX);

    /*  Initialise the soundex code to a string of zeroes                    */
    memset (soundex_code, '0', size);
    soundex_code [size] = '\0';

    soundex_code [0] = toupper (*string);
    last_value = fold? 0: soundex_table [(byte) *string];
    index = 1;                          /*  Store results at [index]         */
    while (*string)
      {
        this_value = soundex_table [(byte) *string++];
        if (this_value == last_value    /*  Ignore doubles                   */
        ||  this_value == '0')          /*    and 'quiet' letters            */
          {
            last_value = this_value;
            continue;
          }
        last_value = this_value;
        soundex_code [index++] = this_value;
        if (index == size)              /*  Up to size result characters     */
            break;
      }
    return (soundex_code);
}
</PRE>
<A NAME="strt2descr">&nbsp;</A>
<H3><A NAME="TOC294"><TT>strt2descr</TT></A></H3>
<PRE>
#include "sflstr.h"
DESCR *
strt2descr (
    char **table)
</PRE>
<H4>Synopsis</H4>
<P>Converts a table of strings into a single block of memory. The
   input table consists of an array of null-terminated strings,
   terminated in a null pointer. Returns the address of a DESCR
   block defined as: "typedef struct {size_t size; byte *data}
   DESCR;". Allocates the descriptor block using the mem_alloc()
   function; you must free it using mem_free() when you are
   finished with it. The strings are packed into the descriptor
   data field, each terminated by a null byte. The final string is
   terminated by two nulls. The total size of the descriptor is
   descr-&gt; size + sizeof (DESCR). Note that if you omit the
   last null pointer in the input table, you will probably get an
   addressing error. Returns NULL if there was insufficient memory
   to allocate the descriptor block.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    DESCR
        *descr;                         /*  Allocated descriptor             */
    char
        *descr_ptr;                     /*  Pointer into block               */
    size_t
        descr_size;                     /*  Size of table                    */
    int
        string_nbr;                     /*  Index into string table          */

    ASSERT (table);

    /*  Calculate the size of the descriptor                                 */
    descr_size = 1;                     /*  Allow for final null byte        */
    for (string_nbr = 0; table [string_nbr]; string_nbr++)
        descr_size += strlen (table [string_nbr]) + 1;

    /*  Allocate a descriptor and fill it with the strings                   */
    descr = mem_alloc (descr_size + sizeof (DESCR));
    if (descr)
      {
        descr-&gt; size = descr_size;
        descr-&gt; data = (byte *) descr + sizeof (DESCR);
        descr_ptr    = (char *) descr-&gt; data;

        for (string_nbr = 0; table [string_nbr]; string_nbr++)
          {
            strcpy (descr_ptr, table [string_nbr]);
            descr_ptr += strlen (descr_ptr) + 1;
          }
        *descr_ptr = '\0';              /*  Add a null string                */
      }
    return (descr);
}
</PRE>
<A NAME="descr2strt">&nbsp;</A>
<H3><A NAME="TOC295"><TT>descr2strt</TT></A></H3>
<PRE>
#include "sflstr.h"
char **
descr2strt (
    const DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Takes a descriptor prepared by <A HREF="sfldoc.htm#strt2descr">strt2descr</A>() and returns an
   array of strings pointers, terminated in a null pointer. The
   array is allocated using the mem_alloc() function. Each string
   is individually allocated. Thus, to free the string table you
   must call mem_free() for each entry in the table, except the
   last one, and then for the table. You can also call
   <A HREF="sfldoc.htm#strtfree">strtfree</A>() to destroy the table in a single operation.
   Returns NULL if there was insufficient memory to allocate the
   table of strings.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    char
        **table;
    int
        string_count,
        string_nbr;                     /*  Index into string table          */
    char
        *descr_ptr;                     /*  Pointer into block               */

    ASSERT (descr);

    /*  Count the number of strings in the table                             */
    descr_ptr = (char *) descr-&gt; data;
    string_count = 0;
    while (*descr_ptr)                  /*  Loop until we hit null string    */
      {
        string_count++;
        descr_ptr += strlen (descr_ptr) + 1;
      }

    /*  Allocate a table and fill it with the strings                        */
    table = mem_alloc ((string_count + 1) * sizeof (char *));
    if (table)
      {
        descr_ptr = (char *) descr-&gt; data;
        for (string_nbr = 0; string_nbr &lt; string_count; string_nbr++)
          {
            table [string_nbr] = mem_strdup (descr_ptr);
            descr_ptr += strlen (descr_ptr) + 1;
          }
        table [string_count] = NULL;    /*  Store final null pointer         */
      }
    return (table);
}
</PRE>
<A NAME="strtfree">&nbsp;</A>
<H3><A NAME="TOC296"><TT>strtfree</TT></A></H3>
<PRE>
#include "sflstr.h"
void
strtfree (
    char **table)
</PRE>
<H4>Synopsis</H4>
<P>Releases a table of strings as created by <A HREF="sfldoc.htm#descr2strt">descr2strt</A>() or a
   similar function. If the argument is null, does nothing.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    int
        string_nbr;                     /*  Index into string array          */

    if (table)
      {
        for (string_nbr = 0; table [string_nbr]; string_nbr++)
            mem_free (table [string_nbr]);
        mem_free (table);
      }
}
</PRE>
<A NAME="removechars">&nbsp;</A>
<H3><A NAME="TOC297"><TT>removechars</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
removechars (
    char *strbuf,
    char *chrstorm)
</PRE>
<H4>Synopsis</H4>
<P>Removes known chars from a string. Returns pointer to head of
   the buffer. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset;

   offset = (char *)NULL;

   while (*strbuf)
      {
         offset = strpbrk (strbuf, chrstorm);
         if (offset)
             strcpy (offset, (offset + 1));
         else
             break;
      }

   return strbuf;
}
</PRE>
<A NAME="replacechrswith">&nbsp;</A>
<H3><A NAME="TOC298"><TT>replacechrswith</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
replacechrswith (
    char *strbuf,
    char *chrstorm,
    char chartorlcwith)
</PRE>
<H4>Synopsis</H4>
<P>Subsitutes known char(s)in a string with another. Returns
   pointer to head of the buffer. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset;

   offset = (char *)NULL;

   while (*strbuf)
      {
         offset = strpbrk (strbuf, chrstorm);
         if (offset)
           {
             *(offset)= chartorlcwith;
           }

         else
             break;
      }

   return strbuf;
}
</PRE>
<A NAME="insertstring">&nbsp;</A>
<H3><A NAME="TOC299"><TT>insertstring</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
insertstring (
    char *strbuf,
    char *chrstoins,
    int pos)
</PRE>
<H4>Synopsis</H4>
<P>Inserts a string into another string. Returns a pointer to head
   of the buffer. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   memmove ((strbuf + pos)+ strlen (chrstoins),
   (strbuf + pos), strlen ((strbuf + pos))+ 1);
   memcpy ((strbuf + pos), chrstoins, strlen (chrstoins));

   return strbuf;
}
</PRE>
<A NAME="insertchar">&nbsp;</A>
<H3><A NAME="TOC300"><TT>insertchar</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
insertchar (
    char *strbuf,
    char chrtoins,
    int pos)
</PRE>
<H4>Synopsis</H4>
<P>Inserts a char into a string. Returns a pointer to head of the
   buffer. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   memmove ((strbuf + pos)+ 1,
   (strbuf + pos), strlen ((strbuf + pos))+ 1);
   *(strbuf + pos)= chrtoins;

   return strbuf;
}
</PRE>
<A NAME="leftfill">&nbsp;</A>
<H3><A NAME="TOC301"><TT>leftfill</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
leftfill (
    char *strbuf,
    char chrtofill,
    unsigned len)
</PRE>
<H4>Synopsis</H4>
<P>Pads a string to the left, to a know length, with the given
   char value. Returns a pointer to head of the buffer. Submitted
   by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   while (strlen (strbuf)&lt; len)
     {
       <A HREF="sfldoc.htm#insertchar">insertchar</A> (strbuf, chrtofill, 0);
     }

   return strbuf;
}
</PRE>
<A NAME="rightfill">&nbsp;</A>
<H3><A NAME="TOC302"><TT>rightfill</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
rightfill (
    char *strbuf,
    char chrtofill,
    unsigned len)
</PRE>
<H4>Synopsis</H4>
<P>Pads a string to the right, to a known length, with the given
   char value. Returns a pointer to head of the buffer. Submitted
   by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   while (strlen (strbuf)&lt; len)
     {
       <A HREF="sfldoc.htm#insertchar">insertchar</A> (strbuf, chrtofill, strlen (strbuf));
     }

   return strbuf;
}
</PRE>
<A NAME="trim">&nbsp;</A>
<H3><A NAME="TOC303"><TT>trim</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
trim (
    char *strin)
</PRE>
<H4>Synopsis</H4>
<P>Eats the whitespace's from the left and right side of a string.
   This function maintains a proper pointer head. Returns a
   pointer to head of the buffer. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
    <A HREF="sfldoc.htm#ltrim">ltrim</A> (strin);
    <A HREF="sfldoc.htm#strcrop">strcrop</A> (strin);

    return strin;
}
</PRE>
<A NAME="ltrim">&nbsp;</A>
<H3><A NAME="TOC304"><TT>ltrim</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
ltrim (
    char *string)
</PRE>
<H4>Synopsis</H4>
<P>Deletes leading white spaces in string, and returns a pointer
   to the first non-blank character. If this is a null, the end of
   the string was reached.
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   ASSERT (string);

   while (isspace(*string))
       deletechar(string,0);

   return string;
}
</PRE>
<A NAME="searchreplace">&nbsp;</A>
<H3><A NAME="TOC305"><TT>searchreplace</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
searchreplace (
    char *strbuf,
    char *strtofnd,
    char *strtoins)
</PRE>
<H4>Synopsis</H4>
<P>A case insensitive search and replace. Searches for all
   occurances of a string, and replaces it with another string.
   Returns a pointer to head of the buffer. Submitted by Scott
   Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset, *strbase;

   offset = strbase = (char *)NULL;

   while (*strbuf)
     {
       offset = <A HREF="sfldoc.htm#stricstr">stricstr</A> (!offset ? strbuf : strbase, strtofnd);
       if (offset)
         {
           strbase = (offset + strlen (strtoins));
           strcpy (offset, (offset + strlen (strtofnd)));
           memmove (offset + strlen (strtoins),
                     offset, strlen (offset) + 1);
           memcpy (offset, strtoins, strlen (strtoins));
         }

      else
           break;
     }

   return strbuf;
}
</PRE>
<A NAME="deletestring">&nbsp;</A>
<H3><A NAME="TOC306"><TT>deletestring</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
deletestring (
    char *strbuf,
    char *strtodel,
    int ignorecase)
</PRE>
<H4>Synopsis</H4>
<P>Deletes all occurances of one string, in another string.
   Returns a pointer to head of the buffer. Submitted by Scott
   Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset;

   offset = (char *)NULL;

   while (*strbuf)
     {
        if (!ignorecase)
            offset = <A HREF="sfldoc.htm#stricstr">stricstr</A> (strbuf, strtodel);
        else
            offset = strstr (strbuf, strtodel);
        if (offset)
          {
            strcpy (offset, (offset + strlen (strtodel)));
          }
        else
            break;
     }

   return strbuf;
}
</PRE>
<A NAME="getstrfld">&nbsp;</A>
<H3><A NAME="TOC307"><TT>getstrfld</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
getstrfld (
    char *strbuf,
    int fldno,
    int ofset,
    char *sep,
    char *retstr)
</PRE>
<H4>Synopsis</H4>
<P>Gets a sub-string from a formated string. nice strtok
   replacement. usage: char strarray[] = { "123,456,789,abc" };
   char strretbuff[4]; <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strarray, 2, 0, ",",
   strretbuff); This would return the string "789" and place it
   also in strretbuff. Returns a NULL if fldno is out of range,
   else returns a pointer to head of the buffer. Submitted by
   Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset, *strptr;
   int curfld;

   offset = strptr = (char *)NULL;
   curfld = 0;

   strbuf += ofset;

   while (*strbuf)
     {
       strptr = !offset ? strbuf : offset;
       offset = strpbrk ((!offset ? strbuf : offset), sep);

       if (offset)
          offset++;
       else if (curfld != fldno)
         {
           *retstr = (char)NULL;
           break;
         }

       if (curfld == fldno)
         {
           strncpy (retstr, strptr,
              (int)(!offset ? strlen (strptr)+ 1 :
              (int)(offset - strptr)));
           if (offset)
              retstr[offset - strptr - 1] = 0;

           break;
         }
       curfld++;
     }
   return retstr;
}
</PRE>
<A NAME="setstrfld">&nbsp;</A>
<H3><A NAME="TOC308"><TT>setstrfld</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
setstrfld (
    char *strbuf,
    int fldno,
    int ofset,
    char *sep,
    char *strtoins)
</PRE>
<H4>Synopsis</H4>
<P>Inserts a string into a fomated string. usage: char
   strsrray[26] = { "this is a test." }; <A HREF="sfldoc.htm#setstrfld">setstrfld</A> (strsrray,
   2, 0, " ", "big "); result: this is a big test. Does nothing if
   fldno is out of range, else returns pointer to head of the
   buffer. Returns a pointer to head of the buffer. Submitted by
   Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset, *strptr, *strhead;
   int curfld;

   offset = strptr = (char *)NULL;
   curfld = 0;

   strhead = strbuf;
   strbuf += ofset;

   while (*strbuf)
     {
       strptr = !offset ? strbuf : offset;
       offset = strpbrk ((!offset ? strbuf : offset), sep);

       if (offset)
          offset++;

       if (curfld == fldno)
          {
            <A HREF="sfldoc.htm#insertstring">insertstring</A> (strptr, strtoins,
               (int)(!offset ? strlen (strptr):
               (int)(offset - strptr)));
            break;
          }
       curfld++;
     }

   return strhead;
}
</PRE>
<A NAME="getstrfldlen">&nbsp;</A>
<H3><A NAME="TOC309"><TT>getstrfldlen</TT></A></H3>
<PRE>
#include "sflstr.h"
int
getstrfldlen (
    char *strbuf,
    int fldno,
    int ofset,
    char *sep)
</PRE>
<H4>Synopsis</H4>
<P>Get the length of as a field in a string. Used mainly for
   getting the len to malloc mem to call getstrfld with. Returns
   the length of the field. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *offset, *strptr;
   int curfld, retlen = 0;

   offset = strptr = (char *)NULL;
   curfld = 0;

   strbuf += ofset;

   while (*strbuf)
     {
       strptr = !offset ? strbuf : offset;
       offset = strpbrk ((!offset ? strbuf : offset), sep);

       if (offset)
          offset++;
       else if (curfld != fldno)
         {
           retlen = 0;
           break;
         }
       if (curfld == fldno)
         {
           retlen = (int)(!offset ? strlen (strptr) + 1 :
                    (int)(offset - strptr));
           break;
         }
       curfld++;
     }
   return retlen;
}
</PRE>
<A NAME="findstrinfile">&nbsp;</A>
<H3><A NAME="TOC310"><TT>findstrinfile</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
findstrinfile (
    FILE *fp,
    char *strtofind,
    char *strretstr,
    int *iLnNo)
</PRE>
<H4>Synopsis</H4>
<P> Find's a string inside a text file and reads the line in and
   sets the file pointer to the beginning of that line. Assumes
   the line length to be &lt;= 1024 bytes. Returns a pointer to
   head of the return buffer, and the file postion will be at the
   start of the found string. If the strretstr param is != NULL
   then strretstr will contain the line that the search string was
   found in. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char strline[1025];
   int nfnd = 0;
   long lfpos;

   if (strretstr)
       *strretstr = 0;

   while (1)
     {
       lfpos = ftell (fp);
       fgets (strline, 1024, fp);
       <A HREF="sfldoc.htm#trim">trim</A> (strline);

       if (!*strline)
          continue;

       if (iLnNo)
           (*iLnNo)++;

       if (<A HREF="sfldoc.htm#stricstr">stricstr</A> (strline, strtofind))
         {
           if (strretstr)
             {
               strcpy (strretstr, strline);
             }

           fseek (fp, lfpos, SEEK_SET);
           nfnd = 1;
           break;
         }

       if (feof (fp))
           break;
     }

   if (strretstr)
       return strretstr;
   else
       return (char *)nfnd;
}
</PRE>
<A NAME="getequval">&nbsp;</A>
<H3><A NAME="TOC311"><TT>getequval</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
getequval (
    char *strline,
    char *strretstr)
</PRE>
<H4>Synopsis</H4>
<P> get the everything on a line past a '='.
<H4>Examples</H4>
<PRE>
       char strtest[] = { "progpath=c:\sfl");
       char strret[256];
       getequval (strtest, strret);

    This would return: "c:\sfl".  Returns a pointer to head of the
    return buffer.  Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *stroffset;

   stroffset = strstr (strline, "=");

   if (stroffset)
       <A HREF="sfldoc.htm#ltrim">ltrim</A> ((stroffset + 1));
   else
       return (char *)NULL;

   return strcpy (strretstr,
   (stroffset &amp;&amp; *(stroffset + 1))? (stroffset + 1): "");
}
</PRE>
<A NAME="matchtable">&nbsp;</A>
<H3><A NAME="TOC312"><TT>matchtable</TT></A></H3>
<PRE>
#include "sflstr.h"
int
matchtable (
    char *strbuf,
    char *strmatch,
    char *strsept,
    int ncase)
</PRE>
<H4>Synopsis</H4>
<P> Function to compare a string with a set of strings.
<H4>Examples</H4>
<PRE>
       iret = matchtable (strname, "bill|william|billy", "|", IGNORECASE);

    If strname == "william", then matchtable would return 1.
    Returns &gt;= 0 if match is found.  a -1 if no match is found.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int nstate = -1, cnt = 0, icmpres;
   int ilen;
   char *strtemp;

   ASSERT (strbuf);
   ASSERT (strmatch);
   ASSERT (strsept);

   while (1)
     {
       ilen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strmatch, cnt, 0, strsept);
       strtemp = (char *) malloc (sizeof (char) * ilen + 1);
       ASSERT (strtemp);
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strmatch, cnt, 0, strsept, strtemp);
       if (*strtemp)
         {
           <A HREF="sfldoc.htm#trim">trim</A> (strtemp);
           if (!ncase)
             {
               icmpres = <A HREF="sfldoc.htm#lexcmp">lexcmp</A> (strbuf, strtemp);
             }
           else
             {
               icmpres = strcmp (strbuf, strtemp);
             }

           if (!icmpres)
             {
               nstate = cnt;
               break;
             }
           else
             {
               if (!strcmp (strbuf, strtemp))
                 {
                   nstate = cnt;
                   break;
                 }
             }
         }
       else
         {
           nstate = -1;
           break;
         }
       cnt++;
       free (strtemp);
     }

   return nstate;
}
</PRE>
<A NAME="stringreplace">&nbsp;</A>
<H3><A NAME="TOC313"><TT>stringreplace</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
stringreplace (
    char *strbuf,
    char *strpattern)
</PRE>
<H4>Synopsis</H4>
<P> This function searches for known strings, and replaces them
   with another string.
<H4>Examples</H4>
<PRE>
       stringreplace (strfilename, "sqv|sqr,ruv|run,h_v|h");

    This example would replace all occurences of sqv, with sqr, ruv with
    run and h_v with h. Returns pointer to head of the return buffer.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int ilen, ifld = 0;
   char *strsrch, *strrpl, *strpat;

   if (!strpattern)
       return strbuf;

   while (1)
     {
       ilen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strpattern, ifld, 0, ",");
       if (!ilen)
           break;
       strpat = (char *)malloc (ilen + 1);
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strpattern, ifld, 0, ",", strpat);
       ifld++;

       ilen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strpat, 0, 0, "|");
       strsrch = (char *)malloc (ilen + 1);
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strpat, 0, 0, "|", strsrch);

       ilen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strpat, 1, 0, "|");
       strrpl = (char *)malloc (ilen + 1);
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strpat, 1, 0, "|", strrpl);

       <A HREF="sfldoc.htm#searchreplace">searchreplace</A> (strbuf, strsrch, strrpl);

       free (strsrch);
       free (strrpl);
       free (strpat);
     }

   return strbuf;
}
</PRE>
<A NAME="wordwrapstr">&nbsp;</A>
<H3><A NAME="TOC314"><TT>wordwrapstr</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
wordwrapstr (
    char *strbuff,
    int iwid)
</PRE>
<H4>Synopsis</H4>
<P> Function that does word wraping of a string at or less than
   iwid. Breaks up a string on word boundaries by placing '\n' in
   the string. Returns a pointer to head of the return buffer.
   Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *strtmp = strbuff;
   int icnt = 0;

   <A HREF="sfldoc.htm#replacechrswith">replacechrswith</A> (strbuff, "\n", ' ');
   while (*strtmp)
     {
       if ((int)strlen (strtmp) &gt; (int)iwid)
         {
           icnt = iwid;
           while (*(strtmp + icnt))
             {
               if (strchr (" .?;!,", *(strtmp + icnt)))
                 {
                   <A HREF="sfldoc.htm#ltrim">ltrim</A> ((strtmp + icnt));
                   <A HREF="sfldoc.htm#insertchar">insertchar</A> (strtmp, '\n', icnt);
                   strtmp += icnt + 1;
                   break;
                 }
               icnt--;

               if (!icnt)
                 {
                   if (strchr (" .?;!,", *(strtmp + icnt)))
                     {
                       <A HREF="sfldoc.htm#ltrim">ltrim</A> ((strtmp + iwid));
                       <A HREF="sfldoc.htm#insertchar">insertchar</A> (strtmp, '\n', iwid);
                       strtmp += iwid + 1;
                       break;
                     }
                 }
             }
         }
       else
           break;
   }

   return strbuff;
}
</PRE>
<A NAME="stricstr">&nbsp;</A>
<H3><A NAME="TOC315"><TT>stricstr</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
stricstr (
    const char *str1,
    const char *str2)
</PRE>
<H4>Synopsis</H4>
<P> A case insensitive strstr. Returns a pointer to head of the
   str1. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   char *strtmp = (char *)str1;
   int iret = 1;

   while (*strtmp)
     {
       if (strlen (strtmp)&gt;= strlen (str2))
         {
           iret = <A HREF="sfldoc.htm#lexncmp">lexncmp</A> (strtmp, str2, strlen (str2));
         }
       else
         {
           break;
         }

       if (!iret)
         {
           break;
         }

       strtmp++;
     }

   return !iret ? strtmp : (char *)NULL;
}
</PRE>
<A NAME="strtempcmp">&nbsp;</A>
<H3><A NAME="TOC316"><TT>strtempcmp</TT></A></H3>
<PRE>
#include "sflstr.h"
int
strtempcmp (
    const char *str1,
    const char *strPat)
</PRE>
<H4>Synopsis</H4>
<P> Compares a string to a template. Template chars and there
   functions: # or 9 = Number. A or _ = Alpha. @ = Alphanumeric
   char = Literal. Char would be the literal to use. ie: "\%" -
   looks for a % in that postion Returns 0 if == to the template
   and 1 if != to the template. Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int ires = 1;

   while (*str1 &amp;&amp; *strPat)
     {
       switch ((int)*strPat)
         {
           case '#':
           case '9':
              ires = isdigit ((int)*str1);
              break;

           case 'A':
           case '_':
              ires = isalpha ((int)*str1);
              break;

           case '@':
              ires = isalnum ((int)*str1);
              break;

           case ' ':
              ires = isspace ((int)*str1);
              break;

           case '\\':
              strPat++;
              if (*str1 != *strPat)
                 {
                   ires = 1;
                 }
              break;

           default:
              break;
         }

       if (!ires)
         {
           break;
         }

       str1++;
       strPat++;
     }

   return ires ? 0 : 1;
}
</PRE>
<A NAME="istoken">&nbsp;</A>
<H3><A NAME="TOC317"><TT>istoken</TT></A></H3>
<PRE>
#include "sflstr.h"
int
istoken (
    char **strLine,
    const char *strtoken,
    int *iWasToken)
</PRE>
<H4>Synopsis</H4>
<P> Eats strToEat from strBuff only if it begins with contents of
   strToEat, and returns a 0 or 1 to tell what it did.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { "select * from mytbl;" };
       int iWasToken;
       istoken (&strBuff, "SELECT", &iWasToken);

    On return here iWasToken would == 1, and strBuff would be:
    " * from mytbl;"
    If the token is not found, then strBuff will not be affected, and
    a 0 will be returned.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int iRet;
   char cChar;

   iRet = <A HREF="sfldoc.htm#lexncmp">lexncmp</A> (*strLine, strtoken, strlen (strtoken));

   if (!iRet)
     {
       cChar = *(*strLine + strlen (strtoken));
       if (!isalpha ((int)cChar)&amp;&amp; cChar != '_')
         {
           iRet = *iWasToken = 1;
           strcpy (*strLine, (*strLine + strlen (strtoken)));
         }
       else
           iRet = *iWasToken = 0;
     }

   else
       iRet = *iWasToken = 0;

   return iRet;
}
</PRE>
<A NAME="eatstr">&nbsp;</A>
<H3><A NAME="TOC318"><TT>eatstr</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
eatstr (
    char **strBuff,
    char *strToEat)
</PRE>
<H4>Synopsis</H4>
<P> Eats strToEat from strBuff only if it begins with contents of
   strToEat.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { "select * from mytbl;" };
       eatstr (&strBuff, "SELECT");

       On return here strBuff would be: " * from mytbl;"

    If the token is not found, then strBuff will not be affected and
    a NULL char * will be returned, but any white spaces on the left
    of strBuff would be trimed.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int iWasToken;

   <A HREF="sfldoc.htm#ltrim">ltrim</A> (*strBuff);
   <A HREF="sfldoc.htm#istoken">istoken</A> (strBuff, strToEat, &amp;iWasToken);

   return iWasToken ? *strBuff : (char *)NULL;
}
</PRE>
<A NAME="eatstrpast">&nbsp;</A>
<H3><A NAME="TOC319"><TT>eatstrpast</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
eatstrpast (
    char **strBuff,
    char *strCharsToEatPast)
</PRE>
<H4>Synopsis</H4>
<P> Eats chars past first occurrence of one of the chars contained
   in strCharsToEatPast.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { " , 456, 789" };
       eatstrpast (&strBuff, ",");

    On return here strBuff would be: " 456, 789".
    Returns a pointer to head of the input buffer.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   <A HREF="sfldoc.htm#ltrim">ltrim</A> (*strBuff);
   while (**strBuff &amp;&amp; strchr (strCharsToEatPast, **strBuff))
       deletechar (*strBuff, 0);

   return *strBuff;
}
</PRE>
<A NAME="movestrpast">&nbsp;</A>
<H3><A NAME="TOC320"><TT>movestrpast</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
movestrpast (
    char **strBuff,
    char cCharToEatPast)
</PRE>
<H4>Synopsis</H4>
<P> Eats chars past first occurrence of one of the chars contained
   in strCharsToEatPast.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { "123, 456, 789" };
       movestrpast (&strBuff, ",");

    On return here strBuff would be: " 456, 789".
    Returns a pointer to head of the input buffer.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   <A HREF="sfldoc.htm#ltrim">ltrim</A> (*strBuff);
   while (**strBuff &amp;&amp; **strBuff != cCharToEatPast)
       deletechar (*strBuff, 0);

   if (**strBuff &amp;&amp; **strBuff == cCharToEatPast)
       deletechar (*strBuff, 0);

   return *strBuff;
}
</PRE>
<A NAME="eatchar">&nbsp;</A>
<H3><A NAME="TOC321"><TT>eatchar</TT></A></H3>
<PRE>
#include "sflstr.h"
char *
eatchar (
    char **strBuff,
    char cChar)
</PRE>
<H4>Synopsis</H4>
<P> Trims white spaces and eats just past occurrence of cChar. If
   contents of cChar is not found then only white spaces are
   trimmed.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { "('test', 5)" };
       eatchar (&strBuff, '(');
    On return here strBuff would be: "'test', 5)".
    Returns a pointer to head of the input buffer.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   <A HREF="sfldoc.htm#ltrim">ltrim</A> (*strBuff);
   if (**strBuff &amp;&amp; **strBuff == cChar)
       deletechar (*strBuff, 0);

   return *strBuff;
}
</PRE>
<A NAME="isoneoftokens">&nbsp;</A>
<H3><A NAME="TOC322"><TT>isoneoftokens</TT></A></H3>
<PRE>
#include "sflstr.h"
int
isoneoftokens (
    char **strbuf,
    char *strmat,
    char *strsep,
    int *iWasToken)
</PRE>
<H4>Synopsis</H4>
<P> Eats strToEat from strBuff only if it begins with contents of
   strToEat, and returns a 0 or 1 to tell what it did. Returns 0
   if nothing found, and &gt;= 1 which is an index of the one
   found.
<H4>Examples</H4>
<PRE>
       char strBuff[] = { "select * from mytbl;" };
       int iWasToken;
       isoneoftokens (&strBuff, "INSERT|SELECT|DELETE", "|", &iWasToken);

       On return here iWasToken would == 1, and strBuff would be:
       " * from mytbl;" and the return value would be 2.

    If the token is not found, then strBuff will not be affected, and
    a 0 will be returned.
    Submitted by Scott Beasley &lt;jscottb@infoave.com&gt;
</PRE>
<H4>Source Code - (sflstr.c)</H4>
<PRE>
{
   int nstate = 0, cnt = 0, icmpres;
   int iLen;
   char *strtemp, cChar;

   while (1)
     {
       iLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strmat, cnt, 0, strsep);
       strtemp = (char *) malloc (iLen + 1);
       <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strmat, cnt, 0, strsep, strtemp);
       if (*strtemp)
         {
           <A HREF="sfldoc.htm#trim">trim</A> (strtemp);
           icmpres = <A HREF="sfldoc.htm#lexncmp">lexncmp</A> (*strbuf, strtemp, strlen (strtemp));

           if (!icmpres)
             {
               cChar = *(*strbuf + strlen (strtemp));
               if (!isalpha ((int)cChar)&amp;&amp; cChar != '_')
                 {
                   *iWasToken = cnt + 1;
                   strcpy (*strbuf, (*strbuf + strlen (strtemp)));

                   nstate = cnt + 1;
                 }
               break;
             }

            else
              {
                if (!<A HREF="sfldoc.htm#lexncmp">lexncmp</A> (*strbuf, strtemp, strlen (strtemp)))
                  {
                    cChar = *(*strbuf + strlen (strtemp));
                    if (!isalpha ((int)cChar)&amp;&amp; cChar != '_')
                      {
                        *iWasToken = cnt + 1;
                        strcpy (*strbuf, (*strbuf + strlen (strtemp)));

                        nstate = cnt + 1;
                      }
                    break;
                  }
              }
         }

       else
         {
           *iWasToken = 0;
           nstate = 0;
           break;
         }

       cnt++;
       free (strtemp);
     }

   return nstate;
}
</PRE>
<H2><A NAME="TOC323">TCP/IP, UDP/IP socket functions</A></H2>
<P>Filename: sflsock.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/02/03 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/10/02
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to create, read, and write TCP and UDP
   sockets. Encapsulates system dependencies. Tested under MS
   Winsock, UNIX (Linux, AIX, SunOs), OpenVMS. Some of the code in
   this module was based on the book "Internetworking With TCP/IP
   Volume III: Client-Server Programming And Applications BSD
   Socket Version" by Douglas E. Comer and David L. Stevens,
   published 1993 by Prentice-Hall Inc. ISBN 0-13-020272-X.
   Defines sock_t which you should use for all sockets. If you
   need to call a native socket function, use a (SOCKET) cast on
   the sock_t handle.
<H4>List of Functions</H4>
<UL>
<LI>int <A HREF="sfldoc.htm#sock_init">sock init</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#sock_term">sock term</A><BR>
   (void);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#passive_TCP">passive TCP</A><BR>
   (const char *service, int queue);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#passive_UDP">passive UDP</A><BR>
   (const char *service);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#passive_socket">passive socket</A><BR>
   (const char *service, const char *protocol, int queue);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#connect_TCP">connect TCP</A><BR>
   (const char *host, const char *service);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#connect_UDP">connect UDP</A><BR>
   (const char *host, const char *service);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#connect_TCP_fast">connect TCP fast</A><BR>
   (const struct sockaddr_in *sin);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#connect_UDP_fast">connect UDP fast</A><BR>
   (const struct sockaddr_in *sin);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#connect_socket">connect socket</A><BR>
   (const char *host, const char *service, const char *protocol,
   const struct sockaddr_in *sin, int retry_max, int retry_delay);
</LI>
<LI>int <A HREF="sfldoc.htm#connect_to_peer">connect to peer</A><BR>
   (sock_t handle, const struct sockaddr_in *sin);
</LI>
<LI>int <A HREF="sfldoc.htm#connect_error">connect error</A><BR>
   (void);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#accept_socket">accept socket</A><BR>
   (sock_t master);
</LI>
<LI>sock_t <A HREF="sfldoc.htm#create_socket">create socket</A><BR>
   (const char *protocol);
</LI>
<LI>int <A HREF="sfldoc.htm#address_end_point">address end point</A><BR>
   (const char *host, const char *service, const char *protocol,
   struct sockaddr_in *sin);
</LI>
<LI>int <A HREF="sfldoc.htm#get_sock_addr">get sock addr</A><BR>
   (sock_t handle, struct sockaddr_in *sin, char *name, int
   namesize);
</LI>
<LI>int <A HREF="sfldoc.htm#get_peer_addr">get peer addr</A><BR>
   (sock_t handle, struct sockaddr_in *sin, char *name, int
   namesize);
</LI>
<LI>void <A HREF="sfldoc.htm#build_sockaddr">build sockaddr</A><BR>
   (struct sockaddr_in *sin, qbyte host, dbyte port);
</LI>
<LI>char * <A HREF="sfldoc.htm#socket_localaddr">socket localaddr</A><BR>
   (sock_t handle);
</LI>
<LI>char * <A HREF="sfldoc.htm#socket_peeraddr">socket peeraddr</A><BR>
   (sock_t handle);
</LI>
<LI>Bool <A HREF="sfldoc.htm#socket_is_alive">socket is alive</A><BR>
   (sock_t handle);
</LI>
<LI>int <A HREF="sfldoc.htm#socket_error">socket error</A><BR>
   (sock_t handle);
</LI>
<LI>int <A HREF="sfldoc.htm#socket_nodelay">socket nodelay</A><BR>
   (sock_t handle);
</LI>
<LI>int <A HREF="sfldoc.htm#read_TCP">read TCP</A><BR>
   (sock_t handle, void *buffer, size_t length);
</LI>
<LI>int <A HREF="sfldoc.htm#write_TCP">write TCP</A><BR>
   (sock_t handle, const void *buffer, size_t length);
</LI>
<LI>int <A HREF="sfldoc.htm#read_UDP">read UDP</A><BR>
   (sock_t handle, void *buffer, size_t length, const struct
   sockaddr_in *sin);
</LI>
<LI>int <A HREF="sfldoc.htm#write_UDP">write UDP</A><BR>
   (sock_t handle, const void *buffer, size_t length, const struct
   sockaddr_in *sin);
</LI>
<LI>int <A HREF="sfldoc.htm#close_socket">close socket</A><BR>
   (sock_t handle);
</LI>
<LI>int <A HREF="sfldoc.htm#sock_select">sock select</A><BR>
   (int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds,
   struct timeval *timeout);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_hostname">get hostname</A><BR>
   (void);
</LI>
<LI>qbyte <A HREF="sfldoc.htm#get_hostaddr">get hostaddr</A><BR>
   (void);
</LI>
<LI>qbyte * <A HREF="sfldoc.htm#get_hostaddrs">get hostaddrs</A><BR>
   (void);
</LI>
<LI>const char * <A HREF="sfldoc.htm#sockmsg">sockmsg</A><BR>
   (void);
</LI>
<LI>Bool <A HREF="sfldoc.htm#socket_is_permitted">socket is permitted</A><BR>
   (const char *address, const char *mask);
</LI>
<LI>char * <A HREF="sfldoc.htm#sock_ntoa">sock ntoa</A><BR>
   (qbyte address);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_host_file">get host file</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#get_name_server">get name server</A><BR>
   (struct sockaddr_in *ns_address, int ns_max);
</LI>
<LI>int <A HREF="sfldoc.htm#winsock_last_error">winsock last error</A><BR>
   (void);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflsock.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>AF_INET</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>DNS_PORT</B>  </TT>
<TD ALIGN="LEFT">53 /* Domain Name server port */
<TR><TD ALIGN="LEFT"><TT><B>EAGAIN</B>  </TT>
<TD ALIGN="LEFT">EWOULDBLOCK
<TR><TD ALIGN="LEFT"><TT><B>ECONNRESET</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>EINPROGRESS</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>EPIPE</B>  </TT>
<TD ALIGN="LEFT">-1
<TR><TD ALIGN="LEFT"><TT><B>EWOULDBLOCK</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FAKE_SOCKETS</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>FD_CLR(d,set)</B>  </TT>
<TD ALIGN="LEFT">((set)-&gt;__bits[__FDELT(d)] &= ~__FDMASK(d))
<TR><TD ALIGN="LEFT"><TT><B>FD_ISSET(d,set)</B>  </TT>
<TD ALIGN="LEFT">((set)-&gt;__bits[__FDELT(d)] & __FDMASK(d))
<TR><TD ALIGN="LEFT"><TT><B>FD_SET(d,set)</B>  </TT>
<TD ALIGN="LEFT">((set)-&gt;__bits[__FDELT(d)] |= __FDMASK(d))
<TR><TD ALIGN="LEFT"><TT><B>FD_SETSIZE</B>  </TT>
<TD ALIGN="LEFT">256
<TR><TD ALIGN="LEFT"><TT><B>FD_SETTYPE</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>FD_ZERO(set)</B>  </TT>
<TD ALIGN="LEFT">((void) memset((void *) (set), 0, sizeof(fd_set)))
<TR><TD ALIGN="LEFT"><TT><B>INADDR_ANY</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>INADDR_NONE</B>  </TT>
<TD ALIGN="LEFT">-1 /* constant */
<TR><TD ALIGN="LEFT"><TT><B>INVALID_SOCKET</B>  </TT>
<TD ALIGN="LEFT">(sock_t) -1 /* Invalid socket handle */
<TR><TD ALIGN="LEFT"><TT><B>IP_BADHOST</B>  </TT>
<TD ALIGN="LEFT">2 /* Host not known */
<TR><TD ALIGN="LEFT"><TT><B>IP_BADPROTOCOL</B>  </TT>
<TD ALIGN="LEFT">4 /* Invalid protocol specified */
<TR><TD ALIGN="LEFT"><TT><B>IP_BADSERVICE</B>  </TT>
<TD ALIGN="LEFT">3 /* Service or port not known */
<TR><TD ALIGN="LEFT"><TT><B>IP_BINDERROR</B>  </TT>
<TD ALIGN="LEFT">7 /* Error binding socket */
<TR><TD ALIGN="LEFT"><TT><B>IP_CONNECTERROR</B>  </TT>
<TD ALIGN="LEFT">6 /* Error making connection */
<TR><TD ALIGN="LEFT"><TT><B>IP_LISTENERROR</B>  </TT>
<TD ALIGN="LEFT">8 /* Error preparing to listen */
<TR><TD ALIGN="LEFT"><TT><B>IP_NOERROR</B>  </TT>
<TD ALIGN="LEFT">0 /* No errors */
<TR><TD ALIGN="LEFT"><TT><B>IP_NOSOCKETS</B>  </TT>
<TD ALIGN="LEFT">1 /* Sockets not supported */
<TR><TD ALIGN="LEFT"><TT><B>IP_SOCKETERROR</B>  </TT>
<TD ALIGN="LEFT">5 /* Error creating socket */
<TR><TD ALIGN="LEFT"><TT><B>MAXHOSTNAMELEN</B>  </TT>
<TD ALIGN="LEFT">256 /* constant */
<TR><TD ALIGN="LEFT"><TT><B>NFDBITS</B>  </TT>
<TD ALIGN="LEFT">(sizeof (unsigned long int) * 8)
<TR><TD ALIGN="LEFT"><TT><B>SOCKET_ERROR</B>  </TT>
<TD ALIGN="LEFT">-1 /* Error on socket function */
<TR><TD ALIGN="LEFT"><TT><B>SOCKET_LOOPBACK</B>  </TT>
<TD ALIGN="LEFT">0x7f000001L /* Loopback address 127.0.0.1 */
<TR><TD ALIGN="LEFT"><TT><B>_SFLSOCK_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>__FDELT(d)</B>  </TT>
<TD ALIGN="LEFT">((d) / NFDBITS)
<TR><TD ALIGN="LEFT"><TT><B>__FDMASK(d)</B>  </TT>
<TD ALIGN="LEFT">(1 &lt;&lt; ((d) % NFDBITS))
<TR><TD ALIGN="LEFT"><TT><B>htonl(x)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>htons(x)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>inet_addr(x)</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>inet_ntoa(x)</B>  </TT>
<TD ALIGN="LEFT">"127.0.0.1"
<TR><TD ALIGN="LEFT"><TT><B>ntohl(x)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>ntohs(x)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>select(n,rf,wf,xf,t)</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>sockerrno</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>socket_hostaddr(handle)</B>  </TT>
<TD ALIGN="LEFT">socket_peeraddr (handle)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SOCKET</B>  </TT>
<TD ALIGN="LEFT">int
<TR><TD ALIGN="LEFT"><TT><B>argsize_t</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>sock_t</B>  </TT>
<TD ALIGN="LEFT">qbyte
</TABLE>
<A NAME="sock_init">&nbsp;</A>
<H3><A NAME="TOC324"><TT>sock_init</TT></A></H3>
<PRE>
#include "sflsock.h"
int
sock_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialise the internet protocol. On most systems this is a
   null call. On some systems this loads dynamic libraries.
   Returns 0 0 if everything was okay, else returns SOCKET_ERROR.
   You should call <A HREF="sfldoc.htm#sock_term">sock term</A>() when your program ends.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (__WINDOWS__))
    WORD
        wVersionRequested;              /*  We really want Winsock 1.1       */
    WSADATA
        wsaData;

    wVersionRequested = 0x0101;         /*  ... but we'll take 1.1           */
    if (WSAStartup (wVersionRequested, &amp;wsaData) == 0)
        return (0);
    else
        return ((int) SOCKET_ERROR);

#elif (defined (DOES_SOCKETS))
    return (0);

#elif (defined (FAKE_SOCKETS))
    return (0);

#else
    connect_error_value = IP_NOSOCKETS;
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="sock_term">&nbsp;</A>
<H3><A NAME="TOC325"><TT>sock_term</TT></A></H3>
<PRE>
#include "sflsock.h"
int
sock_term (void)
</PRE>
<H4>Synopsis</H4>
<P>Shuts-down the internet protocol. On most systems this is a
   null call. On some systems this unloads dynamic libraries.
   Returns -1 if there was an error, or 0 if everything was okay.
   See <A HREF="sfldoc.htm#sock_init">sock init</A>().
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (__WINDOWS__))
    WSACleanup ();
#endif
    return (0);
}
</PRE>
<A NAME="passive_TCP">&nbsp;</A>
<H3><A NAME="TOC326"><TT>passive_TCP</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
passive_TCP (
    const char *service,                /*  Service name or port as string   */
    int queue_length                    /*  Queue length for listen()        */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a passive bound TCP socket for the specified service.
   Returns socket number or INVALID_SOCKET. If it returns
   INVALID_SOCKET, you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be one of: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADSERVICE</B>  <TD ALIGN="LEFT">Service
   cannot be converted to port number <TR><TD ALIGN="LEFT"><B>IP
   BADPROTOCOL</B>  <TD ALIGN="LEFT">Cannot understand protocol
   name <TR><TD ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD
   ALIGN="LEFT">Cannot create the passive socket <TR><TD
   ALIGN="LEFT"><B>IP BINDERROR</B>  <TD ALIGN="LEFT">Cannot bind
   to the port <TR><TD ALIGN="LEFT"><B>IP LISTENERROR</B>  <TD
   ALIGN="LEFT">Cannot listen to port </TABLE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (service &amp;&amp; *service);
    ASSERT (queue_length &gt; 0);
    return (<A HREF="sfldoc.htm#passive_socket">passive socket</A> (service, "tcp", queue_length));
}
</PRE>
<A NAME="passive_UDP">&nbsp;</A>
<H3><A NAME="TOC327"><TT>passive_UDP</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
passive_UDP (
    const char *service                 /*  Service name or port as string   */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a passive UDP socket for the specified service. Returns
   socket number or INVALID_SOCKET. If it returns INVALID_SOCKET,
   you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be one of: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADSERVICE</B>  <TD ALIGN="LEFT">Service
   cannot be converted to port number <TR><TD ALIGN="LEFT"><B>IP
   BADPROTOCOL</B>  <TD ALIGN="LEFT">Cannot understand protocol
   name <TR><TD ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD
   ALIGN="LEFT">Cannot create the passive socket <TR><TD
   ALIGN="LEFT"><B>IP BINDERROR</B>  <TD ALIGN="LEFT">Cannot bind
   to the port </TABLE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (service &amp;&amp; *service);
    return (<A HREF="sfldoc.htm#passive_socket">passive socket</A> (service, "udp", 0));
}
</PRE>
<A NAME="passive_socket">&nbsp;</A>
<H3><A NAME="TOC328"><TT>passive_socket</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
passive_socket (
    const char *service,                /*  Service name or port as string   */
    const char *protocol,               /*  Protocol "tcp" or "udp"          */
    int queue_length                    /*  Queue length for TCP sockets     */
)
</PRE>
<H4>Synopsis</H4>
<P> Creates a passive TCP or UDP socket. This function allows a
   server program to create a master socket, so that connections
   can be accepted. Used by the passive_TCP and passive_UDP
   functions. Returns a socket number or INVALID_SOCKET. If it
   returns INVALID_SOCKET, you can get the reason for the error by
   calling <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be one of: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADSERVICE</B>  <TD ALIGN="LEFT">Service
   cannot be converted to port number <TR><TD ALIGN="LEFT"><B>IP
   BADPROTOCOL</B>  <TD ALIGN="LEFT">Cannot understand protocol
   name <TR><TD ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD
   ALIGN="LEFT">Cannot create the passive socket <TR><TD
   ALIGN="LEFT"><B>IP BINDERROR</B>  <TD ALIGN="LEFT">Cannot bind
   to the port <TR><TD ALIGN="LEFT"><B>IP LISTENERROR</B>  <TD
   ALIGN="LEFT">Cannot listen to port </TABLE> By default, opens a
   socket on all available IP addresses. You can open the socket
   on a specific address, by setting the global variable
   ip_passive to the address (in network order). This variable is
   reset to INADDR_ANY after each call to passive_socket or one of
   the functions that calls it.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    struct servent
        *pse;                           /*  Service information entry        */
    struct sockaddr_in
        sin;                            /*  Internet end-point address       */
    sock_t
        handle;                         /*  Socket from socket() call        */

    ASSERT (service &amp;&amp; *service);
    ASSERT (protocol &amp;&amp; *protocol);
    ASSERT (queue_length &gt;= 0);

    connect_error_value = IP_NOERROR;   /*  Assume no errors                 */

    memset ((void *) &amp;sin, 0, sizeof (sin));
    sin.sin_family      = AF_INET;
    sin.sin_addr.s_addr = ip_passive;
    ip_passive = INADDR_ANY;            /*  Reset passive address            */

    /*  Map service name to port number                                      */
    pse = getservbyname (service, protocol);
    if (pse)
        sin.sin_port = htons ((dbyte) (ntohs (pse-&gt; s_port) + ip_portbase));
    else
      {
        sin.sin_port = atoi (service);
        if (sin.sin_port + ip_portbase &gt; 0)
            sin.sin_port = htons ((dbyte) (sin.sin_port + ip_portbase));
        else
          {
            connect_error_value = IP_BADSERVICE;
            return (INVALID_SOCKET);
          }
      }
    handle = <A HREF="sfldoc.htm#create_socket">create socket</A> (protocol);
    if (handle == INVALID_SOCKET)       /*  Cannot create the socket         */
        return (INVALID_SOCKET);

    /*  Bind the socket                                                      */
    if (bind ((SOCKET) handle, (struct sockaddr *) &amp;sin,
        sizeof (sin)) == SOCKET_ERROR)
      {
        connect_error_value = IP_BINDERROR;
        return (INVALID_SOCKET);        /*  Cannot bind to port              */
      }
    /*  Specify incoming queue length for stream socket                      */
    if (streq (protocol, "tcp")
    &amp;&amp; listen ((SOCKET) handle, queue_length) == SOCKET_ERROR)
      {
        connect_error_value = IP_LISTENERROR;
        return (INVALID_SOCKET);        /*  Cannot listen on port            */
      }
    return (handle);

#elif (defined (FAKE_SOCKETS))
    return (1);                         /*  Return dummy handle              */

#else
    connect_error_value = IP_NOSOCKETS;
    return (INVALID_SOCKET);            /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="create_socket">&nbsp;</A>
<H3><A NAME="TOC329"><TT>create_socket</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
create_socket (
    const char *protocol                /*  Protocol "tcp" or "udp"          */
)
</PRE>
<H4>Synopsis</H4>
<P> Creates a TCP or UDP socket. The socket is not connected. To
   use with TCP services you must bind or connect the socket. You
   can use the socket with UDP services - e.g. <A HREF="sfldoc.htm#read_UDP">read UDP</A> () -
   immediately. Returns a socket number or INVALID_SOCKET, in
   which case you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be one of: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADPROTOCOL</B>  <TD ALIGN="LEFT">Cannot
   understand protocol name <TR><TD ALIGN="LEFT"><B>IP
   SOCKETERROR</B>  <TD ALIGN="LEFT">Cannot create the socket
   </TABLE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    struct protoent
#   if (defined (__VMS__))
        ppe_struct = { NULL, NULL, 0 },
#   endif
        *ppe;                           /*  Protocol information entry       */
    int
        sock_type,                      /*  Type of socket we want           */
        true_value = 1;                 /*  Boolean value for setsockopt()   */
    sock_t
        handle;                         /*  Socket from socket() call        */

    ASSERT (protocol &amp;&amp; *protocol);
    connect_error_value = IP_NOERROR;   /*  Assume no errors                 */

    /*  On older VAXen, getprotobyname() is not available                    */
#   if (defined (__VMS__))
    ppe = &amp;ppe_struct;
    ppe-&gt; p_proto = 0;
#   else
    /*  Map protocol name to protocol number                                 */
    ppe = getprotobyname (protocol);
    if (ppe == NULL)                    /*  Cannot get protocol entry        */
      {
        connect_error_value = IP_BADPROTOCOL;
        return (INVALID_SOCKET);
      }
#   endif
    /*  Use protocol string to choose a socket type                          */
    if (streq (protocol, "udp"))
        sock_type = SOCK_DGRAM;
    else
        sock_type = SOCK_STREAM;

    /*  Allocate a socket                                                    */
    handle = (sock_t) socket (AF_INET, sock_type, ppe-&gt; p_proto);
    if (handle == INVALID_SOCKET)       /*  Cannot create passive socket     */
      {
        connect_error_value = IP_SOCKETERROR;
        return (INVALID_SOCKET);
      }
#   if (!defined (__WINDOWS__))
    /*  On BSD-socket systems we need to do this to allow the server to
     *  restart on a previously-used socket, without an annoying timeout
     *  of several minutes.  With winsock the reuseaddr option lets the
     *  server work with an already-used socket (!), so we don't do it.
     */
    setsockopt ((SOCKET) handle, SOL_SOCKET, SO_REUSEADDR,
                (char *) &amp;true_value, sizeof (true_value));
#   endif
    prepare_socket (handle);            /*  Ready socket for use             */
    return (handle);

#elif (defined (FAKE_SOCKETS))
    return (1);                         /*  Return dummy handle              */

#else
    connect_error_value = IP_NOSOCKETS;
    return (INVALID_SOCKET);            /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="connect_TCP">&nbsp;</A>
<H3><A NAME="TOC330"><TT>connect_TCP</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
connect_TCP (
    const char *host,                   /*  Host name                        */
    const char *service                 /*  Service name                     */
)
</PRE>
<H4>Synopsis</H4>
<P> Creates a TCP socket and connects it to a specified host and
   service. Returns a socket number or INVALID_SOCKET. In that
   case you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADHOST</B>  <TD ALIGN="LEFT">Host is not
   known <TR><TD ALIGN="LEFT"><B>IP BADPROTOCOL</B>  <TD
   ALIGN="LEFT">Cannot understand protocol name <TR><TD
   ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD ALIGN="LEFT">Cannot
   open a socket <TR><TD ALIGN="LEFT"><B>IP CONNECTERROR</B>  <TD
   ALIGN="LEFT">Cannot connect socket </TABLE> The host name may
   be a full name, NULL or "" meaning the current host, or a
   dotted-decimal number. The service may be a defined service,
   e.g. "echo", or a port number, specified as an ASCII string.
   See <A HREF="sfldoc.htm#connect_socket">connect socket</A>() for details. Adds the current value
   ip_portbase to the port number. Single-threaded clients may set
   ip_nonblock to FALSE and block on all read and write
   operations. They may use select() if they need to be able to
   time-out during reading/writing. Multi-threaded servers should
   set ip_nonblock to TRUE, and use select() to multiplex socket
   access. When ip_nonblock is TRUE, connect calls will return
   immediately, and the server should use select() to wait until
   the socket is ready for writing. On some systems (early
   Linux?), the select() call will fail in this situation. If you
   compile with -DBLOCKING_CONNECT, connects are done
   synchronously in all cases.
<H4>Examples</H4>
<PRE>
    sock_t handle;
    handle = connect_TCP ("", "8080");
    handle = connect_TCP (NULL, "echo");
    handle = connect_TCP ("www.imatix.com", "http");
</PRE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (service &amp;&amp; *service);
    return (<A HREF="sfldoc.htm#connect_socket">connect socket</A> (host,       /*  We have a host name              */
                            service,    /*  We have a service name           */
                            "tcp",      /*  Protocol is TCP                  */
                            NULL,       /*  No prepared address              */
                            3, 0));     /*  3 retries, no waiting            */
}
</PRE>
<A NAME="connect_UDP">&nbsp;</A>
<H3><A NAME="TOC331"><TT>connect_UDP</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
connect_UDP (
    const char *host,                   /*  Host name                        */
    const char *service                 /*  Service name                     */
)
</PRE>
<H4>Synopsis</H4>
<P> Creates a UDP socket and connects it to a specified host and
   service. Returns a socket number or INVALID_SOCKET. In that
   case you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADHOST</B>  <TD ALIGN="LEFT">Host is not
   known <TR><TD ALIGN="LEFT"><B>IP BADPROTOCOL</B>  <TD
   ALIGN="LEFT">Cannot understand protocol name <TR><TD
   ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD ALIGN="LEFT">Cannot
   open a socket <TR><TD ALIGN="LEFT"><B>IP CONNECTERROR</B>  <TD
   ALIGN="LEFT">Cannot connect socket </TABLE> The host name may
   be a full name, NULL or "" meaning the current host, or a
   dotted-decimal number. The service may be a defined service,
   e.g. "echo", or a port number, specified as an ASCII string.
   See <A HREF="sfldoc.htm#connect_socket">connect socket</A>() for details. Adds the current value
   ip_portbase to the port number. Single-threaded clients may set
   ip_nonblock to FALSE and block on all read and write
   operations. They may use select() if they need to be able to
   time-out during reading/writing. Multi-threaded servers should
   set ip_nonblock to TRUE, and use select() to multiplex socket
   access. When ip_nonblock is TRUE, connect calls will return
   immediately, and the server should use select() to wait until
   the socket is ready for writing. On some systems (early
   Linux?), the select() call will fail in this situation. If you
   compile with -DBLOCKING_CONNECT, connects are done
   synchronously in all cases.
<H4>Examples</H4>
<PRE>
    sock_t handle;
    handle = connect_UDP ("", "7");
    handle = connect_UDP (NULL, "echo");
    handle = connect_UDP ("imatix.com", "echo");
</PRE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (service &amp;&amp; *service);
    return (<A HREF="sfldoc.htm#connect_socket">connect socket</A> (host,       /*  We have a host name              */
                            service,    /*  We have a service name           */
                            "udp",      /*  Protocol is UDP                  */
                            NULL,       /*  No prepared address              */
                            3, 0));     /*  3 retries, no waiting            */
}
</PRE>
<A NAME="connect_TCP_fast">&nbsp;</A>
<H3><A NAME="TOC332"><TT>connect_TCP_fast</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
connect_TCP_fast (
    const struct sockaddr_in *sin       /*  Socket address structure         */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a TCP socket and connects it to a specified host/port
   address. Returns a socket number or INVALID_SOCKET. In that
   case you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADHOST</B>  <TD ALIGN="LEFT">Host is not
   known <TR><TD ALIGN="LEFT"><B>IP BADPROTOCOL</B>  <TD
   ALIGN="LEFT">Cannot understand protocol name <TR><TD
   ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD ALIGN="LEFT">Cannot
   open a socket <TR><TD ALIGN="LEFT"><B>IP CONNECTERROR</B>  <TD
   ALIGN="LEFT">Cannot connect socket </TABLE> This function is
   faster, if you know the host system address and port, than
   <A HREF="sfldoc.htm#connect_TCP">connect TCP</A>() because no translation is needed. You can get
   the host/address structure by calling <A HREF="sfldoc.htm#address_end_point">address end point</A>()
   or <A HREF="sfldoc.htm#get_peer_addr">get peer addr</A>(). See <A HREF="sfldoc.htm#connect_socket">connect socket</A>() for details.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (sin);
    return (<A HREF="sfldoc.htm#connect_socket">connect socket</A> (NULL,       /*  No host name                     */
                            NULL,       /*  No service name                  */
                            "tcp",      /*  Protocol is TCP                  */
                            sin,        /*  We have a prepared address       */
                            1, 0));     /*  1 retry, no waiting              */
}
</PRE>
<A NAME="connect_UDP_fast">&nbsp;</A>
<H3><A NAME="TOC333"><TT>connect_UDP_fast</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
connect_UDP_fast (
    const struct sockaddr_in *sin       /*  Socket address structure         */
)
</PRE>
<H4>Synopsis</H4>
<P> Creates a UDP socket and connects it to a specified host/port
   address. Returns a socket number or INVALID_SOCKET. In that
   case you can get the reason for the error by calling
   <A HREF="sfldoc.htm#connect_error">connect error</A> (). This may be: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD
   ALIGN="LEFT">Sockets not supported on this system <TR><TD
   ALIGN="LEFT"><B>IP BADHOST</B>  <TD ALIGN="LEFT">Host is not
   known <TR><TD ALIGN="LEFT"><B>IP BADPROTOCOL</B>  <TD
   ALIGN="LEFT">Cannot understand protocol name <TR><TD
   ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD ALIGN="LEFT">Cannot
   open a socket <TR><TD ALIGN="LEFT"><B>IP CONNECTERROR</B>  <TD
   ALIGN="LEFT">Cannot connect socket </TABLE> This function is
   faster, if you know the host system address and port, than
   <A HREF="sfldoc.htm#connect_UDP">connect UDP</A>() because no translation is needed. You can get
   the host/address structure by calling <A HREF="sfldoc.htm#address_end_point">address end point</A>()
   or <A HREF="sfldoc.htm#get_peer_addr">get peer addr</A>(). See <A HREF="sfldoc.htm#connect_socket">connect socket</A>() for details.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (sin);
    return (<A HREF="sfldoc.htm#connect_socket">connect socket</A> (NULL,       /*  No host name                     */
                            NULL,       /*  No service name                  */
                            "udp",      /*  Protocol is UDP                  */
                            sin,        /*  We have a prepared address       */
                            1, 0));     /*  1 retry, no waiting              */
}
</PRE>
<A NAME="connect_socket">&nbsp;</A>
<H3><A NAME="TOC334"><TT>connect_socket</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
connect_socket (
    const char *host,                   /*  Name of host, "" = localhost     */
    const char *service,                /*  Service name or port as string   */
    const char *protocol,               /*  Protocol "tcp" or "udp"          */
    const struct sockaddr_in *host_addr, /* Socket address structure         */
    int retries_left,                   /*  Max. number of retries           */
    int retry_delay                     /*  Delay between retries            */
)
</PRE>
<H4>Synopsis</H4>
<P> Makes a connection to a remote TCP or UDP port. This allows a
   client program to start sending information to a server. Used
   by the connect_TCP and connect_UDP functions. Returns a socket
   number or INVALID_SOCKET. If it returns INVALID_SOCKET, you can
   get the reason for the error by calling <A HREF="sfldoc.htm#connect_error">connect error</A> ().
   This may be one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>IP NOSOCKETS</B>  <TD ALIGN="LEFT">Sockets not
   supported on this system <TR><TD ALIGN="LEFT"><B>IP BADHOST</B>
   <TD ALIGN="LEFT">Host is not known <TR><TD ALIGN="LEFT"><B>IP
   BADPROTOCOL</B>  <TD ALIGN="LEFT">Cannot understand protocol
   name <TR><TD ALIGN="LEFT"><B>IP SOCKETERROR</B>  <TD
   ALIGN="LEFT">Cannot open a socket <TR><TD ALIGN="LEFT"><B>IP
   CONNECTERROR</B>  <TD ALIGN="LEFT">Cannot connect socket
   </TABLE> Always blocks until the connection has been made; i.e.
   when this function returns you can start to read and write on
   the socket. Adds the current value ip_portbase to the port
   number. The host name may be a full name, NULL or "" meaning
   the current host, or a dotted-decimal number. The service may
   be a defined service, e.g. "echo", or a port number, specified
   as an ASCII string. Alternatively, both these values may be
   NULL or "", in which case the function uses the host_addr
   argument to supply an address. If you want to build the
   host_addr structure yourself, use <A HREF="sfldoc.htm#build_sockaddr">build sockaddr</A>(). Single-
   threaded clients may set ip_nonblock to FALSE and block on all
   read and write operations. They may use select() if they need
   to be able to time-out during reading/writing. Multi-threaded
   servers should set ip_nonblock to TRUE, and use select() to
   multiplex socket access. When ip_nonblock is TRUE, connect
   calls will return immediately, and the server should use
   select() to wait until the socket is ready for writing. On some
   systems (early Linux?), the select() call will fail in this
   situation. If you compile with -DBLOCKING_CONNECT, connects are
   done synchronously in all cases.
<H4>Examples</H4>
<PRE>
    struct sockaddr_in
        host_addr;
    sock_t
        handle;
    build_sockaddr (&host_addr, 32_bit_host, 16_bit_port);
    handle = connect_socket (NULL, NULL, "tcp", &host_addr, 3, 0);
</PRE>
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    struct sockaddr_in
        sin;                            /*  Internet end-point address       */
    sock_t
        handle = 0;                     /*  Created socket                   */
    int
        rc;                             /*  Return code from call            */
    Bool
        old_nonblock;                   /*  Create non-blocking sockets      */

    connect_error_value = IP_NOERROR;   /*  Assume no errors                 */

    /*  Format sockaddr_in port and hostname, and quit if that failed        */
    if (service &amp;&amp; strused (service))
      {
        ASSERT (protocol &amp;&amp; *protocol);
        if (<A HREF="sfldoc.htm#address_end_point">address end point</A> (host, service, protocol, &amp;sin))
            return (INVALID_SOCKET);
      }
    else
      {
        ASSERT (host_addr);
        sin = *host_addr;               /*  Fast connect requested           */
      }
    /*  Connect socket and maybe retry a few times...                        */
    old_nonblock = ip_nonblock;
#   if (defined (BLOCKING_CONNECT))
    ip_nonblock = FALSE;                /*  Block on this socket             */
#   endif

    while (retries_left)
      {
        handle = <A HREF="sfldoc.htm#create_socket">create socket</A> (protocol);
        if (handle == INVALID_SOCKET)   /*  Unable to open a socket          */
          {
            ip_nonblock = old_nonblock;
            return (INVALID_SOCKET);
          }
        rc = connect ((SOCKET) handle, (struct sockaddr *) &amp;sin, sizeof (sin));
        if (rc == 0)
            break;                      /*  Connected okay                   */
        else
          {
#           if (defined (__WINDOWS__))
            if (WSAGetLastError () == WSAEWOULDBLOCK)
#           else
            if (errno == EINPROGRESS)
#           endif
                break;                  /*  Still connecting, but okay       */
          }
        /*  Retry if we have any attempts left                               */
        <A HREF="sfldoc.htm#close_socket">close socket</A> (handle);
        if (--retries_left == 0)      /*  Connection failed                */
          {
            connect_error_value = IP_CONNECTERROR;
            ip_nonblock = old_nonblock;
            return (INVALID_SOCKET);
          }
        sleep (retry_delay);
      }
    ip_nonblock = old_nonblock;
    prepare_socket (handle);            /*  Set final blocking mode          */
    return (handle);

#elif (defined (FAKE_SOCKETS))
    return (1);                         /*  Return dummy handle              */

#else
    connect_error_value = IP_NOSOCKETS;
    return (INVALID_SOCKET);            /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="connect_to_peer">&nbsp;</A>
<H3><A NAME="TOC335"><TT>connect_to_peer</TT></A></H3>
<PRE>
#include "sflsock.h"
int
connect_to_peer (
    sock_t handle,                      /*  Socket to connect                */
    const struct sockaddr_in *sin       /*  Socket address structure         */
)
</PRE>
<H4>Synopsis</H4>
<P> Connects an unconnected TCP or UDP socket to a peer specified
   by a sockaddr structure. Returns 0 if the connection succeeded,
   or SOCKET_ERROR if there was a problem. In the latter case you
   can get the reason for the error by calling <A HREF="sfldoc.htm#sockmsg">sockmsg</A>().
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        rc;                             /*  Return code from call            */
    Bool
        old_nonblock;                   /*  Create non-blocking sockets      */

    ASSERT (sin);
    old_nonblock = ip_nonblock;
#   if (defined (BLOCKING_CONNECT))
    ip_nonblock = FALSE;                /*  Block on this socket             */
#   endif

    rc = connect ((SOCKET) handle, (struct sockaddr *) sin, sizeof (*sin));

    ip_nonblock = old_nonblock;
    prepare_socket (handle);            /*  Set final blocking mode          */

#   if (defined (__WINDOWS__))
    return (win_error (rc));
#   else
    return (rc);
#   endif

#else
    connect_error_value = IP_NOSOCKETS;
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="address_end_point">&nbsp;</A>
<H3><A NAME="TOC336"><TT>address_end_point</TT></A></H3>
<PRE>
#include "sflsock.h"
int
address_end_point (
    const char *host,                   /*  Name of host, "" = localhost     */
    const char *service,                /*  Service name or port as string   */
    const char *protocol,               /*  Protocol "tcp" or "udp"          */
    struct sockaddr_in *sin             /*  Block for formatted address      */
)
</PRE>
<H4>Synopsis</H4>
<P> Formats an address block (struct sockaddr_in) for the
   specified host and service (port) information. Returns 0 if
   okay, SOCKET_ERROR if there was an error, in which case you can
   call <A HREF="sfldoc.htm#connect_error">connect error</A> () to get the reason for the error. This
   may be one of: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>IP
   NOSOCKETS</B>  <TD ALIGN="LEFT">Sockets not supported on this
   system <TR><TD ALIGN="LEFT"><B>IP BADHOST</B>  <TD
   ALIGN="LEFT">Host is not known </TABLE> Adds the current value
   ip_portbase to the port number.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    struct hostent
        *phe;                           /*  Host information entry           */
    struct servent
        *pse;                           /*  Service information entry        */
    char
        hostname [MAXHOSTNAMELEN + 1];  /*  Name of this system              */
    int
        feedback = 0;                   /*  Assume everything works          */

    ASSERT (service &amp;&amp; *service);
    ASSERT (protocol &amp;&amp; *protocol);
    ASSERT (sin);

    connect_error_value = IP_NOERROR;   /*  Assume no errors                 */
    memset ((void *) sin, 0, sizeof (*sin));
    sin-&gt; sin_family = AF_INET;

    /*  Map service name to a port number                                    */
    pse = getservbyname (service, protocol);
    if (pse)
        sin-&gt; sin_port = pse-&gt; s_port + ip_portbase;
    else
        sin-&gt; sin_port = htons ((short) (atoi (service) + ip_portbase));

    /*  Map host name to IP address, allowing for dotted decimal             */
    if (host &amp;&amp; strused (host))
        strcpy (hostname, host);
    else
        strcpy (hostname, "127.0.0.1");

    /*  Check if it's a valid IP address first                               */
    sin-&gt; sin_addr.s_addr = inet_addr (hostname);
    if (sin-&gt; sin_addr.s_addr == INADDR_NONE)
      {
        /*  Not a dotted address -- try to translate the name                */
        phe = gethostbyname (hostname);
        if (phe)
            memcpy ((void *) &amp;sin-&gt; sin_addr, phe-&gt; h_addr, phe-&gt; h_length);
        else
          {                             /*  Cannot map to host               */
            connect_error_value = IP_BADHOST;
            feedback = (int) SOCKET_ERROR;
          }
      }
    return (feedback);

#else
    connect_error_value = IP_NOSOCKETS;
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="build_sockaddr">&nbsp;</A>
<H3><A NAME="TOC337"><TT>build_sockaddr</TT></A></H3>
<PRE>
#include "sflsock.h"
void
build_sockaddr (
    struct sockaddr_in *sin,            /*  Socket address structure         */
    qbyte host,                         /*  32-bit host address              */
    dbyte port                          /*  16-bit port number               */
)
</PRE>
<H4>Synopsis</H4>
<P> Builds a socket address structure from the specified host and
   port addresses. Does not return any value except the built
   structure.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    ASSERT (sin);

    sin-&gt; sin_family      = AF_INET;
    sin-&gt; sin_addr.s_addr = htonl (host);
    sin-&gt; sin_port        = htons (port);
}
</PRE>
<A NAME="socket_localaddr">&nbsp;</A>
<H3><A NAME="TOC338"><TT>socket_localaddr</TT></A></H3>
<PRE>
#include "sflsock.h"
char *
socket_localaddr (
    sock_t handle)
</PRE>
<H4>Synopsis</H4>
<P>Returns a string containing the local host address for the
   specified connected socket. The string is formatted as a string
   "n.n.n.n". Returns the address of a static string or a buffer
   that is overwritten by each call. If sockets are not supported,
   or there was an error, returns the loopback address
   "127.0.0.1".
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#define NTOA_MAX    16
#if (defined (DOES_SOCKETS))
    static char
        localaddr [NTOA_MAX + 1];       /*  xxx.xxx.xxx.xxx                  */
    struct sockaddr_in
        sin;                            /*  Address of local system          */

    if (<A HREF="sfldoc.htm#get_sock_addr">get sock addr</A> (handle, &amp;sin, NULL, 0))
        return ("127.0.0.1");
    else
      {
        strncpy (localaddr, inet_ntoa (sin.sin_addr), NTOA_MAX);
        return  (localaddr);
      }
#else
    return ("127.0.0.1");
#endif
}
</PRE>
<A NAME="socket_peeraddr">&nbsp;</A>
<H3><A NAME="TOC339"><TT>socket_peeraddr</TT></A></H3>
<PRE>
#include "sflsock.h"
char *
socket_peeraddr (
    sock_t handle)
</PRE>
<H4>Synopsis</H4>
<P>Returns a string containing the peer host address for the
   specified connected socket. The string is formatted as a string
   "n.n.n.n". Returns the address of a static string or a buffer
   that is overwritten by each call. If sockets are not supported,
   or there was an error, returns the loopback address
   "127.0.0.1".
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    static char
        peeraddr [NTOA_MAX + 1];        /*  xxx.xxx.xxx.xxx                  */
    struct sockaddr_in
        sin;                            /*  Address of peer system           */

    if (<A HREF="sfldoc.htm#get_peer_addr">get peer addr</A> (handle, &amp;sin, NULL, 0))
        return ("127.0.0.1");
    else
      {
        strncpy (peeraddr, inet_ntoa (sin.sin_addr), NTOA_MAX);
        return  (peeraddr);
      }
#else
    return ("127.0.0.1");
#endif
}
</PRE>
<A NAME="socket_nodelay">&nbsp;</A>
<H3><A NAME="TOC340"><TT>socket_nodelay</TT></A></H3>
<PRE>
#include "sflsock.h"
int
socket_nodelay (
    sock_t handle)
</PRE>
<H4>Synopsis</H4>
<P>Disables Nagle's algorithm for the specified socket; use this
   when you want to ensure that data is sent outwards as fast as
   possible, and when you are certain that Nagle's algorithm is
   causing a slowdown in performance. Recommended for HTTP, but
   not recommended for telnet. Returns 0 if okay, SOCKET_ERROR if
   there was a problem.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (TCP_NODELAY))
    int
        true_value = 1;                 /*  Boolean value for setsockopt()   */

    return (setsockopt ((SOCKET) handle, SOL_SOCKET, TCP_NODELAY,
                        (char *) &amp;true_value, sizeof (true_value)));
#else
    return (0);                         /*  Not applicable to this system    */
#endif
}
</PRE>
<A NAME="socket_is_alive">&nbsp;</A>
<H3><A NAME="TOC341"><TT>socket_is_alive</TT></A></H3>
<PRE>
#include "sflsock.h"
Bool
socket_is_alive (
    sock_t handle)
</PRE>
<H4>Synopsis</H4>
<P> Returns TRUE if the socket is open. Returns FALSE if the
   socket is no longer accessible. You can use this function to
   check that a socket has not been closed by the other party,
   before doing reading or writing.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        socket_type,
        rc;
    argsize_t
        socket_type_size = sizeof (SOCKET);

    rc = getsockopt ((SOCKET) handle, SOL_SOCKET, SO_TYPE,
                    (char *) &amp;socket_type, &amp;socket_type_size);
    return (rc == 0);
#else
    return (FALSE);
#endif
}
</PRE>
<A NAME="socket_error">&nbsp;</A>
<H3><A NAME="TOC342"><TT>socket_error</TT></A></H3>
<PRE>
#include "sflsock.h"
int
socket_error (
    sock_t handle)
</PRE>
<H4>Synopsis</H4>
<P>Returns an errno value for the socket, or 0 if no error was
   outstanding on the socket. This function is useful if you are
   handling sockets using the select() function: this may return
   error indicators on sockets, without precision on the type of
   error. This function will return the precise error number.
   Errors like EINPROGRESS, EAGAIN, and EWOULDBLOCK can usually be
   ignored or handled by retrying.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    return (getsockopt ((SOCKET) handle, SOL_SOCKET, SO_ERROR, 0, 0));
#else
    return (0);
#endif
}
</PRE>
<A NAME="accept_socket">&nbsp;</A>
<H3><A NAME="TOC343"><TT>accept_socket</TT></A></H3>
<PRE>
#include "sflsock.h"
sock_t
accept_socket (
    sock_t master_socket)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a connection on a specified master socket. If you do
   not want to wait on this call, use select() to poll the socket
   until there is an incoming request, then call accept_socket.
   Returns the number of the new slave socket, or INVALID_SOCKET
   if there was an error on the accept call. You can handle errors
   as fatal except for EAGAIN which indicates that the operation
   would cause a non-blocking socket to block (treat EWOULDBLOCK
   in the same way).
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    sock_t
        slave_socket;                   /*  Connected slave socket           */
    struct sockaddr_in
        sin;                            /*  Address of connecting party      */
    argsize_t
        sin_length;                     /*  Length of address                */

    connect_error_value = IP_NOERROR;   /*  Assume no errors                 */

    sin_length = (int) sizeof (sin);
    slave_socket = accept ((SOCKET) master_socket,
                          (struct sockaddr *) &amp;sin, &amp;sin_length);

    /*  On non-Windows systems, accept returns -1 in case of error, which    */
    /*  is the same as INVALID_SOCKET.                                       */
#   if (defined (__WINDOWS__))
    if (slave_socket == INVALID_SOCKET)
      {
        int sock_errno = WSAGetLastError ();
        if (sock_errno == WSAEWOULDBLOCK || sock_errno == WSAEINPROGRESS)
            errno = EAGAIN;
      }
#   endif
    if (slave_socket != INVALID_SOCKET)
        prepare_socket (slave_socket);

    return (slave_socket);
#else
    connect_error_value = IP_NOSOCKETS;
    return (INVALID_SOCKET);            /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="connect_error">&nbsp;</A>
<H3><A NAME="TOC344"><TT>connect_error</TT></A></H3>
<PRE>
#include "sflsock.h"
int
connect_error (void)
</PRE>
<H4>Synopsis</H4>
<P> Returns the last error code from one of the connection
   functions. For portability in a multithreaded environment, call
   immediately after the call to the connection function.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    return (connect_error_value);
}
</PRE>
<A NAME="get_sock_addr">&nbsp;</A>
<H3><A NAME="TOC345"><TT>get_sock_addr</TT></A></H3>
<PRE>
#include "sflsock.h"
int
get_sock_addr (
    sock_t handle,                      /*  Socket to get address for        */
    struct sockaddr_in *sin,            /*  Block for formatted address      */
    char *name,                         /*  Buffer for host name, or NULL    */
    int namesize                        /*  Size of host name buffer         */
)
</PRE>
<H4>Synopsis</H4>
<P>Builds an address block (struct sockaddr_in) for the local end
   of the specified connected socket. Returns 0 if okay,
   SOCKET_ERROR if there was an error. If the name argument is not
   null, looks-up the host name and returns it. The name is
   truncated to namesize characters, including a trailing null
   character.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        rc;                             /*  Return code from call            */
    struct hostent
        *phe;                           /*  Host information entry           */
    argsize_t
        sin_length;                     /*  Length of address                */

    /*  Get address for local connected socket                               */
    sin_length = (int) sizeof (*sin);   /*  Length of address                */
    rc = getsockname ((SOCKET) handle, (struct sockaddr *) sin, &amp;sin_length);

    /*  Translate into host name string, only if wanted                      */
    if (name != NULL &amp;&amp; rc == 0)
      {
        phe = gethostbyaddr ((char *) &amp;sin-&gt; sin_addr,
                             sizeof (sin-&gt; sin_addr), AF_INET);
        if (phe)
          {
            strncpy (name, phe-&gt; h_name, namesize);
            name [namesize - 1] = '\0';
          }
      }
#   if (defined (__WINDOWS__))
    return (win_error (rc));
#   else
    return (rc);
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="get_peer_addr">&nbsp;</A>
<H3><A NAME="TOC346"><TT>get_peer_addr</TT></A></H3>
<PRE>
#include "sflsock.h"
int
get_peer_addr (
    sock_t handle,                      /*  Socket to get address for        */
    struct sockaddr_in *sin,            /*  Block for formatted address      */
    char *name,                         /*  Buffer for host name, or NULL    */
    int namesize                        /*  Size of host name buffer         */
)
</PRE>
<H4>Synopsis</H4>
<P>Builds an address block (struct sockaddr_in) for the remote end
   of the specified connected socket. Returns 0 if okay,
   SOCKET_ERROR if there was an error. If the name argument is not
   null, looks-up the host name and returns it. The name is
   truncated to namesize characters, including a trailing null
   character.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        rc;                             /*  Return code from call            */
    struct hostent
        *phe;                           /*  Host information entry           */
    argsize_t
        sin_length;                     /*  Length of address                */

    ASSERT (sin);

    /*  Get address for connected socket peer                                */
    sin_length = (int) sizeof (*sin);   /*  Length of address                */
    rc = getpeername ((SOCKET) handle, (struct sockaddr *) sin, &amp;sin_length);

    /*  Translate into host name string, only if wanted                      */
    if (name != NULL &amp;&amp; rc == 0)
      {
        phe = gethostbyaddr ((char *) &amp;sin-&gt; sin_addr,
                             sizeof (sin-&gt; sin_addr), AF_INET);
        if (phe)
          {
            strncpy (name, phe-&gt; h_name, namesize);
            name [namesize - 1] = '\0';
          }
      }
#   if (defined (__WINDOWS__))
    return (win_error (rc));
#   else
    return (rc);
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="read_TCP">&nbsp;</A>
<H3><A NAME="TOC347"><TT>read_TCP</TT></A></H3>
<PRE>
#include "sflsock.h"
int
read_TCP (
    sock_t handle,                      /*  Socket handle                    */
    void *buffer,                       /*  Buffer to receive data           */
    size_t length                       /*  Maximum amount of data to read   */
)
</PRE>
<H4>Synopsis</H4>
<P> Reads data from the socket. On UNIX, VMS, OS/2, passes through
   to the standard read function; some other systems have
   particular ways of accessing sockets. If there is an error on
   the read this function returns SOCKET_ERROR. You can handle
   errors (in sockerrno) as fatal except for EAGAIN which
   indicates that the operation would cause a non-blocking socket
   to block, and EPIPE or ECONNRESET which indicate that the
   socket was closed at the other end. Treat EWOULDBLOCK as
   EAGAIN.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
#   if (defined (__UNIX__) || defined (__VMS__) || defined (__OS2__))
    return (read ((SOCKET) handle, buffer, length));
#   elif (defined (__WINDOWS__))
    int
        rc;                             /*  Return code from call            */

    ASSERT (buffer);
    rc = recv ((SOCKET) handle, buffer, length, 0);
    return (win_error (rc));
#   else
#       error "No code for function body."
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="write_TCP">&nbsp;</A>
<H3><A NAME="TOC348"><TT>write_TCP</TT></A></H3>
<PRE>
#include "sflsock.h"
int
write_TCP (
    sock_t handle,                      /*  Socket handle                    */
    const void *buffer,                 /*  Buffer containing data           */
    size_t length                       /*  Amount of data to write          */
)
</PRE>
<H4>Synopsis</H4>
<P> Writes data from the socket. On UNIX, VMS, OS/2, calls the
   standard write function; some other systems have particular
   ways of accessing sockets. If there is an error on the write
   this function returns SOCKET_ERROR. You can handle errors (in
   sockerrno) as fatal except for EAGAIN which indicates that the
   operation would cause a non-blocking socket to block, and EPIPE
   or ECONNRESET which indicate that the socket was closed at the
   other end. Treat EWOULDBLOCK as EAGAIN.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
#   if (defined (__UNIX__) || defined (__VMS__) || defined (__OS2__))
    return (write ((SOCKET) handle, buffer, length));
#   elif (defined (__WINDOWS__))
    int
        rc;                             /*  Return code from call            */

    ASSERT (buffer);
    rc = send ((SOCKET) handle, buffer, length, 0);
    return (win_error (rc));
#   else
#       error "No code for function body."
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="read_UDP">&nbsp;</A>
<H3><A NAME="TOC349"><TT>read_UDP</TT></A></H3>
<PRE>
#include "sflsock.h"
int
read_UDP (
    sock_t handle,                      /*  Socket handle                    */
    void *buffer,                       /*  Buffer to receive data           */
    size_t length,                      /*  Maximum amount of data to read   */
    const struct sockaddr_in *sin       /*  Block for address, or null       */
)
</PRE>
<H4>Synopsis</H4>
<P> Reads data from a connected or unconnected UDP socket. To
   prepare a connected UDP socket you call <A HREF="sfldoc.htm#connect_UDP">connect UDP</A> ().
   This makes a connection to a specific port on a specific host,
   and returns a socket handle. When you call this function with a
   null value for the address argument, it assumes you are using a
   connected UDP socket. To prepare an unconnected UDP socket,
   call <A HREF="sfldoc.htm#create_socket">create socket</A> () with the string "udp" as argument.
   This returns a sock_t handle that you can use in this function.
   If you use an unconnected UDP socket you must provide an
   address structure. The function places the remote host and port
   in this structure. This lets you reply using <A HREF="sfldoc.htm#write_UDP">write UDP</A> ().
   Generally a server can use unconnected sockets, and a client
   can use connected sockets. You can also format an address for a
   specific host and port using the <A HREF="sfldoc.htm#address_end_point">address end point</A> ()
   function. If there is an error on the read this function
   returns SOCKET_ERROR. You can handle errors (in sockerrno) as
   fatal except for EAGAIN which indicates that the operation
   would cause a non-blocking socket to block. Treat EWOULDBLOCK
   as EAGAIN.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    argsize_t
        sin_length;                     /*  Length of address                */
    int
        flags = 0,                      /*  Flags for call                   */
        rc;                             /*  Return code from call            */

    ASSERT (buffer);
    ASSERT (sin);
    sin_length = (int) sizeof (*sin);
    if (sin)
        /*  Read from unconnected UDP socket; we accept the address of the   */
        /*  sending party in the sin argument.                               */
        rc = recvfrom ((SOCKET) handle, buffer, length, flags,
                      (struct sockaddr *) sin, &amp;sin_length);
    else
        /*  Read from a connected UDP socket; we don't need to get the       */
        /*  address, since we already know it.                               */
        rc = recv     ((SOCKET) handle, buffer, length, flags);

#   if (defined (__WINDOWS__))
    return (win_error (rc));
#   else
    return (rc);
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="write_UDP">&nbsp;</A>
<H3><A NAME="TOC350"><TT>write_UDP</TT></A></H3>
<PRE>
#include "sflsock.h"
int
write_UDP (
    sock_t handle,                      /*  Socket handle                    */
    const void *buffer,                 /*  Buffer containing data           */
    size_t length,                      /*  Amount of data to write          */
    const struct sockaddr_in *sin       /*  Address to send to, or null      */
)
</PRE>
<H4>Synopsis</H4>
<P> Writes data to a connected or unconnected UDP socket. To
   prepare a connected UDP socket you call <A HREF="sfldoc.htm#connect_UDP">connect UDP</A> ().
   This makes a connection to a specific port on a specific host,
   and returns a socket handle. When you call this function with a
   null value for the address argument, it assumes you are using a
   connected UDP socket. To prepare an unconnected UDP socket,
   call <A HREF="sfldoc.htm#create_socket">create socket</A> () with the string "udp" as argument.
   This returns a sock_t handle that you can use in this function.
   If you use an unconnected UDP socket you must provide an
   address structure containing a valid host and port. You can get
   this information from a <A HREF="sfldoc.htm#read_UDP">read UDP</A> () or through
   <A HREF="sfldoc.htm#address_end_point">address end point</A> (). If there is an error on the write
   this function returns SOCKET_ERROR. You can handle errors as
   fatal except for EAGAIN which indicates that the operation
   would cause a non-blocking socket to block. Treat EWOULDBLOCK
   as EAGAIN.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        sin_length,                     /*  Length of address                */
        flags = 0,                      /*  Flags for call                   */
        rc;                             /*  Return code from call            */

    ASSERT (buffer);
    ASSERT (sin);
    sin_length = (int) sizeof (*sin);
    if (sin)
        /*  Write to unconnected UDP socket; we provide the address of       */
        /*  the receiving party in the sin argument.                         */
        rc = sendto ((SOCKET) handle, buffer, length, flags,
                    (struct sockaddr *) sin, sin_length);
    else
        /*  Write to a connected UDP socket; we don't need to supply         */
        /*  the address, since we already know it.                           */
        rc = send   ((SOCKET) handle, buffer, length, flags);

#   if (defined (__WINDOWS__))
    return (win_error (rc));
#   else
    return (rc);
#   endif
#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="close_socket">&nbsp;</A>
<H3><A NAME="TOC351"><TT>close_socket</TT></A></H3>
<PRE>
#include "sflsock.h"
int
close_socket (
    sock_t handle                       /*  Socket handle                    */
)
</PRE>
<H4>Synopsis</H4>
<P> Closes the socket. On UNIX, VMS, OS/2 calls the standard close
   function; some other systems have particular ways of accessing
   sockets. If there is an error on the close this function
   returns SOCKET_ERROR. You can handle errors (in sockerrno) as
   fatal except for EAGAIN which indicates that the operation
   would cause a non-blocking socket to block. Treat EWOULDBLOCK
   as EAGAIN.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    if (!<A HREF="sfldoc.htm#socket_is_alive">socket is alive</A> (handle))
        return (0);
    shutdown ((SOCKET) handle, 2);      /*  Shut socket gracefully           */
#   if (defined (__UNIX__) || defined (__VMS__) || defined (__OS2__))
    return (close ((SOCKET) handle));
#   elif (defined (__WINDOWS__))
    {
    int
        rc;
        rc = closesocket ((SOCKET) handle);
    return (win_error (rc));
    }
#   else
#       error "No code for function body."
#   endif

#elif (defined (FAKE_SOCKETS))
    return (0);                         /*  Okay, closed                     */

#else
    return ((int) SOCKET_ERROR);        /*  Sockets not supported            */
#endif
}
</PRE>
<A NAME="sock_select">&nbsp;</A>
<H3><A NAME="TOC352"><TT>sock_select</TT></A></H3>
<PRE>
#include "sflsock.h"
int
sock_select (int nfds, fd_set *readfds, fd_set *writefds,
             fd_set *errorfds, struct timeval *timeout)
</PRE>
<H4>Synopsis</H4>
<P>Performs the standard select() call. Use this in preference to
   select(), as some systems may not be 100% compatible with BSD
   sockets, Uses the same arguments as the select() call, and
   gives the same return codes. If sockets are not supported,
   always returns 0.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    ASSERT (timeout);
    return (select (nfds,
                    FD_SETTYPE readfds,
                    FD_SETTYPE writefds,
                    FD_SETTYPE errorfds,
                    timeout));
#else
    return (0);
#endif
}
</PRE>
<A NAME="get_hostname">&nbsp;</A>
<H3><A NAME="TOC353"><TT>get_hostname</TT></A></H3>
<PRE>
#include "sflsock.h"
char *
get_hostname (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a string containing the local hostname. The returned
   string is in a static area. Only performs the local hostname
   lookup one time; the returned value is cached for later
   repeated calls to this function. If sockets are not supported,
   returns the value "localhost".
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    static char
        host_name [LINE_MAX + 1] = "";

    if (strnull (host_name))
        if (gethostname (host_name, LINE_MAX))
            strcpy (host_name, "localhost");
    return (host_name);
#else
    return ("localhost");
#endif
}
</PRE>
<A NAME="get_hostaddr">&nbsp;</A>
<H3><A NAME="TOC354"><TT>get_hostaddr</TT></A></H3>
<PRE>
#include "sflsock.h"
qbyte
get_hostaddr (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the current the host address as a 4-byte value in host
   format (not network format). Returns 0x7f000001 (loopback) if
   sockets are not supported or there was an error getting the
   current host IP address. If there are several IP addresses on
   the system, returns one arbitrary address.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    struct hostent
        *phe;                           /*  Host information entry           */

    phe = gethostbyname (<A HREF="sfldoc.htm#get_hostname">get hostname</A> ());
    if (phe)
        return (*(qbyte *) (phe-&gt; h_addr_list [0]));
    else
        return (htonl (SOCKET_LOOPBACK));
#else
    return (htonl (SOCKET_LOOPBACK));
#endif
}
</PRE>
<A NAME="get_hostaddrs">&nbsp;</A>
<H3><A NAME="TOC355"><TT>get_hostaddrs</TT></A></H3>
<PRE>
#include "sflsock.h"
qbyte *
get_hostaddrs (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a table of all host IP addresses. The table ends in a
   zero address. Each address is a 4-byte value in host format.
   Returns NULL if there was an error. If sockets are not
   supported, returns a table with the loopback address
   (127.0.0.1) and a null address. The caller must free the table
   using mem_free() when finished using it.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (DOES_SOCKETS))
    int
        addr_count;                     /*  How many addresses do we have    */
    qbyte
        *addr_table;                    /*  Where we store the addresses     */
    struct hostent
        *phe;                           /*  Host information entry           */

    if ((phe = gethostbyname (<A HREF="sfldoc.htm#get_hostname">get hostname</A> ())) == NULL)
        return (NULL);

    /*  Count the addresses                                                  */
    for (addr_count = 0; phe-&gt; h_addr_list [addr_count]; addr_count++);

    /*  Allocate a table; socket addresses are 4 bytes                       */
    addr_table = mem_alloc (4 * (addr_count + 1));

    /*  Store the addresses                                                  */
    for (addr_count = 0; phe-&gt; h_addr_list [addr_count]; addr_count++)
        addr_table [addr_count]
            = *(qbyte *) (phe-&gt; h_addr_list [addr_count]);

    addr_table [addr_count] = 0;
    return (addr_table);

#else
    qbyte
        *addr_table;                    /*  Where we store the addresses     */

    addr_table = mem_alloc (8);         /*  Addresses are 4 bytes            */
    addr_table [0] = htonl (SOCKET_LOOPBACK);
    addr_table [1] = 0;
    return (addr_table);
#endif
}
</PRE>
<A NAME="sock_ntoa">&nbsp;</A>
<H3><A NAME="TOC356"><TT>sock_ntoa</TT></A></H3>
<PRE>
#include "sflsock.h"
char *
sock_ntoa (qbyte address)
</PRE>
<H4>Synopsis</H4>
<P>Converts an IP address in network order to a string in dotted
   format. The string is stored in a statically-allocated buffer
   that is overwritten by each call.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    static char
        string [16];                    /*  xxx.xxx.xxx.xxx                  */
    byte
        *part;

    /*  Network order is high-low so we can address the bytes in order       */
    part = (byte *) &amp;address;
    sprintf (string, "%d.%d.%d.%d", part [0], part [1], part [2], part [3]);
    return (string);
}
</PRE>
<A NAME="sockmsg">&nbsp;</A>
<H3><A NAME="TOC357"><TT>sockmsg</TT></A></H3>
<PRE>
#include "sflsock.h"
const char *
sockmsg (void)
</PRE>
<H4>Synopsis</H4>
<P> Returns a string describing the cause of the last fatal error
   to occur a socket. Should be called directly after a socket i/o
   operation; if you do other i/o operations or allow other
   threads to proceed in the meantime, the returned string may be
   incorrect.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (__WINDOWS__))
    char
        *message;

    switch (WSAGetLastError ())
      {
        case WSAEINTR:           message = "WSAEINTR";           break;
        case WSAEBADF:           message = "WSAEBADF";           break;
        case WSAEACCES:          message = "WSAEACCES";          break;
        case WSAEFAULT:          message = "WSAEFAULT";          break;
        case WSAEINVAL:          message = "WSAEINVAL";          break;
        case WSAEMFILE:          message = "WSAEMFILE";          break;
        case WSAEWOULDBLOCK:     message = "WSAEWOULDBLOCK";     break;
        case WSAEINPROGRESS:     message = "WSAEINPROGRESS";     break;
        case WSAEALREADY:        message = "WSAEALREADY";        break;
        case WSAENOTSOCK:        message = "WSAENOTSOCK";        break;
        case WSAEDESTADDRREQ:    message = "WSAEDESTADDRREQ";    break;
        case WSAEMSGSIZE:        message = "WSAEMSGSIZE";        break;
        case WSAEPROTOTYPE:      message = "WSAEPROTOTYPE";      break;
        case WSAENOPROTOOPT:     message = "WSAENOPROTOOPT";     break;
        case WSAEPROTONOSUPPORT: message = "WSAEPROTONOSUPPORT"; break;
        case WSAESOCKTNOSUPPORT: message = "WSAESOCKTNOSUPPORT"; break;
        case WSAEOPNOTSUPP:      message = "WSAEOPNOTSUPP";      break;
        case WSAEPFNOSUPPORT:    message = "WSAEPFNOSUPPORT";    break;
        case WSAEAFNOSUPPORT:    message = "WSAEAFNOSUPPORT";    break;
        case WSAEADDRINUSE:      message = "WSAEADDRINUSE";      break;
        case WSAEADDRNOTAVAIL:   message = "WSAEADDRNOTAVAIL";   break;
        case WSAENETDOWN:        message = "WSAENETDOWN";        break;
        case WSAENETUNREACH:     message = "WSAENETUNREACH";     break;
        case WSAENETRESET:       message = "WSAENETRESET";       break;
        case WSAECONNABORTED:    message = "WSAECONNABORTED";    break;
        case WSAECONNRESET:      message = "WSAECONNRESET";      break;
        case WSAENOBUFS:         message = "WSAENOBUFS";         break;
        case WSAEISCONN:         message = "WSAEISCONN";         break;
        case WSAENOTCONN:        message = "WSAENOTCONN";        break;
        case WSAESHUTDOWN:       message = "WSAESHUTDOWN";       break;
        case WSAETOOMANYREFS:    message = "WSAETOOMANYREFS";    break;
        case WSAETIMEDOUT:       message = "WSAETIMEDOUT";       break;
        case WSAECONNREFUSED:    message = "WSAECONNREFUSED";    break;
        case WSAELOOP:           message = "WSAELOOP";           break;
        case WSAENAMETOOLONG:    message = "WSAENAMETOOLONG";    break;
        case WSAEHOSTDOWN:       message = "WSAEHOSTDOWN";       break;
        case WSAEHOSTUNREACH:    message = "WSAEHOSTUNREACH";    break;
        case WSAENOTEMPTY:       message = "WSAENOTEMPTY";       break;
        case WSAEPROCLIM:        message = "WSAEPROCLIM";        break;
        case WSAEUSERS:          message = "WSAEUSERS";          break;
        case WSAEDQUOT:          message = "WSAEDQUOT";          break;
        case WSAESTALE:          message = "WSAESTALE";          break;
        case WSAEREMOTE:         message = "WSAEREMOTE";         break;
        case WSAEDISCON:         message = "WSAEDISCON";         break;
        case WSASYSNOTREADY:     message = "WSASYSNOTREADY";     break;
        case WSAVERNOTSUPPORTED: message = "WSAVERNOTSUPPORTED"; break;
        case WSANOTINITIALISED:  message = "WSANOTINITIALISED";  break;
        default:                 message = "No error";
      }
    return (message);
#else
    return (strerror (errno));
#endif
}
</PRE>
<A NAME="winsock_last_error">&nbsp;</A>
<H3><A NAME="TOC358"><TT>winsock_last_error</TT></A></H3>
<PRE>
#include "sflsock.h"
int
winsock_last_error (void)
</PRE>
<H4>Synopsis</H4>
<P>Convert a winsock error into a errno value.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    int
        error = 0;

    switch (WSAGetLastError ())
      {
        case WSAEINTR:           error = EINTR;           break;
        case WSAEBADF:           error = EBADF;           break;
        case WSAEWOULDBLOCK:     error = EAGAIN;          break;
        case WSAEINPROGRESS:     error = EAGAIN;          break;
        case WSAENETDOWN:        error = EAGAIN;          break;
        case WSAECONNRESET:      error = EPIPE;           break;
        case WSAECONNABORTED:    error = EPIPE;           break;
        case WSAEINVAL:          error = EPIPE;           break;
#  if defined (WIN32)
        default:                 error = GetLastError ();
#  else
        default:                 error = errno;
#  endif
      }
    return (error);
}
</PRE>
<A NAME="socket_is_permitted">&nbsp;</A>
<H3><A NAME="TOC359"><TT>socket_is_permitted</TT></A></H3>
<PRE>
#include "sflsock.h"
Bool
socket_is_permitted (const char *address, const char *mask)
</PRE>
<H4>Synopsis</H4>
<P>Compares the specified address with a mask and returns TRUE if
   the address matches the mask, or FALSE if it does not. The
   address is formatted as a string "xxx.xxx.xxx.xxx". The mask is
   formatted as zero or more patterns, delimited by whitespace or
   commas. A pattern is an address string, with zero or more of
   the last components replaced by '*'. The pattern may also be
   prefixed by '!' to indicate exclusion. This is an example of a
   mask: "127.0.0.1, 253.34.*, !253.35.*". This mask allows all
   addresses: "*". To get the string address for a remote socket,
   use socket_peer_address().
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    char
        *addrptr,                       /*  Pointer into address             */
        *maskptr;                       /*  Pointer into mask                */
    Bool
        negate,                         /*  If !pattern                      */
        feedback = FALSE;               /*  False unless matched             */

    ASSERT (address);
    ASSERT (mask);

    maskptr = (char *) mask;
    while (*maskptr)
      {
        while (isspace (*maskptr) || *maskptr == ',')
            maskptr++;

        /*  Get negation if necessary                                        */
        if (*maskptr == '!')
          {
            negate = TRUE;
            maskptr++;
          }
        else
            negate = FALSE;

        /*  Compare pattern with address up to the end of the pattern        */
        for (addrptr = (char *) address; *addrptr; addrptr++)
          {
            if (*maskptr == '*')        /*  Matched address up to *          */
                return (!negate);       /*  So either accepted or failed     */
            else
            if (*maskptr == '\0')       /*  Did not match address            */
                return (negate);        /*    so fail unless negated         */
            else
            if (*addrptr != *maskptr)   /*  Some difference                  */
                break;                  /*    so stop comparing              */

            maskptr++;
          }
        if (*addrptr == '\0'            /*  Matched exact address?           */
        &amp;&amp; (*maskptr == '\0' || isspace (*maskptr) || *maskptr == ','))
            return (!negate);           /*  Either accepted or failed        */

        until (*maskptr == '\0' || isspace (*maskptr) || *maskptr == ',')
            maskptr++;                  /*  Skip to end of this pattern      */
      }
    return (feedback);
}
</PRE>
<A NAME="get_host_file">&nbsp;</A>
<H3><A NAME="TOC360"><TT>get_host_file</TT></A></H3>
<PRE>
#include "sflsock.h"
char *
get_host_file (void)
</PRE>
<H4>Synopsis</H4>
<P>returns the full path name of the host lookup file, if provided
   by the OS, and found. If not found, returns "hosts". The
   returned string is held in a static area of memory that may be
   overwritten by each call.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
#if (defined (WIN32))
    static OSVERSIONINFO
        version_info;
    static char
        name [LINE_MAX + 1];

    strclr (name);
    GetWindowsDirectory (name, LINE_MAX);
    version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx (&amp;version_info))
        /*  On Windows NT the hosts file is well-hidden; on Win95 it's
         *  more visible                                                     */
        if (version_info.dwPlatformId == VER_PLATFORM_WIN32_NT)
            strcat (name, "\\system32\\drivers\\etc\\hosts");
        else
            strcat (name, "\\hosts");
    return (name);

#elif (defined (__UNIX__))
    return ("/etc/hosts");

#elif (defined (__VMS__))
    return ("/etc/hosts");              /*  Not correct -- needs more work   */

#elif (defined (__OS2__))
    /*  Under OS/2 the hosts information is stored in the "hosts" file which
     *  is in the directory pointed at by the %ETC% environment variable.
     *  If that environment variable is not set, then TCP/IP support is not
     *  properly installed.  In that instance we return "/mptn/etc/hosts"
     *  (the likely value on OS/2 Warp 3 Connect and OS/2 Warp 4) and hope
     *  for the best.
     */

    /*  A static array is used only because the other versions use a static
     *  array.  If the resulting file name will not fit in the space allowed
     *  then "/mtpn/etc/hosts" is used as before.
     */
    static char
        name [LINE_MAX + 1];
    char
        *etcenv = NULL;

    etcenv = getenv ("ETC");
    if (etcenv != NULL &amp;&amp; strlen (etcenv) &lt; (LINE_MAX - 6))
      { /*  We've already checked it will all fit.                           */
        strcpy (name, etcenv);
        strcat (name, "/hosts");
        return (name);
      }
    else
        return ("/mptn/etc/hosts");

#else
    return ("hosts");
#endif
}
</PRE>
<A NAME="get_name_server">&nbsp;</A>
<H3><A NAME="TOC361"><TT>get_name_server</TT></A></H3>
<PRE>
#include "sflsock.h"
int
get_name_server (struct sockaddr_in *ns_address, int ns_max)
</PRE>
<H4>Synopsis</H4>
<P>gets the addresses of the DNS servers defined in the TCP/IP
   configuration. The addresses are returned in a user-provided
   struct sockaddr_in array. The maximum number of addresses in
   this array is supplied as the ns_max argument. Return the
   number of address found.
<H4>Source Code - (sflsock.c)</H4>
<PRE>
{
    int
        ns_count = 0;                /*  Number of servers that we found  */

#if (defined (WIN32))
    static OSVERSIONINFO
        version_info;
    HKEY
        hkey;                           /*  Handle to returned reg. key      */
    static char
        registry_value [LINE_MAX + 1];  /*  DNS server info from registry    */
    long
        size = LINE_MAX;                /*  Max. size of returned value      */
    DWORD
        type;
    char
        *key,
        **address_list = NULL;
    int
        address_nbr;

    /*  Look in registry; this sometimes works, but not always               */
    version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx (&amp;version_info)
    &amp;&amp;  version_info.dwPlatformId == VER_PLATFORM_WIN32_NT)
        key = "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters";
    else
        key = "SYSTEM\\CurrentControlSet\\Services\\Vxd\\Mstcp\\Parameters";

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, key, 0,
        KEY_QUERY_VALUE, &amp;hkey) == ERROR_SUCCESS
    &amp;&amp;  RegQueryValueEx (hkey, "NameServer", NULL, (LPDWORD) &amp;type,
        (LPBYTE) registry_value, (LPDWORD) &amp;size) == ERROR_SUCCESS)
      {
        address_list = <A HREF="sfldoc.htm#tok_split">tok split</A> (registry_value);
        for (address_nbr = 0; address_list [address_nbr]; address_nbr++)
          {
            if (ns_count &gt;= ns_max)
                break;

            ns_address [ns_count].sin_family      = AF_INET;
            ns_address [ns_count].sin_port        = htons (DNS_PORT);
            ns_address [ns_count].sin_addr.s_addr =
                inet_addr (address_list [address_nbr]);
            ns_count++;
          }
        <A HREF="sfldoc.htm#tok_free">tok free</A> (address_list);
        RegCloseKey (hkey);
      }

#elif (defined (__UNIX__))
    static char
        buffer  [LINE_MAX + 1],
        address [16];
    FILE
        *resolver;
    int
        rc;

    resolver = <A HREF="sfldoc.htm#file_open">file open</A> ("/etc/resolv.conf", 'r');
    if (resolver)
        while (<A HREF="sfldoc.htm#file_read">file read</A> (resolver, buffer))
          {
            rc = sscanf (buffer, "nameserver %s", address);
            if (rc &gt; 0 &amp;&amp; rc != EOF)
              {
                if (ns_count &gt;= ns_max)
                    break;

                ns_address [ns_count].sin_family      = AF_INET;
                ns_address [ns_count].sin_port        = htons (DNS_PORT);
                ns_address [ns_count].sin_addr.s_addr = inet_addr (address);
                ns_count++;
              }
          }
    <A HREF="sfldoc.htm#file_close">file close</A> (resolver);

#elif (defined (__OS2__))
    static char
        buffer  [LINE_MAX + 1],
        address [16];
    char
        *etcenv   = NULL,
        *filename = NULL;
    FILE
        *resolver = NULL;
    int
        rc;

    /*  Under OS/2 the file controlling the resolver is stored in the        */
    /*  directory pointed at by the ETC environment variable.  It is called  */
    /*  resolv2 or resolv (I *think* that is the order of preference), so we */
    /*  try those two file names in that order.                              */

    /*  If the ETC environment variable is not set we try the /mptn/etc      */
    /*  directory since that is a likely default location for it.            */

    etcenv = getenv ("ETC");
    if (etcenv)
      {
        filename = mem_alloc (strlen(etcenv) + 10);
        if (!filename)
          return 0;                  /*  Cannot allocate memory for filename */

        strcpy (filename, etcenv);
        strcat (filename, "/resolv2");

        resolver = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r');

        if (! resolver)
          { /*  Not available under that filename, let's try the other one   */
            strcpy (filename, etcenv);
            strcat (filename, "/resolv");

            resolver = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'r');
          }
        mem_free (filename);
      }
    else
      { /*  No environment variable around, try using the defaults           */
        resolver = <A HREF="sfldoc.htm#file_open">file open</A> ("/mptn/etc/resolv2", 'r');
        if (! resolver)
            resolver = <A HREF="sfldoc.htm#file_open">file open</A> ("/mptn/etc/resolv", 'r');
      }
    if (resolver)
        while (<A HREF="sfldoc.htm#file_read">file read</A> (resolver, buffer))
          {
            rc = sscanf (buffer, "nameserver %s", address);
            if (rc &gt; 0 &amp;&amp; rc != EOF)
              {
                if (ns_count &gt;= ns_max)
                    break;

                ns_address [ns_count].sin_family      = AF_INET;
                ns_address [ns_count].sin_port        = htons (DNS_PORT);
                ns_address [ns_count].sin_addr.s_addr = inet_addr (address);
                ns_count++;
              }
          }
    <A HREF="sfldoc.htm#file_close">file close</A> (resolver);
#endif

    return (ns_count);
}
</PRE>
<H2><A NAME="TOC362">Symbol-table functions</A></H2>
<P>Filename: sflsymb.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 93/12/27 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/08/31
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Symbol lookup is by name. Symbols contain a string value and a
   pointer to an caller-defined memory block. The symbol-table
   functions let you create and manage symbol tables. The
   functions are designed to be as general as possible (to support
   a wide variety of applications), but at the same time fast. The
   symbol table data structure is based on a combined linked list
   &amp; hash table representation. The file sflsymb.h contains
   definitions for the various structures and external functions
   used in the sflsymb.c. Both the linked-list and hash-table
   representations have a guaranteed order. In the linked-list,
   new symbols are pushed on to the head of the list. In the hash
   table each bucket just contains a pointer to a linked-list of
   symbols. When a new symbol is created, it is pushed onto the
   front of this list. The reason that both data structures are
   used is to make the algorithm faster. Each representation has
   its stengths and weaknesses. For instance, if you wanted to
   lookup a symbol table entry for a given name using the hash
   table you could find it immediately, whereas with the linked-
   list, you would need to traverse most of the table to find the
   symbol. Some of these functions are called through macros that
   add the filename and line number of the call, for tracing. Do
   NOT call these functions directly.
<H4>List of Functions</H4>
<UL>
<LI>SYMTAB * <A HREF="sfldoc.htm#sym_create_table_">sym create table </A><BR>
   (const char *source_file, word source_line);
</LI>
<LI>void <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>void <A HREF="sfldoc.htm#sym_empty_table">sym empty table</A><BR>
   (SYMTAB *symtab);
</LI>
<LI>int <A HREF="sfldoc.htm#sym_merge_tables">sym merge tables</A><BR>
   (SYMTAB *symtab, const SYMTAB *import);
</LI>
<LI>SYMBOL * <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A><BR>
   (const SYMTAB *symtab, const char *name);
</LI>
<LI>SYMBOL * <A HREF="sfldoc.htm#sym_create_symbol_">sym create symbol </A><BR>
   (SYMTAB *symtab, const char *name, const char *val, const char
   *source_file, word source_line);
</LI>
<LI>SYMBOL * <A HREF="sfldoc.htm#sym_assume_symbol_">sym assume symbol </A><BR>
   (SYMTAB *symtab, const char *name, const char *val, const char
   *source_file, word source_line);
</LI>
<LI>SYMBOL * <A HREF="sfldoc.htm#sym_delete_symbol">sym delete symbol</A><BR>
   (SYMTAB *symtab, SYMBOL *symbol);
</LI>
<LI>char * <A HREF="sfldoc.htm#sym_get_value">sym get value</A><BR>
   (const SYMTAB *symtab, const char *name, const char
   *default_value);
</LI>
<LI>long <A HREF="sfldoc.htm#sym_get_number">sym get number</A><BR>
   (const SYMTAB *symtab, const char *key, const long
   default_value);
</LI>
<LI>Bool <A HREF="sfldoc.htm#sym_get_boolean">sym get boolean</A><BR>
   (const SYMTAB *symtab, const char *key, const Bool
   default_value);
</LI>
<LI>void <A HREF="sfldoc.htm#sym_set_value">sym set value</A><BR>
   (SYMBOL *symbol, const char *value);
</LI>
<LI>int <A HREF="sfldoc.htm#sym_exec_all">sym exec all</A><BR>
   (const SYMTAB *symtab, symfunc handler, ...);
</LI>
<LI>int <A HREF="sfldoc.htm#sym_hash">sym hash</A><BR>
   (const char *name);
</LI>
<LI>void <A HREF="sfldoc.htm#sym_sort_table">sym sort table</A><BR>
   (SYMTAB *symtab, symsort sort_function);
</LI>
<LI>char * <A HREF="sfldoc.htm#symb2strt_">symb2strt </A><BR>
   (const SYMTAB *symtab, const char *source_file, word
   source_line);
</LI>
<LI>SYMTAB * <A HREF="sfldoc.htm#strt2symb_">strt2symb </A><BR>
   (char **strings, const char *source_file, word source_line);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#symb2descr_">symb2descr </A><BR>
   (const SYMTAB *symtab, const char *source_file, word
   source_line);
</LI>
<LI>SYMTAB * <A HREF="sfldoc.htm#descr2symb_">descr2symb </A><BR>
   (const DESCR *descr, const char *source_file, word
   source_line);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflsymb.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SYM_HASH_SIZE</B>  </TT>
<TD ALIGN="LEFT">256 /* Assumed by sym_hash () */
<TR><TD ALIGN="LEFT"><TT><B>_SFLSYMB_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>descr2symb(d)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>strt2symb(s)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>sym_assume_symbol(t,n,v)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>sym_create_symbol(t,n,v)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>sym_create_table()</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>symb2descr(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
<TR><TD ALIGN="LEFT"><TT><B>symb2strt(t)</B>  </TT>
<TD ALIGN="LEFT">(various)
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>symfunc</B>  </TT>
<TD ALIGN="LEFT">Bool (*) (SYMBOL *, ...)
<TR><TD ALIGN="LEFT"><TT><B>symsort</B>  </TT>
<TD ALIGN="LEFT">int (*) (const void *symb1, const void *symb2)
</TABLE>
<A NAME="sym_create_table_">&nbsp;</A>
<H3><A NAME="TOC363"><TT>sym_create_table_</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMTAB *
sym_create_table_ (
    const char *filename,               /*  Name of source file making call  */
    word        lineno)                 /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Creates a new symbol table. Use the sym_create_table macro to
   call this function! Returns a SYMTAB pointer which you must use
   in all future references to the symbol table. The symbol table
   is maintained in memory until the program ends or you use
   <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A>() to delete it. Returns null if there was
   not enough memory to create the symbol table.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMTAB
        *table;                         /*  Pointer to created table         */
    int
        hash_index;                     /*  Index into hash bucket           */

    /*  Allocate by going directly to mem_alloc_ function                    */
    table = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (NULL, sizeof (SYMTAB), filename, lineno);
    if (table)
      {
        table-&gt; symbols = NULL;         /*  No symbols attached yet          */
        table-&gt; size    = 0;
        for (hash_index = 0; hash_index &lt; SYM_HASH_SIZE; hash_index++)
            table-&gt; hash [hash_index] = NULL;
      }
    return (table);
}
</PRE>
<A NAME="sym_delete_table">&nbsp;</A>
<H3><A NAME="TOC364"><TT>sym_delete_table</TT></A></H3>
<PRE>
#include "sflsymb.h"
void
sym_delete_table (
    SYMTAB *table)                      /*  Symbol table to delete           */
</PRE>
<H4>Synopsis</H4>
<P>Deletes the given symbol table. First frees any memory space
   used by the table and attached symbols, including the user data
   block if that is not null. If the table argument is NULL, does
   nothing.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol,                        /*  Pointer to symbol                */
        *next = NULL;                   /*    and to next symbol in list     */

    if (!table)
        return;                         /*  Do nothing if argument is null   */

    for (symbol = table-&gt; symbols; symbol; symbol = next)
      {
        next = symbol-&gt; next;           /*  Keep track of next in list       */
        mem_free (symbol-&gt; value);      /*  Free value if used               */
        mem_free (symbol);              /*  Finally free symbol and name     */
      }
    mem_free (table);                   /*  Now free the table               */
}
</PRE>
<A NAME="sym_empty_table">&nbsp;</A>
<H3><A NAME="TOC365"><TT>sym_empty_table</TT></A></H3>
<PRE>
#include "sflsymb.h"
void
sym_empty_table (
    SYMTAB *table)                      /*  Symbol table to empty            */
</PRE>
<H4>Synopsis</H4>
<P>Empties the given symbol table, by deleting all symbols. You
   can then add new symbols. If the table argument is NULL, does
   nothing.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol,                        /*  Pointer to symbol                */
        *next = NULL;                   /*    and to next symbol in list     */
    int
        hash_index;                     /*  Index into hash bucket           */

    if (!table)
        return;                         /*  Do nothing if argument is null   */

    for (symbol = table-&gt; symbols; symbol; symbol = next)
      {
        next = symbol-&gt; next;           /*  Keep track of next in list       */
        mem_free (symbol-&gt; value);      /*  Free value if used               */
        mem_free (symbol);              /*  Finally free symbol and name     */
      }
    table-&gt; symbols = NULL;             /*  No symbols attached yet          */
    table-&gt; size    = 0;
    for (hash_index = 0; hash_index &lt; SYM_HASH_SIZE; hash_index++)
        table-&gt; hash [hash_index] = NULL;
}
</PRE>
<A NAME="sym_merge_tables">&nbsp;</A>
<H3><A NAME="TOC366"><TT>sym_merge_tables</TT></A></H3>
<PRE>
#include "sflsymb.h"
int
sym_merge_tables (
    SYMTAB *table,                      /*  Symbol table to import into      */
    const SYMTAB *import)               /*  Symbol table to import from      */
</PRE>
<H4>Synopsis</H4>
<P>Imports the contents of one symbol table into another. Will
   overwrite symbols with the same name. Returns the number of
   symbols imported. If there is a lack of available memory, will
   stop importing.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Next symbol in table             */
    int
        count = 0;

    ASSERT (table);
    ASSERT (import);

    for (symbol = import-&gt; symbols; symbol; symbol = symbol-&gt; next)
      {
        if (<A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (table, symbol-&gt; name, symbol-&gt; value) == NULL)
            break;
        count++;
      }
    return (count);
}
</PRE>
<A NAME="sym_lookup_symbol">&nbsp;</A>
<H3><A NAME="TOC367"><TT>sym_lookup_symbol</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMBOL *
sym_lookup_symbol (
    const SYMTAB *table,                /*  Symbol table to search           */
    const char   *name)                 /*  Symbol name to search for        */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a symbol, by name, in the specified symbol table.
   Returns a pointer to the symbol if found, or NULL if not found.
   If more than one symbol with the same name exists, finds the
   latest entry.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Search through hash bucket list  */

    ASSERT (table);

    for (symbol = table-&gt; hash [<A HREF="sfldoc.htm#sym_hash">sym hash</A> (name)];
         symbol;
         symbol = symbol-&gt; h_next)
      {
        if (streq (symbol-&gt; name, name))
            return (symbol);
      }
    return (NULL);
}
</PRE>
<A NAME="sym_create_symbol_">&nbsp;</A>
<H3><A NAME="TOC368"><TT>sym_create_symbol_</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMBOL *
sym_create_symbol_ (
    SYMTAB *table,                      /*  Symbol table to insert into      */
    const char *name,                   /*  Name of symbol to create         */
    const char *value,                  /*  Value of symbol to create        */
    const char *filename,               /*  Name of source file making call  */
    word        lineno)                 /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Creates a new symbol in the specified table. Use the
   sym_create_symbol macro to call this function! Returns a SYMBOL
   pointer to the created symbol, or NULL if there was not enough
   memory to create the symbol. Initialises the symbol name and
   value to the values supplied. Sets symbol data to NULL. You can
   set this yourself if you need to, after calling this function.
   Use mem_alloc() or mem_strdup() to assign values to the data
   block, otherwise you may cause problems when you delete the
   symbol or symbol table, since these functions free these
   fields. You can create several symbols with the same name; the
   last-defined is always placed before older instances and will
   be found first by <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A>().
<H4>Examples</H4>
<PRE>
    SYMTAB
        *symbol_table;
    SYMBOL
        *new_symbol;

    symbol_table = sym_create_table ();
    ASSERT (symbol_table);
    new_symbol = sym_create_symbol (symbol_table, "This name", "This value");
    if (new_symbol)
      {
        new_symbol-&gt; data = mem_alloc (sizeof (my_block));
        memcpy (new_symbol-&gt; data, my_block);
      }
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Allocated symbol                 */
    int
        hash;                           /*  Hash bucket no. for symbol       */

    ASSERT (table);

    symbol = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (NULL, sizeof (*symbol) + strlen (name) + 1,
                         filename, lineno);
    if (symbol)
      {
        /*  Set the symbol pointers and fields                               */
        hash = <A HREF="sfldoc.htm#sym_hash">sym hash</A> (name);
        symbol-&gt; next   = table-&gt; symbols;
        symbol-&gt; prev   = NULL;
        symbol-&gt; h_next = table-&gt; hash [hash];
        symbol-&gt; h_prev = NULL;
        symbol-&gt; name   = (char *) symbol + sizeof (*symbol);
        symbol-&gt; value  = mem_strdup (value);
        symbol-&gt; data   = NULL;
        symbol-&gt; hash   = (byte) hash;
        strcpy (symbol-&gt; name, name);

        if (table-&gt; symbols)
            table-&gt; symbols-&gt; prev = symbol;
        table-&gt; symbols = symbol;

        if (table-&gt; hash [hash])
            table-&gt; hash [hash]-&gt; h_prev = symbol;
        table-&gt; hash [hash] = symbol;
        table-&gt; size++;
      }
    return (symbol);
}
</PRE>
<A NAME="sym_assume_symbol_">&nbsp;</A>
<H3><A NAME="TOC369"><TT>sym_assume_symbol_</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMBOL *
sym_assume_symbol_ (
    SYMTAB *table,                      /*  Symbol table to search           */
    const char *name,                   /*  Name of symbol to find/create    */
    const char *value,                  /*  Value of symbol to create        */
    const char *filename,               /*  Name of source file making call  */
    word        lineno)                 /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Searches for a symbol, by name, in the specified symbol table.
   If the symbol does not exist, creates the symbol as specified.
   Returns a SYMBOL pointer to the existing or new symbol, or NULL
   if a new symbol could not be created. The lookup and creation
   follow the same rules as <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A>() and
   <A HREF="sfldoc.htm#sym_create_symbol">sym create symbol</A>(). The symbol's value is set to the
   supplied value in all cases. Do not call this function
   directly; pass through the sym_assume_symbol macro.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Allocated or found symbol        */

    ASSERT (table);

    symbol = <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A> (table, name);
    if (symbol)
      {
        /*  Update the symbol value, if it has changed                       */
        if (symbol-&gt; value &amp;&amp; strneq (symbol-&gt; value, value))
            <A HREF="sfldoc.htm#sym_set_value">sym set value</A> (symbol, value);
      }
    else
        symbol = <A HREF="sfldoc.htm#sym_create_symbol_">sym create symbol </A> (table, name, value, filename, lineno);

    return (symbol);
}
</PRE>
<A NAME="sym_delete_symbol">&nbsp;</A>
<H3><A NAME="TOC370"><TT>sym_delete_symbol</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMBOL *
sym_delete_symbol (
    SYMTAB *table,                      /*  Symbol table to search           */
    SYMBOL *symbol)                     /*  Symbol to delete                 */
</PRE>
<H4>Synopsis</H4>
<P>Removes the specified symbol from the symbol table and looks
   through the table for another with the same name. Returns a
   pointer to the next symbol, or NULL if no further symbols were
   found with the same name. Deallocates the symbol value, if not
   NULL.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *next;                          /*  Next symbol with same name       */

    ASSERT (table);
    ASSERT (symbol);

    /*  Find a symbol with the same name, or NULL if none found              */
    next = symbol;
    for (next = symbol-&gt; h_next; next; next = next-&gt; h_next)
        if (streq (next-&gt; name, symbol-&gt; name))
            break;

    /*  Fix up the pointers and remove the original symbol                   */
    if (symbol-&gt; prev)
        symbol-&gt; prev-&gt; next = symbol-&gt; next;
    else
        table-&gt; symbols = symbol-&gt; next;

    if (symbol-&gt; next)
        symbol-&gt; next-&gt; prev = symbol-&gt; prev;

    if (symbol-&gt; h_prev)
        symbol-&gt; h_prev-&gt; h_next = symbol-&gt; h_next;
    else
        table-&gt; hash [symbol-&gt; hash] = symbol-&gt; h_next;

    if (symbol-&gt; h_next)
        symbol-&gt; h_next-&gt; h_prev = symbol-&gt; h_prev;

    table-&gt; size--;
    mem_free (symbol-&gt; value);
    mem_free (symbol);

    return (next);
}
</PRE>
<A NAME="sym_exec_all">&nbsp;</A>
<H3><A NAME="TOC371"><TT>sym_exec_all</TT></A></H3>
<PRE>
#include "sflsymb.h"
int
sym_exec_all (
    const SYMTAB *table,                /*  Symbol table to process          */
    symfunc the_function, ...           /*  Function to call                 */
)
</PRE>
<H4>Synopsis</H4>
<P>Traverses the symbol table, executing the specified function
   for every symbol in the table. The function receives one or
   more arguments: the first argument is a SYMBOL pointer to the
   symbol, and following arguments as supplied by the caller.
   Continues so long as the function returns TRUE; halts when
   every symbol has been processed, or when the function returns
   FALSE. Returns the number of symbols processed without errors.
   The symbols are processed in reverse creation order; the newest
   symbol is processed first.
<H4>Examples</H4>
<PRE>
    static Bool
    dump_symbol (SYMBOL *symbol, ...)
    {
        printf ("%s = %s\n", symbol-&gt; name, symbol-&gt; value);
        return (TRUE);
    }

    SYMTAB
        *table;

    table = sym_create_table ();
    sym_create_symbol (table, "Symbol 1", "value 1");
    sym_create_symbol (table, "Symbol 2", "value 2");
    sym_exec_all (table, dump_symbol);
    sym_delete_table (table);
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Next symbol in table             */
    va_list
        argptr;                         /*  Argument list pointer            */
    int
        count = 0;                      /*  Number of symbols processed ok   */

    ASSERT (table);

    va_start (argptr, the_function);    /*  Start variable args processing   */
    for (symbol = table-&gt; symbols; symbol; symbol = symbol-&gt; next)
      {
        if ((*the_function) (symbol, argptr))
            count++;
        else
            break;
      }
    va_end (argptr);                    /*  End variable args processing     */
    return (count);
}
</PRE>
<A NAME="sym_hash">&nbsp;</A>
<H3><A NAME="TOC372"><TT>sym_hash</TT></A></H3>
<PRE>
#include "sflsymb.h"
int
sym_hash (
    const char *name)
</PRE>
<H4>Synopsis</H4>
<P>Computes the hash value for a null-delimited string. The
   algorithm used is a simple 8-bit checksum of the characters in
   the string. The hash is within the range 0 .. SYM_HASH_SIZE -
   1.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    int
        hash;                           /*  Computed hash value              */

    for (hash = 0; *name; name++)
        hash += *name;

    return (hash &amp; (SYM_HASH_SIZE - 1));
}
</PRE>
<A NAME="sym_get_value">&nbsp;</A>
<H3><A NAME="TOC373"><TT>sym_get_value</TT></A></H3>
<PRE>
#include "sflsymb.h"
char *
sym_get_value (
    const SYMTAB *table,                /*  Symbol table to process          */
    const char *name,                   /*  Name of symbol to look for       */
    const char *default_value)          /*  Value to return if not defined   */
</PRE>
<H4>Synopsis</H4>
<P>Returns value for specified symbol, if defined in table, or a
   default value otherwise. You can use this in situations where a
   symbol does not need to exist, and where frequent look-up by
   name is required. The symbol table must exist and be populated
   beforehand as appropriate. Returns a pointer to the value; you
   should never write to this string since it may exist as a
   string constant, not writable memory.
<H4>Examples</H4>
<PRE>
    value = sym_get_value (env, "PATH", NULL);
    if (!value)
        puts ("PATH not defined");
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Search through symbol table      */

    ASSERT (table);
    symbol = <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A> (table, name);
    if (symbol)
        return (symbol-&gt; value);
    else
        return ((char *) default_value);
}
</PRE>
<A NAME="sym_get_number">&nbsp;</A>
<H3><A NAME="TOC374"><TT>sym_get_number</TT></A></H3>
<PRE>
#include "sflsymb.h"
long
sym_get_number (
    const SYMTAB *table,                /*  Symbol table to process          */
    const char *name,                   /*  Name of symbol to look for       */
    const long default_value)           /*  Value to return if not defined   */
</PRE>
<H4>Synopsis</H4>
<P>Returns value for specified symbol, as a long value. If the
   symbol is not defined in the table, returns a default value.
<H4>Examples</H4>
<PRE>
    value = sym_get_number (env, "MAX_USERS", 10);
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    char
        *value;

    value = <A HREF="sfldoc.htm#sym_get_value">sym get value</A> (table, name, NULL);
    return (value? atol (value): default_value);
}
</PRE>
<A NAME="sym_get_boolean">&nbsp;</A>
<H3><A NAME="TOC375"><TT>sym_get_boolean</TT></A></H3>
<PRE>
#include "sflsymb.h"
Bool
sym_get_boolean (
    const SYMTAB *table,                /*  Symbol table to process          */
    const char *name,                   /*  Name of symbol to look for       */
    const Bool default_value)           /*  Value to return if not defined   */
</PRE>
<H4>Synopsis</H4>
<P>Returns value for specified symbol, as TRUE or FALSE. If the
   symbol is not defined in the table, returns a default value.
<H4>Examples</H4>
<PRE>
    value = sym_get_boolean (env, "CONNECTS_ENABLED", TRUE);
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    char
        *value;

    value = <A HREF="sfldoc.htm#sym_get_value">sym get value</A> (table, name, NULL);
    return (value? (<A HREF="sfldoc.htm#conv_str_bool">conv str bool</A> (value) != 0): default_value);
}
</PRE>
<A NAME="sym_set_value">&nbsp;</A>
<H3><A NAME="TOC376"><TT>sym_set_value</TT></A></H3>
<PRE>
#include "sflsymb.h"
void
sym_set_value (
    SYMBOL *symbol,                     /*  Symbol to change                 */
    const char *value)                  /*  New value to assign              */
</PRE>
<H4>Synopsis</H4>
<P>Assigns a new value for the symbol; this frees any previously
   assigned value and duplicates the supplied value, which must be
   a null terminated string. If you want to assign binary values,
   you can use the symbol's data block. If the value is NULL, any
   existing value is freed and the symbol value pointer is set to
   NULL.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    ASSERT (symbol);

    mem_strfree (&amp;symbol-&gt; value);      /*  Free existing value if any       */
    symbol-&gt; value = mem_strdup (value);
}
</PRE>
<A NAME="sym_sort_table">&nbsp;</A>
<H3><A NAME="TOC377"><TT>sym_sort_table</TT></A></H3>
<PRE>
#include "sflsymb.h"
void
sym_sort_table (SYMTAB *table, symsort sort_function)
</PRE>
<H4>Synopsis</H4>
<P>Sorts a symbol table using the qsort library function. To
   access the symbol table, use the next and prev symbol pointers.
   If the sort_function is NULL, sorts on the symbol name.
<H4>Examples</H4>
<PRE>
    int compare (const void *sym1, const void *sym2)
    {
        return (strcmp (*(SYMBOL **) sym1)-&gt; value,
                        *(SYMBOL **) sym2)-&gt; value));
    }
    SYMTAB
        *table;
    SYMBOL
        *symbol;

    table = sym_create_table ();
    sym_create_symbol (table, "Symbol 1", "A");
    sym_create_symbol (table, "Symbol 2", "D");
    sym_create_symbol (table, "Symbol 4", "B");
    sym_create_symbol (table, "Symbol 3", "C");
    sym_sort_table (table, compare);
    for (symbol = symtab-&gt; symbols; symbol; symbol = symbol-&gt; next)
        printf ("Symbol %s = %s\n", symbol-&gt; name, symbol-&gt; value);
    sym_delete_table (table);
</PRE>
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol,
        **array;
    int
        index;

    ASSERT (table);

    if (table-&gt; size == 0)
        return;

    array = mem_alloc (table-&gt; size * sizeof (SYMBOL *));
    if (array == NULL)
        return;                         /*  Not enough memory                */

    /*  Build sorting array                                                  */
    for (symbol = table-&gt; symbols, index = 0;
         symbol &amp;&amp; index &lt; table-&gt; size;
         symbol = symbol-&gt; next, index++)
        array [index] = symbol;

    if (sort_function == NULL)
        sort_function = sym_sort_by_name;

    qsort ((void *) array, table-&gt; size, sizeof (SYMBOL *), sort_function);

    /*  Re-order symbol table links                                          */
    table-&gt; symbols = array [0];
    for (index = 0; index &lt; table-&gt; size; index++)
      {
        symbol = array [index];
        symbol-&gt; prev = (index &gt; 0)? array [index -1]: NULL;
        symbol-&gt; next = (index &lt; table-&gt; size - 1)? array [index + 1]: NULL;
      }
    mem_free (array);
}
</PRE>
<A NAME="symb2strt_">&nbsp;</A>
<H3><A NAME="TOC378"><TT>symb2strt_</TT></A></H3>
<PRE>
#include "sflsymb.h"
char **
symb2strt_ (
    const SYMTAB *symtab,               /*  Symbol table to export           */
    const char   *filename,             /*  Name of source file making call  */
    word          lineno)               /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Exports the symbol table as an array of strings of the format
   "name=value". Returns a pointer to the array. The array is
   allocated dynamically. The array ends with a NULL string. To
   free the table, call <A HREF="sfldoc.htm#strtfree">strtfree</A>(). If there was not enough
   memory to allocate the table, returns NULL. See also
   <A HREF="sfldoc.htm#symb2env">symb2env</A>(). Do not call this function directly: pass
   through the symb2strt macro.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMBOL
        *symbol;                        /*  Pointer to symbol                */
    char
        **strings,                      /*  Returned string array            */
        *name_and_value;                /*  Name=value string                */
    int
        string_nbr;                     /*  Index into symbol_array          */

    if (!symtab)
        return (NULL);                  /*  Return NULL if argument is null  */

    /*  Allocate the array of pointers with one slot for the final NULL      */
    strings = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (NULL, sizeof (char *) * (symtab-&gt; size + 1),
                          filename, lineno);
    if (strings)
      {
        string_nbr = 0;
        for (symbol = symtab-&gt; symbols; symbol; symbol = symbol-&gt; next)
          {
            /*  Allocate space for "name=value" plus final null char         */
            name_and_value = <A HREF="sfldoc.htm#mem_alloc_">mem alloc </A> (NULL, strlen (symbol-&gt; name)
                                       + strlen (symbol-&gt; value) + 2,
                                         filename, lineno);
            if (name_and_value)         /*  Fail-safe if no memory left      */
                sprintf (name_and_value, "%s=%s", symbol-&gt; name,
                                                  symbol-&gt; value);
            strings [string_nbr++] = name_and_value;
          }
        strings [string_nbr] = NULL;    /*  Store final null pointer         */
      }
    return (strings);
}
</PRE>
<A NAME="strt2symb_">&nbsp;</A>
<H3><A NAME="TOC379"><TT>strt2symb_</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMTAB *
strt2symb_ (
    char      **table,                  /*  String table to convert          */
    const char *filename,               /*  Name of source file making call  */
    word        lineno)                 /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Converts a table of strings into a symbol table. The input
   table consists of an array of null-terminated strings,
   terminated in a null pointer. Ignores any strings that don't
   look like: "name=value". If the table contains multiple strings
   with the same name, the last instance is stored in the symbol
   table. Note that if you omit the last null pointer in the input
   table, you will probably get an addressing error. Returns NULL
   if there was insufficient memory to allocate the symbol table,
   or if the input argument was null. Do not call this function
   directly: pass through the strt2symb macro.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMTAB
        *symtab;                        /*  Allocated symbol table           */
    char
        *equals;                        /*  Position of '=' in string        */
    int
        string_nbr;                     /*  Index into string table          */

    if (!table)
        return (NULL);                  /*  Return NULL if argument is null  */

    symtab = <A HREF="sfldoc.htm#sym_create_table_">sym create table </A> (filename, lineno);
    if (symtab)
      {
        for (string_nbr = 0; table [string_nbr]; string_nbr++)
          {
            equals = strchr (table [string_nbr], '=');
            if (equals)
              {
                *equals = '\0';         /*  Cut into two strings             */
                <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, table [string_nbr], equals + 1);
                *equals = '=';          /*  Restore previous state           */
              }
          }
      }
    return (symtab);
}
</PRE>
<A NAME="symb2descr_">&nbsp;</A>
<H3><A NAME="TOC380"><TT>symb2descr_</TT></A></H3>
<PRE>
#include "sflsymb.h"
DESCR *
symb2descr_ (
    const SYMTAB *symtab,               /*  Symbol table to export           */
    const char   *filename,             /*  Name of source file making call  */
    word          lineno)               /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Exports the symbol table as a table of strings in a DESCR
   block. Each string has the format "name=value". The block ends
   with a null string. Returns a pointer to the descriptor. The
   descriptor is allocated dynamically; to free it, use
   mem_free(). If there was not enough memory to allocate the
   descriptor, returns NULL. Do not call this function directly:
   pass through the symb2descr macro.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    char
        **strings;                      /*  Formatted string array           */
    DESCR
        *descr;                         /*  Formatted descriptor             */

    if (!symtab)
        return (NULL);                  /*  Return NULL if argument is null  */

    /*  Convert symbol table to strings                                      */
    strings = symb2strt_ (symtab, filename, lineno);
    descr   = <A HREF="sfldoc.htm#strt2descr">strt2descr</A> (strings);     /*  And build into descriptor        */
    <A HREF="sfldoc.htm#strtfree">strtfree</A> (strings);
    return (descr);
}
</PRE>
<A NAME="descr2symb_">&nbsp;</A>
<H3><A NAME="TOC381"><TT>descr2symb_</TT></A></H3>
<PRE>
#include "sflsymb.h"
SYMTAB *
descr2symb_ (
    const DESCR  *descr,                /*  Descriptor to convert            */
    const char   *filename,             /*  Name of source file making call  */
    word          lineno)               /*  Line number in calling source    */
</PRE>
<H4>Synopsis</H4>
<P>Converts a DESCR block into a symbol table. The descriptor
   consists of a block of null-terminated strings, terminated in a
   double null byte. Ignores any strings that don't look like:
   "name=value". If the block contains multiple strings with the
   same name, the last instance is stored in the symbol table.
   Returns NULL if there was not enough memory to allocate the
   symbol table, or if the input argument was null. Do not call
   this function directly: pass through the descr2symb macro.
<H4>Source Code - (sflsymb.c)</H4>
<PRE>
{
    SYMTAB
        *symtab;                        /*  Allocated symbol table           */
    char
        **strings;                      /*  Formatted string array           */

    if (!descr)
        return (NULL);                  /*  Return NULL if argument is null  */

    strings = <A HREF="sfldoc.htm#descr2strt">descr2strt</A> (descr);       /*  Convert descriptor to strings    */
    symtab  = <A HREF="sfldoc.htm#strt2symb_">strt2symb </A> (strings, filename, lineno);
    <A HREF="sfldoc.htm#strtfree">strtfree</A> (strings);
    return (symtab);
}
</PRE>
<H2><A NAME="TOC382">System-level functions (assertions,...)</A></H2>
<P>Filename: sflsyst.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/04/13 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides miscellaneous system-level functions.
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#sys_assert">sys assert</A><BR>
   (const char *filename, unsigned line_number);
</LI>
<LI>char * <A HREF="sfldoc.htm#sys_name">sys name</A><BR>
   (void);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflsyst.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLSYST_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="sys_assert">&nbsp;</A>
<H3><A NAME="TOC383"><TT>sys_assert</TT></A></H3>
<PRE>
#include "sflsyst.h"
void
sys_assert (const char *File, unsigned Line)
</PRE>
<H4>Synopsis</H4>
<P>Displays an 'assertion failed' message and aborts the program.
   This function is required by prelude.h if you compile with the
   DEBUG symbol.
<H4>Source Code - (sflsyst.c)</H4>
<PRE>
{
#   if (defined (__WINDOWS__) &amp;&amp; !defined (_CONSOLE))
    static char
        buffer [LINE_MAX];              /*  Formatted error message          */
    MSG
        msg;
    Bool
        quit;
    int
        rc;                             /*  MessageBox return code           */

    sprintf (buffer, "Module %s, line %u", File, Line);
    /*  If WM_QUIT is in the queue the message box won't show                */
    quit = PeekMessage(&amp;msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
    rc   = MessageBox (NULL, buffer, "Assertion failed!",
                       MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);
    if (quit)
        PostQuitMessage (msg.wParam);
    if (rc != IDABORT)
        return;
#   else
    fflush  (stdout);
    fprintf (stderr, "\nAssertion failed: %s, line %u\n", File, Line);
    fflush  (stderr);
#   endif
    abort   ();
}
</PRE>
<A NAME="sys_name">&nbsp;</A>
<H3><A NAME="TOC384"><TT>sys_name</TT></A></H3>
<PRE>
#include "sflsyst.h"
char *
sys_name (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a static buffer with the type or name of OS.
<H4>Source Code - (sflsyst.c)</H4>
<PRE>
{
#if (defined (__WINDOWS__))
#   if (defined (WIN32))
    static char
        name [30];

    OSVERSIONINFO
        version_info;

    version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx (&amp;version_info))
      {
        if (version_info.dwPlatformId == VER_PLATFORM_WIN32_NT)
            sprintf (name, "Windows NT %ld.%ld",
                            version_info.dwMajorVersion,
                            version_info.dwMinorVersion);
        else
        if (version_info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            sprintf (name, "Windows 95 %ld.%ld",
                            version_info.dwMajorVersion,
                            version_info.dwMinorVersion);
        else
            sprintf (name, "Windows %ld.%ld with win32s",
                            version_info.dwMajorVersion,
                            version_info.dwMinorVersion);
      }
    return (name);
#   else
        return ("Windows 3.x");
#   endif
#elif (defined (__UNIX__))
#   if (defined (__UTYPE_AUX))
        return ("UNIX Type: Apple AUX");
#   elif (defined (__UTYPE_DECALPHA))
        return ("UNIX Type: Digital UNIX (Alpha)");
#   elif (defined (__UTYPE_IBMAIX))
        return ("UNIX Type: IBM RS/6000 AIX");
#   elif (defined (__UTYPE_HPUX))
        return ("UNIX Type: HP/UX");
#   elif (defined (__UTYPE_LINUX))
        return ("UNIX Type: Linux");
#   elif (defined (__UTYPE_MIPS))
        return ("UNIX Type: MIPS");
#   elif (defined (__UTYPE_NETBSD))
        return ("UNIX Type: NetBSD");
#   elif (defined (__UTYPE_NEXT))
        return ("UNIX Type: NeXT");
#   elif (defined (__UTYPE_SCO))
        return ("UNIX Type: SCO UNIX");
#   elif (defined (__UTYPE_IRIX))
        return ("UNIX Type: Silicon Graphics IRIX");
#   elif (defined (__UTYPE_SUNOS))
        return ("UNIX Type: SunOS");
#   elif (defined (__UTYPE_SUNSOLARIS))
        return ("UNIX Type: Sun Solaris");
#   elif (defined (__UTYPE_UNIXWARE))
        return ("UNIX Type: SCO UNIXWare");
#   else
        return ("UNIX Type: Generic");
#   endif
#elif (defined (__VMS__))
    return ("UNIX Type: Digital OpenVMS");
#elif (defined (__OS2__))
    return ("UNIX Type: IBM OS/2");
#elif (defined (__MSDOS__))
    return ("MS-DOS");
#else
    return ("Unknown");
#endif
}
</PRE>
<H2><A NAME="TOC385">HTTP and CGI Support functions</A></H2>
<P>Filename: sflhttp.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/05/31 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/01/15
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides various functions that support HTTP and CGI
   programming, including escaping/unescaping, and CGI data
   manipulation.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#http_escape">http escape</A><BR>
   (const char *string, char *result);
</LI>
<LI>size_t <A HREF="sfldoc.htm#http_escape_size">http escape size</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#http_unescape">http unescape</A><BR>
   (char *string, char *result);
</LI>
<LI>char * <A HREF="sfldoc.htm#http_query2strt">http query2strt</A><BR>
   (const char *query);
</LI>
<LI>SYMTAB * <A HREF="sfldoc.htm#http_query2symb">http query2symb</A><BR>
   (const char *query);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#http_query2descr">http query2descr</A><BR>
   (const char *query);
</LI>
<LI>size_t <A HREF="sfldoc.htm#http_encode_meta">http encode meta</A><BR>
   (char *output, const char *input, size_t outmax);
</LI>
<LI>int <A HREF="sfldoc.htm#cgi_parse_query_vars">cgi parse query vars</A><BR>
   (SYMTAB *symtab, const char *query, const char *prefix);
</LI>
<LI>int <A HREF="sfldoc.htm#cgi_parse_file_vars">cgi parse file vars</A><BR>
   (SYMTAB *symtab, FILE *file, const char *prefix, size_t size);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#http_multipart_decode">http multipart decode</A><BR>
   (const char *mime_file, const char *store_path, const char
   *local_format);
</LI>
<LI>Bool <A HREF="sfldoc.htm#is_full_url">is full url</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#cgi_get_input">cgi get input</A><BR>
   (int iMethod);
</LI>
<LI>char * <A HREF="sfldoc.htm#cgi_fld_by_name">cgi fld by name</A><BR>
   (char *strFld, char *strIn, char *strRetBuf);
</LI>
<LI>char * <A HREF="sfldoc.htm#cgi_fld_by_index">cgi fld by index</A><BR>
   (int iPos, char *strIn, char *strRetBuf, char *strFldName);
</LI>
<LI>int <A HREF="sfldoc.htm#cgi_fld_len_by_index">cgi fld len by index</A><BR>
   (int iPos, char *strIn, int *iDataLen, int *iNameLen);
</LI>
<LI>int <A HREF="sfldoc.htm#displayform">displayform</A><BR>
   (char *strformfile, char *strvalues);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflhttp.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>CGIETHER</B>  </TT>
<TD ALIGN="LEFT">2
<TR><TD ALIGN="LEFT"><TT><B>CGIGET</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>CGIPOST</B>  </TT>
<TD ALIGN="LEFT">1
<TR><TD ALIGN="LEFT"><TT><B>_SFLHTTP_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>cgi_free_input(strBuf)</B>  </TT>
<TD ALIGN="LEFT">free((strBuf))
</TABLE>
<A NAME="http_escape">&nbsp;</A>
<H3><A NAME="TOC386"><TT>http_escape</TT></A></H3>
<PRE>
#include "sflhttp.h"
char *
http_escape (
    const char *string,
    char *result)
</PRE>
<H4>Synopsis</H4>
<P>Performs HTTP escaping on a string. This works as follows: all
   characters except alphanumerics and spaces are converted into
   the 3-byte sequence "%xx" where xx is the character's
   hexadecimal value; spaces are replaced by '+'. Line breaks are
   stored as "%0D%0A", where a 'line break' is any one of: "\n",
   "\r", "\n\r", or "\r\n". If the result buffer is NULL,
   calculates the required size, allocates a block of memory, and
   returns that. Otherwise, returns result, which must be large
   enough for the escaping operation (see <A HREF="sfldoc.htm#http_escape_size">http escape size</A>()).
   When you all <A HREF="sfldoc.htm#http_escape">http escape</A>() with a null target block, you
   must free the returned block using mem_free(). Returns NULL if
   it could not allocate a target block as required.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    static char
        hex_char [] = "0123456789ABCDEF";
    char
        *target;                        /*  Where we store the result        */

    ASSERT (string);
    if (result == NULL)
        if ((result = mem_alloc (<A HREF="sfldoc.htm#http_escape_size">http escape size</A> (string))) == NULL)
            return (NULL);              /*  Could not allocate a block       */

    target = result;
    while (*string)
      {
        if (isalnum (*string))          /*  Don't escape letters or digits   */
            *target++ = *string;
        else
        if (*string == ' ')             /*  Spaces are replaced by '+'       */
            *target++ = '+';
        else
        if (*string == '\n' || *string == '\r')
          {
            if ((string [1] == '\n' || string [1] == '\r')
            &amp;&amp;  (string [1] != *string))
                string++;
            *target++ = '%';            /*  New line becomes %0A%0D          */
            *target++ = '0';
            *target++ = 'A';
            *target++ = '%';
            *target++ = '0';
            *target++ = 'D';
          }
        else
          {
            *target++ = '%';            /*  Some other escaped character     */
            *target++ = hex_char [(byte) *string &gt;&gt; 4];
            *target++ = hex_char [(byte) *string &amp; 15];
          }
        string++;
      }
    *target = '\0';                     /*  Terminate target string          */
    return (result);
}
</PRE>
<A NAME="http_escape_size">&nbsp;</A>
<H3><A NAME="TOC387"><TT>http_escape_size</TT></A></H3>
<PRE>
#include "sflhttp.h"
size_t
http_escape_size (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Returns the size of a string after HTTP escaping. See the
   <A HREF="sfldoc.htm#http_escape">http escape</A>() function for details of the escaping
   algorithm. Includes the null terminator in the returned size.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    size_t
        result_size = 1;                /*  Allow for null terminator        */

    ASSERT (string);
    while (*string)
      {
        if (isalnum (*string))          /*  Don't escape letters or digits   */
            result_size++;
        else
        if (*string == ' ')             /*  Spaces are replaced by '+'       */
            result_size++;
        else
        if (*string == '\n' || *string == '\r')
          {
            if ((string [1] == '\n' || string [1] == '\r')
            &amp;&amp;  (string [1] != *string))
                string++;
            result_size += 6;           /*  Line ending becomes %0D%0A       */
          }
        else
            result_size += 3;           /*  Some other escaped character     */

        string++;
      }
    return (result_size);
}
</PRE>
<A NAME="http_unescape">&nbsp;</A>
<H3><A NAME="TOC388"><TT>http_unescape</TT></A></H3>
<PRE>
#include "sflhttp.h"
char *
http_unescape (
    char *string,
    char *result)
</PRE>
<H4>Synopsis</H4>
<P>Removes HTTP escaping from a string. See <A HREF="sfldoc.htm#http_escape">http escape</A>() for
   details of the escaping algorithm. If the result string is
   NULL, modifies the source string in place, else fills-in the
   result string. Returns the resulting string. End-of-line
   sequences (%0A%0D) are stored as a single new-line character,
   i.e. carriage-returns (%0D) are not stored.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    /*  This lookup table gives us a quick way to convert a hex digit        */
    /*  into a binary value.  Note that the index must be [0..127].          */
    static char
        hex_to_bin [128] = {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*            */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*            */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*            */
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0,    /*   0..9     */
            0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*   A..F     */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*            */
            0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*   a..f     */
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };  /*            */
    char
        *target;                        /*  Where we store the result        */

    ASSERT (string);
    if (!result)                        /*  If result string is null,        */
        result = string;                /*    modify in place                */
    target = result;

    while (*string)
      {
        if (*string == '%'              /*  Unescape %xx sequence            */
        &amp;&amp;   string [1] &amp;&amp; string [2])
          {
            *target = hex_to_bin [string [1] &amp; 127] * 16
                    + hex_to_bin [string [2] &amp; 127];
            string += 2;                /*  Bump past two hex digits         */
            if (*target != '\r')
                target++;               /*  We do not store CRs              */
          }
        else
        if (*string == '+')             /*  Spaces are escaped as '+'        */
            *target++ = ' ';
        else
            *target++ = *string;        /*  Otherwise just copy              */

        string++;
      }
    *target = '\0';                     /*  Terminate target string          */
    return (result);
}
</PRE>
<A NAME="http_query2strt">&nbsp;</A>
<H3><A NAME="TOC389"><TT>http_query2strt</TT></A></H3>
<PRE>
#include "sflhttp.h"
char **
http_query2strt (
    const char *original_query)
</PRE>
<H4>Synopsis</H4>
<P>Parses a HTTP query string, building an array of strings of the
   format "name=value". The query string is assumed to be in
   escaped format, so <A HREF="sfldoc.htm#http_unescape">http unescape</A>() is always applied to the
   query string. Within the query string, field=value pairs are
   delimited by &amp; or ;. Returns a pointer to the array. The
   array is allocated dynamically. The array ends with a NULL
   string. To free the table, call <A HREF="sfldoc.htm#strtfree">strtfree</A>(). If there was
   not enough memory to allocate the table, returns NULL.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    char
        *query,                         /*  Local copy of query string       */
        *query_ptr,                     /*  Pointer into query string        */
        *query_next,                    /*  Pointer to next query chunk      */
        **strings;                      /*  Returned string array            */
    int
        char_nbr,                       /*  Index into query string          */
        string_count,                   /*  Size of string table             */
        string_nbr;                     /*  Index into string table          */

    ASSERT (original_query);

    if (*original_query == '&amp;')         /*  Skip leading &amp; if present        */
        original_query++;

    if ((query = mem_strdup (original_query)) == NULL)
        return (NULL);                  /*  Could not allocate memory        */

    /*  Break query string at &amp; and ; delimiters and count strt size         */
    string_count = 1;                   /*  Last string has no delimiter     */
    for (char_nbr = 0; original_query [char_nbr]; char_nbr++)
        if (query [char_nbr] == '&amp;' || query [char_nbr] == ';')
          {
            query [char_nbr] = '\0';
            string_count++;
          }

    /*  Allocate the array of pointers with one slot for the final NULL      */
    if ((strings = mem_alloc (sizeof (char *) * (string_count + 1))) == NULL)
      {
        mem_free (query);
        return (NULL);                  /*  Could not allocate memory        */
      }

    /*  Query string now consists of a series of substrings, each ending in
     *  a null character.  We have to unescape each substring, which we do
     *  in-place: the unescaped string is never larger than the original
     *  string.
     */
    query_ptr = query;
    for (string_nbr = 0; string_nbr &lt; string_count; string_nbr++)
      {
        /*  Unescape next query string component                             */
        query_next = query_ptr + strlen (query_ptr) + 1;
        <A HREF="sfldoc.htm#http_unescape">http unescape</A> (query_ptr, NULL);

        /*  Allocate space for "name=value" plus final null char             */
        strings [string_nbr] = mem_strdup (query_ptr);
        query_ptr = query_next;
      }
    strings [string_nbr] = NULL;        /*  Store final null pointer         */
    mem_free (query);                   /*  Release temporary memory         */
    return (strings);
}
</PRE>
<A NAME="http_query2symb">&nbsp;</A>
<H3><A NAME="TOC390"><TT>http_query2symb</TT></A></H3>
<PRE>
#include "sflhttp.h"
SYMTAB *
http_query2symb (
    const char *query)
</PRE>
<H4>Synopsis</H4>
<P>Parses a HTTP query string, and populates a symbol table with
   the resulting field values. The query string is assumed to be
   escaped, so <A HREF="sfldoc.htm#http_unescape">http unescape</A>() is always applied to the query
   string. Within the query string, field=value pairs are
   delimited by &amp; or ;. Returns a SYMTAB pointer to the new
   table. If there was not enough memory to allocate the table,
   returns NULL.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    char
        **strings;                      /*  Formatted string array           */
    SYMTAB
        *symtab;                        /*  Returned symbol table            */

    strings = <A HREF="sfldoc.htm#http_query2strt">http query2strt</A> (query);
    if (strings)
      {
        symtab = <A HREF="sfldoc.htm#strt2symb">strt2symb</A> (strings);
        <A HREF="sfldoc.htm#strtfree">strtfree</A> (strings);
        return (symtab);
      }
    else
        return (NULL);                  /*  Couldn't create string table     */
}
</PRE>
<A NAME="http_query2descr">&nbsp;</A>
<H3><A NAME="TOC391"><TT>http_query2descr</TT></A></H3>
<PRE>
#include "sflhttp.h"
DESCR *
http_query2descr (
    const char *query)
</PRE>
<H4>Synopsis</H4>
<P>Parses a HTTP query string, and returns the values as a DESCR
   block, composed of null-delimited strings with an empty string
   at the end. See <A HREF="sfldoc.htm#strt2descr">strt2descr</A>() and <A HREF="sfldoc.htm#http_query2symb">http query2symb</A>() for
   more details. Returns the address of the allocated descriptor,
   or NULL if there was not enough memory.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    char
        **strings;                      /*  Formatted string array           */
    DESCR
        *descr;                         /*  Returned descriptor              */

    strings = <A HREF="sfldoc.htm#http_query2strt">http query2strt</A> (query);
    if (strings)
      {
        descr = <A HREF="sfldoc.htm#strt2descr">strt2descr</A> (strings);
        <A HREF="sfldoc.htm#strtfree">strtfree</A> (strings);
        return (descr);
      }
    else
        return (NULL);                  /*  Couldn't create string table     */
}
</PRE>
<A NAME="http_encode_meta">&nbsp;</A>
<H3><A NAME="TOC392"><TT>http_encode_meta</TT></A></H3>
<PRE>
#include "sflhttp.h"
size_t
http_encode_meta (
    char       *output,
    const char *input,
    size_t      outmax)
</PRE>
<H4>Synopsis</H4>
<P>Translates special characters into HTML/SGML metacharacters.
   The input buffer is not modified; you supply an output buffer
   and specify the maximum size of this buffer. The input buffer
   must end in a null. Returns the final size of the translated
   data excluding the final null byte. If the resulting data is
   too long, it is brutally truncated.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    /*  This lookup table provides a translation string for each byte
     *  in the character set.  We assume 8-bit characters.  When the
     *  string is NULL, the character is copied without translation.
     */
    static char
        *meta [256];                    /*  Metacharacter translation table  */
    static Bool
        first_time = TRUE;              /*  First time flag                  */
    int
        char_index;                     /*  Index into translation table     */
    size_t
        space_left;                     /*  Space left in destination        */
    const char
        *source;                        /*  Pointer to source string         */
    char
        *dest,                          /*  Pointer to result string         */
        *meta_char;                     /*  Pointer through metachar string  */

    ASSERT (input);
    ASSERT (output);

#   define OUTPUT(c)  if (!space_left) ; else { *dest++ = (c); space_left--; }

    /*  Initialise translation table first time through                      */
    if (first_time)
      {
        first_time = FALSE;
        for (char_index = 0; char_index &lt; 256; char_index++)
            meta [char_index] = NULL;

#if (defined (__UNIX__) || defined (__WINDOWS__))
        /*  UNIX and Windows generally use ISO-8859-1 (Latin-1)              */
        meta [0xC4] = "Auml";
        meta [0xC5] = "Aring";
        meta [0xC6] = "AElig";
        meta [0xD6] = "Ouml";
        meta [0xDC] = "Uuml";
        meta [0xE0] = "agrave";
        meta [0xE1] = "aacute";
        meta [0xE2] = "acirc";
        meta [0xE4] = "auml";
        meta [0xE5] = "aring";
        meta [0xE6] = "aelig";
        meta [0xE7] = "ccedil";
        meta [0xE8] = "egrave";
        meta [0xE9] = "eacute";
        meta [0xEA] = "ecirc";
        meta [0xEB] = "euml";
        meta [0xEC] = "igrave";
        meta [0xED] = "iacute";
        meta [0xEE] = "icirc";
        meta [0xEF] = "iuml";
        meta [0xF2] = "ograve";
        meta [0xF3] = "oacute";
        meta [0xF4] = "ocirc";
        meta [0xF6] = "ouml";
        meta [0xF9] = "ugrave";
        meta [0xFA] = "uacute";
        meta [0xFB] = "ucirc";
        meta [0xFC] = "uuml";
        meta [0xFD] = "yuml";

#elif (defined (__MSDOS__))
        /*  DOS generally uses the PC-1 alphabet                             */
        meta [0x80] = "uuml";
        meta [0x82] = "eacute";
        meta [0x83] = "acirc";
        meta [0x84] = "auml";
        meta [0x85] = "agrave";
        meta [0x86] = "aring";
        meta [0x87] = "ccedil";
        meta [0x88] = "ecirc";
        meta [0x89] = "euml";
        meta [0x8A] = "egrave";
        meta [0x8B] = "iuml";
        meta [0x8C] = "icirc";
        meta [0x8D] = "igrave";
        meta [0x8E] = "Auml";
        meta [0x2F] = "Aring";
        meta [0x91] = "aelig";
        meta [0x92] = "AElig";
        meta [0x93] = "ocirc";
        meta [0x94] = "ouml";
        meta [0x95] = "ograve";
        meta [0x96] = "ucirc";
        meta [0x97] = "ugrave";
        meta [0x98] = "yuml";
        meta [0x99] = "Ouml";
        meta [0x9A] = "Uuml";
        meta [0xA0] = "aacute";
        meta [0xA1] = "iacute";
        meta [0xA2] = "oacute";
        meta [0xA3] = "uacute";
#endif
      }
    if (outmax == 0)                    /*  Special case for zero space      */
        return (0);

    space_left = outmax - 1;            /*  Allow for final null byte        */
    dest = output;
    for (source = input; *source; source++)
      {
        meta_char = meta [(int) *source &amp; 255];
        if (meta_char)
          {
            OUTPUT ('&amp;');
            while (*meta_char)
              {
                OUTPUT (*meta_char);
                meta_char++;
              }
            OUTPUT (';');
          }
        else
            OUTPUT (*source);
      }
    *dest = '\0';
    return ((size_t) (dest - output));
}
</PRE>
<A NAME="cgi_parse_query_vars">&nbsp;</A>
<H3><A NAME="TOC393"><TT>cgi_parse_query_vars</TT></A></H3>
<PRE>
#include "sflhttp.h"
int
cgi_parse_query_vars (
    SYMTAB *symtab,
    const char *query,
    const char *prefix)
</PRE>
<H4>Synopsis</H4>
<P>Parses a CGI query string and loads the resulting variables
   into an existing symbol table, optionally prefixing each name
   with a string. Returns the number of variables loaded. The
   prefix can be NULL or empty if not required.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    static char
        query_var [LINE_MAX];           /*  Query variable name              */
    char
        **query_vars,                   /*  Query as string table            */
        *equals;                        /*  Equal sign in variable           */
    int
        string_nbr,                     /*  Index into string table          */
        variables = 0;                  /*  Number of variables loaded       */

    ASSERT (symtab);
    if ((query_vars = <A HREF="sfldoc.htm#http_query2strt">http query2strt</A> (query)) == NULL)
        return (0);                     /*  Not enough memory                */

    for (string_nbr = 0; query_vars [string_nbr]; string_nbr++)
      {
        equals = strchr (query_vars [string_nbr], '=');
        if (equals)
          {
            *equals = '\0';             /*  Cut into two strings             */
            if (prefix &amp;&amp; *prefix)
              {
                ASSERT (strlen (query_vars [string_nbr])
                      + strlen (prefix) &lt; LINE_MAX);
                <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (query_var, prefix, query_vars [string_nbr], NULL);
              }
            else
                strcpy (query_var, query_vars [string_nbr]);

            <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, query_var, equals + 1);
            *equals = '=';              /*  Restore previous state           */
            variables++;                /*  Count this variable              */
          }
      }
    <A HREF="sfldoc.htm#strtfree">strtfree</A> (query_vars);
    return (variables);
}
</PRE>
<A NAME="cgi_parse_file_vars">&nbsp;</A>
<H3><A NAME="TOC394"><TT>cgi_parse_file_vars</TT></A></H3>
<PRE>
#include "sflhttp.h"
int
cgi_parse_file_vars (
    SYMTAB *symtab,
    FILE   *file,
    const char *prefix,
    size_t size)
</PRE>
<H4>Synopsis</H4>
<P>Parses a CGI query string stored in a file, and loads the
   resulting variables into an existing symbol table, optionally
   prefixing each name with a string. Returns the number of
   variables loaded. The prefix can be NULL or empty if not
   required. The file data is assumed to be escaped (see
   <A HREF="sfldoc.htm#http_escape">http escape</A>()); the data should not contain line breaks,
   spaces, or other unescaped chars. The file should already have
   been opened: a typical use for this function is to parse the
   values supplied in stdin. The maximum size for the file is
   CGI_QUERY_FILE_MAX characters.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    char
        *query;                         /*  Data loaded from file            */
    size_t
        read_size;                      /*  Amount of data read from file    */
    int
        variables = 0;                  /*  Number of variables loaded       */

    ASSERT (file);
    ASSERT (symtab);
    ASSERT (size &lt;= CGI_QUERY_FILE_MAX);

    if ((query = mem_alloc (size + 1)) == NULL)
        return (0);

    read_size = fread (query, 1, size, file);
    query [read_size] = '\0';
    variables = <A HREF="sfldoc.htm#cgi_parse_query_vars">cgi parse query vars</A> (symtab, query, prefix);
    mem_free (query);
    return (variables);
}
</PRE>
<A NAME="http_multipart_decode">&nbsp;</A>
<H3><A NAME="TOC395"><TT>http_multipart_decode</TT></A></H3>
<PRE>
#include "sflhttp.h"
DESCR *
http_multipart_decode (const char *mime_file, const char *store_path,
                       const char *local_format)
</PRE>
<H4>Synopsis</H4>
<P>Parses a multipart-encoded file (as received by a web server as
   POST data) and returns a HTTP-encoded string containing the
   field data, in the format:
   "name=value&amp;name=value&amp;name=value...". For each field
   that refers to an uploaded file (INPUT field with type FILE),
   creates a temporary file holding the data. The name of this
   temporary file is put into a generated variable, whose name is
   built by using the local format string (ex: '%s_tmp'). The
   actual uploaded file is stored in a temporary file whose name
   is generated by the SFL <A HREF="sfldoc.htm#get_tmp_file_name">get tmp file name</A>() function. So,
   data for a file upload field called "doc" will be stored in a
   temporary file called (eg) "temp1234.tmp", and a field
   "doc_tmp" will be added, with the value "temp1234.tmp". The
   HTTP-encoded string is returned as a DESCR block, which you can
   decode using <A HREF="sfldoc.htm#http_query2strt">http query2strt</A>(), passing the descriptor
   data. You must free the descriptor using mem_free() when you're
   finished with it.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    FILE
        *f_source,
        *f_tmp = NULL;
    char
        *tmp_name = NULL,
        *p_head,
        *p_data,
        *p_next,
        *buffer;
    int
        offset,
        read_size;
    static char
        separator [80 + 1];
    static int
        sep_size;
    SYMTAB
        *table,
        *header_tab;
    qbyte
        tmp_index = 1;
    DESCR
        *descr = NULL;

    ASSERT (local_format);

    if (strstr (local_format, "%s") == NULL)
        return (NULL);

    buffer = mem_alloc (MULTI_BUFFER_SIZE + 1);
    if (buffer == NULL)
        return (NULL);

    table = <A HREF="sfldoc.htm#sym_create_table">sym create table</A> ();
    if (table == NULL)
      {
        mem_free (buffer);
        return (NULL);
      }

    header_tab = <A HREF="sfldoc.htm#sym_create_table">sym create table</A> ();
    if (header_tab == NULL)
      {
        mem_free (buffer);
        <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (table);
        return (NULL);
      }

    f_source = fopen (mime_file, "rb");
    if (f_source == NULL)
      {
        mem_free (buffer);
        <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (table);
        <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (header_tab);
        return (NULL);
      }

    memset (separator, 0, sizeof (separator));
    separator [0] = 0x0D;
    separator [1] = 0x0A;
    fgets (&amp;separator [2], 78, f_source);
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (&amp;separator [2] , '\r', '\0');
    <A HREF="sfldoc.htm#strconvch">strconvch</A> (&amp;separator [2] , '\n', '\0');
    sep_size  = strlen (separator);

    read_size = fread (buffer, 1, MULTI_BUFFER_SIZE, f_source);
    p_next = buffer;
    while (read_size &gt; 0)
      {
        <A HREF="sfldoc.htm#sym_empty_table">sym empty table</A> (header_tab);
        p_head = p_next;
        p_data = (char *) <A HREF="sfldoc.htm#memfind">memfind</A> ((byte *) p_head,
                          MULTI_BUFFER_SIZE - (p_head - buffer),
                          (byte *) "\r\n\r\n", 4, FALSE);
        if (p_data)
          {
            *p_data = '\0';
            p_data += 4;
          }
        if (p_head)
          {
            multipart_decode_header (p_head, header_tab);
            if (<A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A> (header_tab, "filename") != NULL)
              {
                if (f_tmp != NULL)
                  {
                    ASSERT (tmp_name != NULL);
                    fclose (f_tmp);
                    f_tmp = NULL;
                    if (<A HREF="sfldoc.htm#get_file_size">get file size</A> (tmp_name) == 0)
                        <A HREF="sfldoc.htm#file_delete">file delete</A> (tmp_name);
                  }
                tmp_name = <A HREF="sfldoc.htm#get_tmp_file_name">get tmp file name</A> (store_path, &amp;tmp_index, "tmp");
                f_tmp = fopen (tmp_name, "wb");
              }
          }
        p_next = (char *) <A HREF="sfldoc.htm#memfind">memfind</A> ((byte *) p_data,
                          read_size - (p_data - buffer),
                          (byte *) separator, sep_size, FALSE);
        if (p_next != NULL)
          {
            *p_next = '\0';
            save_multipart_header (table, header_tab, p_data, tmp_name,
                                   local_format);
            if (f_tmp)
              {
                fwrite (p_data, p_next - p_data, 1, f_tmp);
                fclose (f_tmp);
                f_tmp = NULL;
                if (<A HREF="sfldoc.htm#get_file_size">get file size</A> (tmp_name) == 0)
                    <A HREF="sfldoc.htm#file_delete">file delete</A> (tmp_name);
              }
            p_next += sep_size;

            /*  Found end of file marker                                     */
            if (*p_next == '-' &amp;&amp; *(p_next + 1) == '-')
              {
                if (f_tmp)
                  {
                    fclose (f_tmp);
                    f_tmp = NULL;
                    if (<A HREF="sfldoc.htm#get_file_size">get file size</A> (tmp_name) == 0)
                        <A HREF="sfldoc.htm#file_delete">file delete</A> (tmp_name);
                  }
                break;
              }
            else
                while (*p_next == '\r' || *p_next == '\n')
                    p_next++;
          }
        else
          {
            if (f_tmp)
                fwrite (p_data, &amp;buffer [read_size - sep_size ] - p_data,
                        1, f_tmp);
            offset = 0;
            while (read_size &gt; 0 &amp;&amp; p_next == NULL)
              {
                memmove (buffer, &amp;buffer [read_size - sep_size + offset ],
                                 sep_size);
                read_size = fread (&amp;buffer [sep_size], 1,
                                   MULTI_BUFFER_SIZE - sep_size, f_source);
                p_next = (char *) <A HREF="sfldoc.htm#memfind">memfind</A> ((byte *) buffer,
                                  read_size + sep_size,
                                  (byte *) separator, sep_size, FALSE);
                if (p_next != NULL)
                  {
                    *p_next = '\0';
                    save_multipart_header (table, header_tab,
                                           p_data, tmp_name, local_format);
                    if (f_tmp)
                      {
                        fwrite (buffer, p_next - buffer, 1, f_tmp);
                        fclose (f_tmp);
                        f_tmp = NULL;
                        if (<A HREF="sfldoc.htm#get_file_size">get file size</A> (tmp_name) == 0)
                            <A HREF="sfldoc.htm#file_delete">file delete</A> (tmp_name);
                      }
                    p_next += sep_size;

                   /*  Found end of file marker                              */
                   if (*p_next == '-' &amp;&amp; *(p_next + 1) == '-')
                     {
                       read_size = 0;
                       break;
                     }
                   else
                       while (*p_next == '\r' || *p_next == '\n')
                           p_next++;
                   read_size += sep_size;
                  }
                else
                  {
                    if (f_tmp)
                        fwrite (buffer, read_size, 1, f_tmp);
                    offset = sep_size;
                  }

              }
          }
      }
    if (f_tmp)
      {
        fclose (f_tmp);
        if (<A HREF="sfldoc.htm#get_file_size">get file size</A> (tmp_name) == 0)
            <A HREF="sfldoc.htm#file_delete">file delete</A> (tmp_name);
      }
    <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (header_tab);
    fclose (f_source);
    mem_free (buffer);

    descr = http_multipart2url (table);
    <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A> (table);

    return (descr);
}
</PRE>
<A NAME="is_full_url">&nbsp;</A>
<H3><A NAME="TOC396"><TT>is_full_url</TT></A></H3>
<PRE>
#include "sflhttp.h"
Bool
is_full_url (const char *string)
</PRE>
<H4>Synopsis</H4>
<P>If the specified string starts with a URL scheme, returns TRUE,
   else returns FALSE. A schema is one or more of [A-Za-z0-9+-.]
   followed by a ':'.
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    Bool
        scheme_size = 0;

    ASSERT (string);
    while (*string)
      {
        if (isalpha (*string)
        ||  isdigit (*string)
        ||  *string == '+'
        ||  *string == '-'
        ||  *string == '.')
            scheme_size++;              /*  So far, a valid scheme name      */
        else
        if (*string == ':')
            return (scheme_size &gt; 0);   /*  Okay if ':' was not first char   */
        else
            return (FALSE);             /*  No scheme name found             */
        string++;
      }
    return (FALSE);                     /*  End of string but no scheme      */
}
</PRE>
<A NAME="cgi_get_input">&nbsp;</A>
<H3><A NAME="TOC397"><TT>cgi_get_input</TT></A></H3>
<PRE>
#include "sflhttp.h"
char *
cgi_get_input (
    int iMethod)
</PRE>
<H4>Synopsis</H4>
<P>Gets CGI data input from stdin or the enviorment vairable
   QUERY_STRING, to form a stream to be used by cgi_fld_by_name,
   cgi_fld_by_index and cgi_fld_len_by_index functions. After you
   have finshed with the input stream from this function you
   should call, cgi_free_input to free it up. Submitted by Scott
   Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    int iStdinLen = 0, iMethodWas = 0;
    char *strHead, *strRetBuf;

    if (iMethod == CGIPOST
    ||  iMethod == CGIETHER)
      {
        if (getenv ("CONTENT_LENGTH"))
          {
            iStdinLen = atoi (getenv ("CONTENT_LENGTH"));
            iMethodWas = 1;
          }
      }
    if (iMethod == CGIGET
    || (iMethod == CGIETHER &amp;&amp; !iStdinLen))
      {
        if (getenv ("QUERY_STRING"))
          {
            iStdinLen = strlen (getenv ("QUERY_STRING"));
            iMethodWas = 0;
          }
      }
    if (!iStdinLen)
        return (NULL);

    strHead = strRetBuf = (char *) malloc (sizeof (char) *
                                           iStdinLen + 1);
    if (strHead == NULL)
        return (NULL);

    memset (strRetBuf, 0, iStdinLen + 1);
    if (iMethodWas == CGIPOST)
        fread (strRetBuf, sizeof (char), iStdinLen, stdin);
    else
        strcpy (strRetBuf, getenv ("QUERY_STRING"));

    return (*strHead? strHead: NULL);
}
</PRE>
<A NAME="cgi_fld_by_name">&nbsp;</A>
<H3><A NAME="TOC398"><TT>cgi_fld_by_name</TT></A></H3>
<PRE>
#include "sflhttp.h"
char *
cgi_fld_by_name (
    char *strFld,
    char *strIn,
    char *strRetBuf)
</PRE>
<H4>Synopsis</H4>
<P>Gets field data from a CGI input stream based off a HTML form
   field name. This function returns the value of the form field.
   example: Form snippet: Product &lt;INPUT TYPE="text"
   NAME="SENDERID" SIZE=80 VALUE="mailto"&gt; Version &lt;INPUT
   TYPE="text" NAME="VERSION" SIZE=80 VALUE="v1.4"&gt; E-mail
   &lt;INPUT TYPE="text" NAME="Email" SIZE=80&gt; CGI code to get
   form field: <A HREF="sfldoc.htm#cgi_fld_by_name">cgi fld by name</A> ("VERSION", strStdin,
   strVersion); On return from the call: strVersion would =
   "VERSION" Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    int iCnt = 0, iLen;
    char *strTmp;

    ASSERT (strFld);
    ASSERT (strIn);

    <A HREF="sfldoc.htm#trim">trim</A> (strFld);
    *strRetBuf = (char) NULL;
    FOREVER
      {
        iLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strIn, iCnt, 0, "&amp;");
        if (!iLen)
            break;

        strTmp = (char *) malloc (sizeof (char) * iLen + 1);
        <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strIn, iCnt++, 0, "&amp;", strTmp);
        if (!<A HREF="sfldoc.htm#lexncmp">lexncmp</A> (strFld, strTmp, strlen (strFld)))
          {
            <A HREF="sfldoc.htm#getequval">getequval</A> (strTmp, strRetBuf);
            <A HREF="sfldoc.htm#http_unescape">http unescape</A> (strRetBuf, NULL);
          }
        if (strTmp)
            free (strTmp);
        strTmp = NULL;
      }
    return strRetBuf;
}
</PRE>
<A NAME="cgi_fld_by_index">&nbsp;</A>
<H3><A NAME="TOC399"><TT>cgi_fld_by_index</TT></A></H3>
<PRE>
#include "sflhttp.h"
char *
cgi_fld_by_index (
    int iPos,
    char *strIn,
    char *strRetBuf,
    char *strFldName)
</PRE>
<H4>Synopsis</H4>
<P>Gets field data from a CGI input stream based off a field
   index. The index is from 0 to n. Where 0 would be the first
   field in the stream, and n would be the last. This function
   returns the HTML form field name and the value of the field.
   example: Form snippet: Product &lt;INPUT TYPE="text"
   NAME="SENDERID" SIZE=80 VALUE="mailto"&gt; Version &lt;INPUT
   TYPE="text" NAME="VERSION" SIZE=80 VALUE="v1.4"&gt; E-mail
   &lt;INPUT TYPE="text" NAME="Email" SIZE=80&gt; CGI code to get
   form field: <A HREF="sfldoc.htm#cgi_fld_by_index">cgi fld by index</A> (1, strStdin, strFldValue,
   strFldName); On return from the call: strFldValue would =
   "v1.4" and would strFldName be = "VERSION" Submitted by Scott
   Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    int iLen;
    char *strTmp;

    ASSERT (strIn);

    *strRetBuf = (char) NULL;
    iLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strIn, iPos, 0, "&amp;");
    if (iLen)
      {
        strTmp = (char *) malloc (sizeof (char) * iLen + 1);

        <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strIn, iPos, 0, "&amp;", strTmp);
        <A HREF="sfldoc.htm#getequval">getequval</A> (strTmp, strRetBuf);
        <A HREF="sfldoc.htm#http_unescape">http unescape</A> (strRetBuf, NULL);
        if (strFldName)
            <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strTmp, 0, 0, "=", strFldName);

        free (strTmp);
      }
    return strRetBuf;
}
</PRE>
<A NAME="cgi_fld_len_by_index">&nbsp;</A>
<H3><A NAME="TOC400"><TT>cgi_fld_len_by_index</TT></A></H3>
<PRE>
#include "sflhttp.h"
int
cgi_fld_len_by_index (
    int iPos,
    char *strIn,
    int *iDataLen,
    int *iNameLen)
</PRE>
<H4>Synopsis</H4>
<P>Gets the length of the field data from a CGI input stream based
   off a field index. The index is from 0 to n. Where 0 would be
   the first field in the stream, and n would be the last.
   example: Form snippet: Product &lt;INPUT TYPE="text"
   NAME="SENDERID" SIZE=80 VALUE="mailto"&gt; Version &lt;INPUT
   TYPE="text" NAME="VERSION" SIZE=80 VALUE="v1.4"&gt; E-mail
   &lt;INPUT TYPE="text" NAME="Email" SIZE=80&gt; CGI code to get
   form field: <A HREF="sfldoc.htm#cgi_fld_len_by_index">cgi fld len by index</A> (1, strStdin,
   &amp;iDataLen, &amp;iNameLen); On return from the call:
   iDataLen would = 4 and iNameLen would be = 7 Submitted by Scott
   Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    int iLen;
    char *strTmp;

    ASSERT (strIn);

    iLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strIn, iPos, 0, "&amp;");

    if (iLen)
      {
        strTmp = (char *) malloc (sizeof (char) * iLen + 1);

        <A HREF="sfldoc.htm#getstrfld">getstrfld</A> (strIn, iPos, 0, "&amp;", strTmp);
        <A HREF="sfldoc.htm#http_unescape">http unescape</A> (strTmp, NULL);
        iLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strTmp, 1, 0, "=");
        if (iDataLen)
            *iDataLen = iLen;

        if (iNameLen)
            *iNameLen = <A HREF="sfldoc.htm#getstrfldlen">getstrfldlen</A> (strTmp, 0, 0, "=");

        free (strTmp);
      }

    return iLen;
}
</PRE>
<A NAME="displayform">&nbsp;</A>
<H3><A NAME="TOC401"><TT>displayform</TT></A></H3>
<PRE>
#include "sflhttp.h"
int
displayform (
    char *strformfile,
    char *strvalues)
</PRE>
<H4>Synopsis</H4>
<P>Writes a HTML file out to the web browser or another file.
   Gives the option to have replaceable parameters in your HTML.
   Form snippet: Product &lt;INPUT TYPE="text" NAME="SENDERID"
   SIZE=80 VALUE="%PRONAME%"&gt; Version &lt;INPUT TYPE="text"
   NAME="TOIDS" SIZE=80 VALUE="%PROVER%"&gt; E-mail &lt;INPUT
   TYPE="text" NAME="Email" SIZE=80&gt; This would/could be a
   string you build at runtime: char *strformparms =
   "%PRONAME%|mailto,%PROVER%|v1.4"; char *strfilename = The full
   path to the HTML file to display. This will read the file and
   do any string replaces it needs to and then send it out to the
   browser, or file with the changes. <A HREF="sfldoc.htm#displayform">displayform</A>
   (strfilename, strformparms); Submitted by Scott Beasley <A
   HREF=mailto:"jscottb@infoave.com">jscottb@infoave.com</A>
<H4>Source Code - (sflhttp.c)</H4>
<PRE>
{
    FILE *fp;
    char strline[1025];

    ASSERT (strformfile);

    fp = fopen (strformfile, "r");
    if (!fp)
        return 1;

    while (!feof (fp))
      {
        fgets (strline, 1024, fp);
        <A HREF="sfldoc.htm#strcrop">strcrop</A> (strline);
        if (*strvalues)
            <A HREF="sfldoc.htm#stringreplace">stringreplace</A> (strline, strvalues);
        puts (strline);
      }

    fclose (fp);
    return 0;
}
</PRE>
<H2><A NAME="TOC402">Environment variable functions</A></H2>
<P>Filename: sflenv.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/05/14 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/03/21
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read environment variables (also called
   shell variables or logical variables.) Provides translation
   into numeric and Boolean values. Provides functions to work
   with the environment block.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#env_get_string">env get string</A><BR>
   (const char *name, const char *default_value);
</LI>
<LI>long <A HREF="sfldoc.htm#env_get_number">env get number</A><BR>
   (const char *name, long default_value);
</LI>
<LI>Bool <A HREF="sfldoc.htm#env_get_boolean">env get boolean</A><BR>
   (const char *name, Bool default_value);
</LI>
<LI>DESCR * <A HREF="sfldoc.htm#env2descr">env2descr</A><BR>
   (void);
</LI>
<LI>char * <A HREF="sfldoc.htm#descr2env">descr2env</A><BR>
   (const DESCR *descr);
</LI>
<LI>SYMTAB * <A HREF="sfldoc.htm#env2symb">env2symb</A><BR>
   (void);
</LI>
<LI>char * <A HREF="sfldoc.htm#symb2env">symb2env</A><BR>
   (const SYMTAB *symtab);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflenv.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLENV_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="env_get_string">&nbsp;</A>
<H3><A NAME="TOC403"><TT>env_get_string</TT></A></H3>
<PRE>
#include "sflenv.h"
char *
env_get_string (
    const char *name,
    const char *default_value)
</PRE>
<H4>Synopsis</H4>
<P>Translates the specified environment variable and returns a
   static string containing the value. If the variable is not
   defined in the environment, returns the specified default
   value. Note: if you want to use the value in a program you
   should use <A HREF="sfldoc.htm#strdupl">strdupl</A>() to make a copy. The environment
   variable name is always translated into upper case. The default
   value may be NULL.
<H4>Examples</H4>
<PRE>
    config_file = strdupl (env_get_string ("config", "default.cfg"));
</PRE>
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    static char
        variable_name [LINE_MAX];
    char
        *variable_value;

    <A HREF="sfldoc.htm#strupc">strupc</A> (strcpy (variable_name, name));
    variable_value = getenv (variable_name);
    return (variable_value? variable_value: (char *) default_value);
}
</PRE>
<A NAME="env_get_number">&nbsp;</A>
<H3><A NAME="TOC404"><TT>env_get_number</TT></A></H3>
<PRE>
#include "sflenv.h"
long
env_get_number (
    const char *name,
    long default_value)
</PRE>
<H4>Synopsis</H4>
<P>Translates the specified environment variable and returns the
   long numeric value of the string. If the variable is not
   defined in the environment, returns the specified default
   value. The environment variable name is always translated into
   upper case.
<H4>Examples</H4>
<PRE>
    max_retries = env_get_number ("retries", 5);
</PRE>
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    char
        *variable_value;

    variable_value = <A HREF="sfldoc.htm#env_get_string">env get string</A> (name, NULL);
    return (variable_value? atol (variable_value): default_value);
}
</PRE>
<A NAME="env_get_boolean">&nbsp;</A>
<H3><A NAME="TOC405"><TT>env_get_boolean</TT></A></H3>
<PRE>
#include "sflenv.h"
Bool
env_get_boolean (
    const char *name,
    Bool default_value)
</PRE>
<H4>Synopsis</H4>
<P>Translates the specified environment variable and returns the
   Boolean value of the string. If the variable is not defined in
   the environment, returns the specified default value. The
   environment variable name is always translated into upper case.
   The environment variable value is interpreted irrespective to
   upper/lower case, and looking at the first letter only. T/Y/1
   are TRUE, everything else is FALSE. See <A HREF="sfldoc.htm#conv_str_bool">conv str bool</A>() for
   the conversion rules.
<H4>Examples</H4>
<PRE>
    enforce_security = env_get_number ("security", FALSE);
</PRE>
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    char
        *variable_value;

    variable_value = <A HREF="sfldoc.htm#env_get_string">env get string</A> (name, NULL);
    return (variable_value?
           (<A HREF="sfldoc.htm#conv_str_bool">conv str bool</A> (variable_value) != 0): default_value);
}
</PRE>
<A NAME="env2descr">&nbsp;</A>
<H3><A NAME="TOC406"><TT>env2descr</TT></A></H3>
<PRE>
#include "sflenv.h"
DESCR *
env2descr (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a DESCR pointer containing the current process
   environment strings. The descriptor is allocated using
   mem_alloc(); you should use mem_free() to deallocate when you
   are finished. Returns NULL if there was not enough memory to
   allocate the descriptor.
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#strt2descr">strt2descr</A> (environ));
}
</PRE>
<A NAME="descr2env">&nbsp;</A>
<H3><A NAME="TOC407"><TT>descr2env</TT></A></H3>
<PRE>
#include "sflenv.h"
char **
descr2env (
    const DESCR *descr)
</PRE>
<H4>Synopsis</H4>
<P>Returns an environment block from the supplied descriptor data.
   The returned block is an array of strings, terminated by a null
   pointer. Each string is allocated independently using
   mem_alloc(). Returns NULL if there was not enough memory to
   allocate the block.
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    return (<A HREF="sfldoc.htm#descr2strt">descr2strt</A> (descr));
}
</PRE>
<A NAME="env2symb">&nbsp;</A>
<H3><A NAME="TOC408"><TT>env2symb</TT></A></H3>
<PRE>
#include "sflenv.h"
SYMTAB *
env2symb (void)
</PRE>
<H4>Synopsis</H4>
<P>Creates a symbol table containing the environment variables.
   Each variable is stored as a name plus value. You can destroy
   the symbol table using <A HREF="sfldoc.htm#sym_delete_table">sym delete table</A>() when you are
   finished with it.
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    SYMTAB
        *symtab;                        /*  Allocated symbol table           */
    char
        *next_entry,                    /*  Environment variable + value     */
        *equals;                        /*  Position of '=' in string        */
    int
        string_nbr;                     /*  Index into string table          */

    /*  We create the table here, instead of passing through <A HREF="sfldoc.htm#strt2symb">strt2symb</A>(),
        since we have to ensure that environment variable names are stored
        in uppercase.  Some systems (NT) return mixed-case names.            */

    symtab = <A HREF="sfldoc.htm#sym_create_table">sym create table</A> ();
    if (symtab)
      {
        for (string_nbr = 0; environ [string_nbr]; string_nbr++)
          {
            next_entry = mem_strdup (environ [string_nbr]);
            equals = strchr (next_entry, '=');
            if (equals)
              {
                *equals = '\0';         /*  Cut into two strings             */
                <A HREF="sfldoc.htm#strupc">strupc</A> (next_entry);
                <A HREF="sfldoc.htm#sym_assume_symbol">sym assume symbol</A> (symtab, next_entry, equals + 1);
              }
            mem_free (next_entry);
          }
      }
    return (symtab);
}
</PRE>
<A NAME="symb2env">&nbsp;</A>
<H3><A NAME="TOC409"><TT>symb2env</TT></A></H3>
<PRE>
#include "sflenv.h"
char **
symb2env (
    const SYMTAB *symtab)
</PRE>
<H4>Synopsis</H4>
<P>Returns an environment block from the supplied symbol table.
   The returned block is an array of strings, terminated by a null
   pointer. Each string is allocated independently using
   mem_alloc(). Returns NULL if there was not enough memory to
   allocate the block. Normalises the environment variable names
   as follows: converts all letters to uppercase, and non-
   alphanumeric characters to underlines. To free the array, use
   <A HREF="sfldoc.htm#strtfree">strtfree</A>(). See also <A HREF="sfldoc.htm#symb2strt">symb2strt</A>().
<H4>Source Code - (sflenv.c)</H4>
<PRE>
{
    MEMTRN
        *memtrn;                        /*  Memory transation                */
    SYMBOL
        *symbol;                        /*  Pointer to symbol                */
    char
        **strings,                      /*  Returned string array            */
        *name_and_value,                /*  Name=value string                */
        *nameptr;                       /*  Pointer into name                */
    int
        string_nbr;                     /*  Index into symbol_array          */

    if (!symtab)
        return (NULL);                  /*  Return NULL if argument is null  */

    /*  Allocate the array of pointers with one slot for the final NULL      */
    memtrn  = <A HREF="sfldoc.htm#mem_new_trans">mem new trans</A> ();
    strings = mem_alloc (sizeof (char *) * (symtab-&gt; size + 1));
    if (strings)
      {
        string_nbr = 0;
        for (symbol = symtab-&gt; symbols; symbol; symbol = symbol-&gt; next)
          {
            /*  Allocate space for "name=value" plus final null char         */
            name_and_value = mem_alloc (strlen (symbol-&gt; name)
                                      + strlen (symbol-&gt; value) + 2);
            if (!name_and_value)        /*  Quit if no memory left           */
              {
                <A HREF="sfldoc.htm#mem_rollback">mem rollback</A> (memtrn);
                return (NULL);
              }
            /*  Get symbol name in uppercase, using underlines               */
            strcpy (name_and_value, symbol-&gt; name);
            for (nameptr = name_and_value; *nameptr; nameptr++)
                if (isalnum (*nameptr))
                    *nameptr = toupper (*nameptr);
                else
                    *nameptr = '_';
            strcat (name_and_value, "=");
            strcat (name_and_value, symbol-&gt; value);
            strings [string_nbr++] = name_and_value;
          }
        strings [string_nbr] = NULL;    /*  Store final null pointer         */
      }
    <A HREF="sfldoc.htm#mem_commit">mem commit</A> (memtrn);
    return (strings);
}
</PRE>
<H2><A NAME="TOC410">String token manipulation functions.</A></H2>
<P>Filename: sfltok.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/09/10 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/03/31
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to break strings into tokens and handle
   symbol substitution in strings.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#tok_split">tok split</A><BR>
   (const char *string);
</LI>
<LI>char * <A HREF="sfldoc.htm#tok_split_rich">tok split rich</A><BR>
   (const char *string, const char *delims);
</LI>
<LI>void <A HREF="sfldoc.htm#tok_free">tok free</A><BR>
   (char **token_list);
</LI>
<LI>char * <A HREF="sfldoc.htm#tok_push">tok push</A><BR>
   (char **token_list, const char *string);
</LI>
<LI>int <A HREF="sfldoc.htm#tok_size">tok size</A><BR>
   (char **token_list);
</LI>
<LI>size_t <A HREF="sfldoc.htm#tok_text_size">tok text size</A><BR>
   (char **token_list);
</LI>
<LI>char * <A HREF="sfldoc.htm#tok_subst">tok subst</A><BR>
   (const char *string, SYMTAB *symbols);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfltok.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLTOK_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="tok_split">&nbsp;</A>
<H3><A NAME="TOC411"><TT>tok_split</TT></A></H3>
<PRE>
#include "sfltok.h"
char **
tok_split (
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Accepts a string and breaks it into words, delimited by white
   space (spaces, tabs, newlines). Returns an array of strings
   which ends in a NULL string. If the string is empty or NULL,
   returns an array containing a single NULL value. The array is
   allocated dynamically by this function, and you must call
   <A HREF="sfldoc.htm#tok_free">tok free</A>() to release it when you have finished. Returns
   NULL if there was insufficient memory to complete the split
   operation.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    char
        *buffer,
        *bufptr,
        **token_list,                   /*  Returned token list              */
        last_char = '\0';               /*  Last character parsed            */
    int
        word_count = 0,                 /*  Number of words in string        */
        word_nbr;

    /*  Allocate space for work string, up to the size of the input string   */
    buffer = mem_alloc (strlen (string) + 1);
    if (buffer == NULL)
        return (NULL);

    /*  Now copy string and eliminate whitespace                             */
    bufptr = buffer;                    /*  Move to start of target buffer   */
    if (string)                         /*  Allow string to be NULL          */
      {
        while (*string)                 /*  Copy entire string               */
            if (isspace (*string))      /*  Collapse whitespace to           */
              {                         /*    a single null byte             */
                while (isspace (*string))
                    string++;
                if (bufptr &gt; buffer)
                  {
                    word_count++;       /*  We have a new word               */
                    last_char = *bufptr++ = '\0';
                  }
              }
            else
                last_char = *bufptr++ = *string++;
      }
    /*  Count last word if it was not terminated in a white space            */
    if (last_char &gt; 0)
        word_count++;
    *bufptr = '\0';                     /*  End with final NULL              */

    /*  The token list starts with a pointer to the buffer, then has one     */
    /*  pointer to each string in the buffer.  It ends with a null pointer.  */
    /*  We return the address of the first string pointer, i.e. the caller   */
    /*  does not see the pointer to the buffer.  We can thus get away with   */
    /*  just two allocs; one for the buffer and one for the token list.     */
    token_list = mem_alloc (sizeof (char *) * (word_count + 2));
    if (token_list == NULL)
        return (NULL);

    token_list [0] = buffer;            /*  Store buffer address             */
    token_list++;                       /*    and bump starting address      */

    bufptr = buffer;
    for (word_nbr = 0; word_nbr &lt; word_count; word_nbr++)
      {
        token_list [word_nbr] = bufptr;
        bufptr += strlen (bufptr) + 1;
      }
    token_list [word_count] = NULL;     /*  Store final null pointer         */
    return (token_list);
}
</PRE>
<A NAME="tok_split_rich">&nbsp;</A>
<H3><A NAME="TOC412"><TT>tok_split_rich</TT></A></H3>
<PRE>
#include "sfltok.h"
char **
tok_split_rich (
    const char *string,
    const char *delims)
</PRE>
<H4>Synopsis</H4>
<P>Works as the <A HREF="sfldoc.htm#tok_split">tok split</A>() function, but handles tokens that
   are delimited by user-specified characters. A typical use of
   this function is to handle quoted strings. Each character in
   the delims argument is a potential token delimiter. For
   instance, to handle strings defined with single or double
   quotes, you could pass "\"'" as the delims argument. Note that
   this function always splits on spaces outside delimited tokens.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    char
        *buffer,
        *bufptr,
        **token_list,                   /*  Returned token list              */
        delim,                          /*  Current delimiter character      */
        last_char = '\0';               /*  Last character parsed            */
    int
        word_count = 0,                 /*  Number of words in string        */
        word_nbr;

    /*  Allocate space for work string, up to the size of the input string   */
    buffer = mem_alloc (strlen (string) + 1);
    if (buffer == NULL)
        return (NULL);

    /*  Now copy string and eliminate spaces and cut on delimiters           */
    bufptr = buffer;                    /*  Move to start of target buffer   */
    if (string)                         /*  Allow string to be NULL          */
      {
        while (*string)                 /*  Copy entire string               */
            if (strchr (delims, *string))
              {                         /*  User-specified delimiter         */
                word_count++;           /*  Count the word                   */
                delim = *string++;      /*    and skip the delimiter         */
                while (*string != delim)
                  {
                    if (*string)
                        *bufptr++ = *string++;
                    else
                        break;          /*  Unfinished token, but allright   */
                  }
                last_char = *bufptr++ = '\0';
                if (*string == delim)
                    string++;           /*  Skip final delimiter             */
                while (isspace (*string))
                    string++;           /*    and any trailing spaces        */
              }
            else
            if (isspace (*string))      /*  Collapse whitespace to           */
              {                         /*    a single null byte             */
                word_count++;           /*    unless at the start            */
                while (isspace (*string))
                    string++;
                if (bufptr &gt; buffer)
                    last_char = *bufptr++ = '\0';
              }
            else
                last_char = *bufptr++ = *string++;
      }
    /*  Count last word if it was not terminated in a white space            */
    if (last_char &gt; 0)
        word_count++;

    *bufptr = '\0';                     /*  End with final NULL              */

    /*  The token list starts with a pointer to the buffer, then has one     */
    /*  pointer to each string in the buffer.  It ends with a null pointer.  */
    /*  We return the address of the first string pointer, i.e. the caller   */
    /*  does not see the pointer to the buffer.  We can thus get away with   */
    /*  just two allocs; one for the buffer and one for the token list.     */
    token_list = mem_alloc (sizeof (char *) * (word_count + 2));
    if (token_list == NULL)
        return (NULL);

    token_list [0] = buffer;            /*  Store buffer address             */
    token_list++;                       /*    and bump starting address      */

    bufptr = buffer;
    for (word_nbr = 0; word_nbr &lt; word_count; word_nbr++)
      {
        token_list [word_nbr] = bufptr;
        bufptr += strlen (bufptr) + 1;
      }
    token_list [word_count] = NULL;     /*  Store final null pointer         */
    return (token_list);

}
</PRE>
<A NAME="tok_free">&nbsp;</A>
<H3><A NAME="TOC413"><TT>tok_free</TT></A></H3>
<PRE>
#include "sfltok.h"
void
tok_free (
    char **token_list)
</PRE>
<H4>Synopsis</H4>
<P>Frees the memory allocated by a <A HREF="sfldoc.htm#tok_split">tok split</A>() call. You
   should call this function for each call to <A HREF="sfldoc.htm#tok_split">tok split</A>(), to
   avoid memory leaks. Do not try to free the allocated memory
   yourself, as the structure of a token list is not documented
   and may change over time.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    token_list--;                       /*  Back-up to get right address     */
    mem_free (token_list [0]);          /*  Free buffer                      */
    mem_free (token_list);              /*    and free token list            */
}
</PRE>
<A NAME="tok_push">&nbsp;</A>
<H3><A NAME="TOC414"><TT>tok_push</TT></A></H3>
<PRE>
#include "sfltok.h"
char **
tok_push (
    char **token_list,
    const char *string)
</PRE>
<H4>Synopsis</H4>
<P>Prepends a string to the specified token table. Reallocates the
   table as required to make room for the new string. Returns the
   new token table -- the supplied token table is automatically
   freed by a call to <A HREF="sfldoc.htm#tok_free">tok free</A>().
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    char
        *new_buffer,                    /*  Newly-allocated buffer           */
        **new_list,                     /*  Returned token list              */
        *new_bufptr;                    /*  Pointer into new buffer          */
    int
        word_count,                     /*  Number of words in string        */
        word_nbr;
    size_t
        buffer_size;

    buffer_size = <A HREF="sfldoc.htm#tok_text_size">tok text size</A> (token_list);
    word_count  = <A HREF="sfldoc.htm#tok_size">tok size</A>      (token_list);

    /*  New list has one entry for each in old list, plus header, plus null
     *  entry at end, plus one for the new string -- makes 3 more.
     */
    new_list   = mem_alloc (sizeof (char *) * (word_count + 3));
    new_buffer = mem_alloc (buffer_size + strlen (string));
    if (new_list == NULL || new_buffer == NULL)
        return (NULL);

    word_count++;                       /*  We add one word                  */
    strcpy (new_buffer, string);
    memcpy (new_buffer + strlen (string) + 1, token_list [-1], buffer_size);
    new_list [0] = new_buffer;          /*  Store buffer address             */
    new_list++;                         /*    and bump starting address      */

    new_bufptr = new_buffer;
    for (word_nbr = 0; word_nbr &lt; word_count; word_nbr++)
      {
        new_list [word_nbr] = new_bufptr;
        new_bufptr += strlen (new_bufptr) + 1;
      }
    new_list [word_count] = NULL;       /*  Store final null pointer         */
    <A HREF="sfldoc.htm#tok_free">tok free</A> (token_list);              /*  Free old list                    */
    return (new_list);
}
</PRE>
<A NAME="tok_size">&nbsp;</A>
<H3><A NAME="TOC415"><TT>tok_size</TT></A></H3>
<PRE>
#include "sfltok.h"
int
tok_size (
    char **token_list)
</PRE>
<H4>Synopsis</H4>
<P>Returns size of specified token list, in entries. Stops at the
   empty terminating token. Thus the table "This", "Is", "A",
   "String" will return a size of 4.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    int
        word_nbr;

    for (word_nbr = 0; token_list [word_nbr]; word_nbr++);
    return (word_nbr);
}
</PRE>
<A NAME="tok_text_size">&nbsp;</A>
<H3><A NAME="TOC416"><TT>tok_text_size</TT></A></H3>
<PRE>
#include "sfltok.h"
size_t
tok_text_size (
    char **token_list)
</PRE>
<H4>Synopsis</H4>
<P>Returns size of specified token list, in characters. Counts the
   size of each token, plus one terminator for each token. Thus
   the table "This", "Is", "A", "String" will return a size of 17.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    size_t
        text_size;
    int
        word_nbr;

    text_size = 0;
    for (word_nbr = 0; token_list [word_nbr]; word_nbr++)
        text_size += strlen (token_list [word_nbr]) + 1;

    return (text_size);
}
</PRE>
<A NAME="tok_subst">&nbsp;</A>
<H3><A NAME="TOC417"><TT>tok_subst</TT></A></H3>
<PRE>
#include "sfltok.h"
char *
tok_subst (const char *string, SYMTAB *symbols)
</PRE>
<H4>Synopsis</H4>
<P>Performs symbol substitution into the specified string. Returns
   a newly-allocated string containing the result, or NULL if
   there was not enough memory. The symbol table holds the set of
   symbols that may be inserted. Undefined symbols are inserted as
   an empty value. Symbols are specified in the string using this
   syntax: $(name), where 'name' is case-sensitive. This version
   does not allow embedded symbols.
<H4>Source Code - (sfltok.c)</H4>
<PRE>
{
    char
        *sym_start,
        *sym_end,
        *sym_name,                      /*  Symbol name to look for          */
        *copied_to,                     /*  Up to where we copied so far     */
        *cur_result,                    /*  Current result buffer            */
        *new_result;                    /*  After adding next symbol         */
    int
        sym_length;                     /*  Length of symbol name            */
    SYMBOL
        *symbol;                        /*  Symbol in symbol table           */

    ASSERT (string);
    ASSERT (symbols);

    /*  Parse from left to right, looking for $(...) patterns                */
    cur_result = mem_strdup ("");       /*  Result buffer is empty           */
    sym_start  = strchr (string, '$');
    copied_to  = (char *) string;
    while (sym_start)
      {
        sym_end = strchr (++sym_start, ')');
        if (*sym_start == '('
        &amp;&amp;   sym_end
        &amp;&amp;  *sym_end   == ')')
          {
            /*  First, copy string up to sym_start                           */
            new_result = mem_alloc (strlen (cur_result)
                                    + sym_start - copied_to);
            strcpy  (new_result, cur_result);
            strncat (new_result, copied_to, sym_start - 1 - copied_to);
            mem_free (cur_result);
            cur_result = new_result;
            copied_to  = sym_end + 1;

            /*  Now translate and insert symbol                              */
            sym_length = sym_end - sym_start - 1;
            sym_name   = mem_alloc (sym_length + 1);
            memcpy (sym_name, sym_start + 1, sym_length);
            sym_name [sym_length] = 0;
            symbol = <A HREF="sfldoc.htm#sym_lookup_symbol">sym lookup symbol</A> (symbols, sym_name);
            mem_free (sym_name);
            if (symbol)
              {
                xstrcpy_debug ();
                new_result = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, cur_result, symbol-&gt; value, NULL);
                mem_free (cur_result);
                cur_result = new_result;
              }
          }
        else
            sym_end = sym_start + 1;

        sym_start = strchr (sym_end, '$');
      }
    /*  Copy anything remaining in the string                                */
    xstrcpy_debug ();
    new_result = <A HREF="sfldoc.htm#xstrcpy">xstrcpy</A> (NULL, cur_result, copied_to, NULL);
    mem_free (cur_result);
    return (new_result);
}
</PRE>
<H2><A NAME="TOC418">Linked-list functions</A></H2>
<P>Filename: sfltree.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 97/11/18 Jonathan Schultz <A
   HREF=mailto:"jonathan@imatix.com">jonathan@imatix.com</A>
<BR>Revised: 98/01/03 Jonathan Schultz <A
   HREF=mailto:"jonathan@imatix.com">jonathan@imatix.com</A>
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to maintain 'Red-Black' balanced binary
   trees. You can use these functions to work with trees of any
   structure. To make this work, all structures must start with
   the following: "void *left, *right, *parent; TREE_COLOUR
   colour;". All trees need a pointer to the root of type TREE
   which should be initialised with tree_init - you can test
   whether a tree is empty by comparing its root with TREE_NULL.
   The order of nodes in the tree is determined by calling a node
   comparison function provided by the caller - this accepts two
   node pointers and returns zero if the two nodes are equal, -1
   if the first is smaller and 1 if the first is larger.
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#tree_init">tree init</A><BR>
   (TREE **root);
</LI>
<LI>int <A HREF="sfldoc.htm#tree_insert">tree insert</A><BR>
   (TREE **root, void *tree, TREE_COMPARE *comp, Bool
   allow_duplicates);
</LI>
<LI>void <A HREF="sfldoc.htm#tree_delete">tree delete</A><BR>
   (TREE **root, void *tree);
</LI>
<LI>void * <A HREF="sfldoc.htm#tree_find">tree find</A><BR>
   (TREE **root, void *tree, TREE_COMPARE *comp);
</LI>
<LI>void <A HREF="sfldoc.htm#tree_traverse">tree traverse</A><BR>
   (void *tree, TREE_PROCESS *process, int method);
</LI>
<LI>void * <A HREF="sfldoc.htm#tree_next">tree next</A><BR>
   (void *tree);
</LI>
<LI>void * <A HREF="sfldoc.htm#tree_prev">tree prev</A><BR>
   (void *tree);
</LI>
<LI>void * <A HREF="sfldoc.htm#tree_first">tree first</A><BR>
   (void *tree);
</LI>
<LI>void * <A HREF="sfldoc.htm#tree_last">tree last</A><BR>
   (void *tree);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfltree.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>TREE_DUPLICATE</B>  </TT>
<TD ALIGN="LEFT">-1
<TR><TD ALIGN="LEFT"><TT><B>TREE_NULL</B>  </TT>
<TD ALIGN="LEFT">&TREE_EMPTY
<TR><TD ALIGN="LEFT"><TT><B>TREE_OK</B>  </TT>
<TD ALIGN="LEFT">0
<TR><TD ALIGN="LEFT"><TT><B>_SFLTREE_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>TREE_COLOUR</B>  </TT>
<TD ALIGN="LEFT">enum {BLACK, RED}
<TR><TD ALIGN="LEFT"><TT><B>TREE_COMPARE</B>  </TT>
<TD ALIGN="LEFT">int () (void *t1, void *t2)
<TR><TD ALIGN="LEFT"><TT><B>TREE_PROCESS</B>  </TT>
<TD ALIGN="LEFT">void () (void *t)
</TABLE>
<A NAME="tree_init">&nbsp;</A>
<H3><A NAME="TOC419"><TT>tree_init</TT></A></H3>
<PRE>
#include "sfltree.h"
void tree_init (TREE **root)
</PRE>
<H4>Synopsis</H4>
<P>Initialises an empty tree.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    *root = TREE_NULL;
}
</PRE>
<A NAME="tree_insert">&nbsp;</A>
<H3><A NAME="TOC420"><TT>tree_insert</TT></A></H3>
<PRE>
#include "sfltree.h"
int tree_insert (TREE **root, void *tree, TREE_COMPARE *comp,
                 Bool allow_duplicates)
</PRE>
<H4>Synopsis</H4>
<P>Inserts a node into an existing tree. Initialises node pointers
   and colour to correct values. The data used by the compare
   functions must be filled in so that tree_insert can find the
   correct place in the tree to insert the node.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current,
       *parent;
    int
        last_comp = 0;

    /* find where node belongs */
    current = *root;
    parent  = NULL;
    while (current != TREE_NULL)
      {
        parent  = current;
        last_comp = (comp) (tree, current);
        switch (last_comp)
          {
            case -1: current = current-&gt; left;  break;
            case  1: current = current-&gt; right; break;
            default: if (allow_duplicates)
                         current = current-&gt; left;
                     else
                         return TREE_DUPLICATE;

          }
      }

    /* setup new node */
    ((TREE *) tree)-&gt; parent = parent;
    ((TREE *) tree)-&gt; left   = TREE_NULL;
    ((TREE *) tree)-&gt; right  = TREE_NULL;
    ((TREE *) tree)-&gt; colour = RED;

    /* insert node in tree */
    if (parent)
        switch (last_comp)
          {
            case  1: parent-&gt; right = tree;  break;
            default: parent-&gt; left  = tree;
          }
    else
        *root = tree;

    insert_fixup (root, tree);
    return (TREE_OK);
}
</PRE>
<A NAME="tree_delete">&nbsp;</A>
<H3><A NAME="TOC421"><TT>tree_delete</TT></A></H3>
<PRE>
#include "sfltree.h"
void tree_delete (TREE **root, void *tree)
</PRE>
<H4>Synopsis</H4>
<P>Deletes a node from a tree. Does not deallocate any memory.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *youngest, *elder;
    TREE_COLOUR
        colour;

    if ((!tree)
    ||  (tree == TREE_NULL))
        return;

    if ((((TREE *) tree)-&gt; left  == TREE_NULL)
    ||  (((TREE *) tree)-&gt; right == TREE_NULL))
        /* elder has a TREE_NULL node as a child */
        elder = tree;
    else
      {
        /* find tree successor with a TREE_NULL node as a child */
        elder = ((TREE *) tree)-&gt; right;
        while (elder-&gt; left != TREE_NULL)
            elder = elder-&gt; left;
      }

    /* youngest is elder's only child */
    if (elder-&gt; left != TREE_NULL)
        youngest = elder-&gt; left;
    else
        youngest = elder-&gt; right;

    /* remove elder from the parent chain */
    youngest-&gt; parent = elder-&gt; parent;
    if (elder-&gt; parent)
        if (elder == elder-&gt; parent-&gt; left)
            elder-&gt; parent-&gt; left  = youngest;
        else
            elder-&gt; parent-&gt; right = youngest;
    else
        *root = youngest;

    colour = elder-&gt; colour;

    if (elder != tree)
      {
/*
    JS 1997/11/18: This is from the original code.  I have changed it because
    our implementation knows nothing about the data, and should handle varying
    size nodes within a single tree, provided the part of the data used for
    comparison remains the same.  Plus just moving the data around will mess
    up any other pointers to it.

        tree-&gt; Data = elder-&gt; Data;
*/
        elder-&gt; left   = ((TREE *) tree)-&gt; left;
        elder-&gt; right  = ((TREE *) tree)-&gt; right;
        elder-&gt; parent = ((TREE *) tree)-&gt; parent;
        elder-&gt; colour = ((TREE *) tree)-&gt; colour;
        if (((TREE *) tree)-&gt; parent)
            if (tree == ((TREE *) tree)-&gt; parent-&gt; left)
                ((TREE *) tree)-&gt; parent-&gt; left  = elder;
            else
                ((TREE *) tree)-&gt; parent-&gt; right = elder;
        else
            *root = elder;
      }

    if (colour == BLACK)
        delete_fixup (root, youngest);
}
</PRE>
<A NAME="tree_find">&nbsp;</A>
<H3><A NAME="TOC422"><TT>tree_find</TT></A></H3>
<PRE>
#include "sfltree.h"
void *tree_find (TREE **root, void *tree, TREE_COMPARE *comp)
</PRE>
<H4>Synopsis</H4>
<P>Finds a node with data matching that provided.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current = *root,
       *found;

    found = NULL;
    while (current != TREE_NULL)
        switch ((comp) (tree, current))
          {
            case -1: current = current-&gt; left;  break;
            case  1: current = current-&gt; right; break;
            default: found = current;           /*  In case of duplicates,   */
                     current = current-&gt; left;  /*  get the first one.       */
          }

    return found;
}
</PRE>
<A NAME="tree_traverse">&nbsp;</A>
<H3><A NAME="TOC423"><TT>tree_traverse</TT></A></H3>
<PRE>
#include "sfltree.h"
void tree_traverse (void *tree, TREE_PROCESS *process, int method)
</PRE>
<H4>Synopsis</H4>
<P>Traverse the tree, calling a processing function at each node.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    if ((!tree)
    ||  (tree == TREE_NULL))
        return;

    if (method == 1)
      {
        (process) (tree);
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; left,  process, method);
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; right, process, method);
      }
    else if (method == 2)
      {
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; left,  process, method);
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; right, process, method);
        (process) (tree);
      }
    else
      {
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; left,  process, method);
        (process) (tree);
        <A HREF="sfldoc.htm#tree_traverse">tree traverse</A> (((TREE *) tree)-&gt; right, process, method);
      }
}
</PRE>
<A NAME="tree_first">&nbsp;</A>
<H3><A NAME="TOC424"><TT>tree_first</TT></A></H3>
<PRE>
#include "sfltree.h"
void *tree_first (void *tree)
</PRE>
<H4>Synopsis</H4>
<P>Finds and returns the first node in a (sub-)tree.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current;

    if ((!tree)
    ||  (tree == TREE_NULL))
        return NULL;

    current = tree;
    while (current-&gt; left != TREE_NULL)
        current = current-&gt; left;

    return current;
}
</PRE>
<A NAME="tree_last">&nbsp;</A>
<H3><A NAME="TOC425"><TT>tree_last</TT></A></H3>
<PRE>
#include "sfltree.h"
void *tree_last (void *tree)
</PRE>
<H4>Synopsis</H4>
<P>Finds and returns the last node in a (sub-)tree.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current;

    if ((!tree)
    ||  (tree == TREE_NULL))
        return NULL;

    current = tree;
    while (current-&gt; right != TREE_NULL)
        current = current-&gt; right;

    return current;
}
</PRE>
<A NAME="tree_next">&nbsp;</A>
<H3><A NAME="TOC426"><TT>tree_next</TT></A></H3>
<PRE>
#include "sfltree.h"
void *tree_next (void *tree)
</PRE>
<H4>Synopsis</H4>
<P>Finds and returns the next node in a tree.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current,
       *child;

    if ((!tree)
    ||  (tree == TREE_NULL))
        return NULL;

    current = tree;
    if (current-&gt; right != TREE_NULL)
        return <A HREF="sfldoc.htm#tree_first">tree first</A> (current-&gt; right);
    else
      {
        current = tree;
        child   = TREE_NULL;
        while ((current-&gt; parent)
           &amp;&amp;  (current-&gt; right == child))
          {
            child = current;
            current = current-&gt; parent;
          }
        if (current-&gt; right != child)
            return current;
        else
            return NULL;
      }
}
</PRE>
<A NAME="tree_prev">&nbsp;</A>
<H3><A NAME="TOC427"><TT>tree_prev</TT></A></H3>
<PRE>
#include "sfltree.h"
void *tree_prev (void *tree)
</PRE>
<H4>Synopsis</H4>
<P>Finds and returns the previous node in a tree.
<H4>Source Code - (sfltree.c)</H4>
<PRE>
{
    TREE
       *current,
       *child;

    if ((!tree)
    ||  (tree == TREE_NULL))
        return NULL;

    current = tree;
    if (current-&gt; left != TREE_NULL)
        return <A HREF="sfldoc.htm#tree_last">tree last</A> (current-&gt; left);
    else
      {
        current = tree;
        child   = TREE_NULL;
        while ((current-&gt; parent)
           &amp;&amp;  (current-&gt; left == child))
          {
            child = current;
            current = current-&gt; parent;
          }
        if (current-&gt; left != child)
            return current;
        else
            return NULL;
      }
}
</PRE>
<H2><A NAME="TOC428">Tracing functions</A></H2>
<P>Filename: sfltron.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 92/10/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 97/09/08
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions for a programmer who needs to insert long-
   term tracing code in software. The tracing code is activated
   and disactivated at run-time, for instance when problems are
   suspected.
<H4>List of Functions</H4>
<UL>
<LI>void <A HREF="sfldoc.htm#enable_trace">enable trace</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#disable_trace">disable trace</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#push_trace">push trace</A><BR>
   (Bool new_state);
</LI>
<LI>void <A HREF="sfldoc.htm#pop_trace">pop trace</A><BR>
   (void);
</LI>
<LI>void <A HREF="sfldoc.htm#set_trace_file">set trace file</A><BR>
   (const char *filename, char mode);
</LI>
<LI>void <A HREF="sfldoc.htm#trace">trace</A><BR>
   (const char *format, ...);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfltron.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLTRON_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="enable_trace">&nbsp;</A>
<H3><A NAME="TOC429"><TT>enable_trace</TT></A></H3>
<PRE>
#include "sfltron.h"
void
enable_trace (void)
</PRE>
<H4>Synopsis</H4>
<P>Enables tracing. All calls to <A HREF="sfldoc.htm#trace">trace</A>() send a line of text
   to stdout or the trace file specified with
   <A HREF="sfldoc.htm#set_trace_file">set trace file</A>().
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    trace_state = TRUE;
}
</PRE>
<A NAME="disable_trace">&nbsp;</A>
<H3><A NAME="TOC430"><TT>disable_trace</TT></A></H3>
<PRE>
#include "sfltron.h"
void
disable_trace (void)
</PRE>
<H4>Synopsis</H4>
<P>Ends tracing. Following a call to this functions, calls to
   <A HREF="sfldoc.htm#trace">trace</A>() have no effect.
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    trace_state = FALSE;
}
</PRE>
<A NAME="push_trace">&nbsp;</A>
<H3><A NAME="TOC431"><TT>push_trace</TT></A></H3>
<PRE>
#include "sfltron.h"
void
push_trace (Bool new_state)
</PRE>
<H4>Synopsis</H4>
<P>Saves the current trace state. Restore with <A HREF="sfldoc.htm#pop_trace">pop trace</A>().
   The current implementation only saves one level of tracing.
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    pushed_state = trace_state;
    trace_state = new_state;
}
</PRE>
<A NAME="pop_trace">&nbsp;</A>
<H3><A NAME="TOC432"><TT>pop_trace</TT></A></H3>
<PRE>
#include "sfltron.h"
void
pop_trace (void)
</PRE>
<H4>Synopsis</H4>
<P>Restores a trace state saved by <A HREF="sfldoc.htm#push_trace">push trace</A>().
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    trace_state = pushed_state;
}
</PRE>
<A NAME="set_trace_file">&nbsp;</A>
<H3><A NAME="TOC433"><TT>set_trace_file</TT></A></H3>
<PRE>
#include "sfltron.h"
void
set_trace_file (const char *filename, char mode)
</PRE>
<H4>Synopsis</H4>
<P> Sends trace output to the specified file. If set_trace_file is
   not used, traces go to the console. If filename is null, any
   open trace file is close. Only one trace file can be open at
   any time. If mode is 'a', output is appended to the trace file;
   if 'w' the trace file is reset at open time. The caller can
   check for errors in this function by looking at the value of
   trace_file, which is left null if errors occur.
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    if (trace_file)
      {
        <A HREF="sfldoc.htm#file_close">file close</A> (trace_file);
        trace_file = NULL;
      }
    if (filename)
      {
        ASSERT (mode == 'w' || mode == 'a');
        trace_file = <A HREF="sfldoc.htm#file_open">file open</A> (filename, mode);
      }
}
</PRE>
<A NAME="trace">&nbsp;</A>
<H3><A NAME="TOC434"><TT>trace</TT></A></H3>
<PRE>
#include "sfltron.h"
void
trace (const char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P> If the global variable trace_state is TRUE, this function
   formats the parameters (using printf() conventions) and sends
   these to stdout, or the trace_file if opened using
   <A HREF="sfldoc.htm#set_trace_file">set trace file</A>(). The trace output is given a newline
   automatically. Reentrant. Uses globals.
<H4>Source Code - (sfltron.c)</H4>
<PRE>
{
    va_list
        argptr;                         /*  Argument list pointer            */
    FILE
        *out = stdout;                  /*  Output by default to stdout      */

    if (trace_state)
      {
        va_start (argptr, format);      /*  Start variable args processing   */
        if (trace_file)
            out = trace_file;

        /*  Output message:  date: message text\n                            */
        print_time_str (out);
        fputs    (": ", out);
        vfprintf (out, format, argptr);
        fputs    ("\n", out);
        fflush   (out);

        va_end (argptr);                /*  End variable args processing     */
      }
}
</PRE>
<H2><A NAME="TOC435">Process user id (uid) and group id (gid) functions</A></H2>
<P>Filename: sfluid.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 96/05/03 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/09/04
<BR>Copyright: Copyright (c) 1991-98 iMatix
<H3>Synopsis</H3>
<P>Provides functions to access user and group id names and manage
   the current real/effective uid's and gid's for a process. These
   functions are only meaningful on UNIX systems, and partially on
   VMS systems, but may be used by portable programs that must
   operate under UNIX as well as other environments. Some uid
   functions are non-portable between UNIX systems; this package
   provides a single API. Changes for OS/2 were done by Ewen
   McNeill <A HREF=mailto:"ewen@naos.co.nz">ewen@naos.co.nz</A>.
<H4>List of Functions</H4>
<UL>
<LI>char * <A HREF="sfldoc.htm#get_uid_name">get uid name</A><BR>
   (uid_t uid);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_gid_name">get gid name</A><BR>
   (gid_t gid);
</LI>
<LI>int <A HREF="sfldoc.htm#set_uid_user">set uid user</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_uid_root">set uid root</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_gid_user">set gid user</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_gid_root">set gid root</A><BR>
   (void);
</LI>
<LI>int <A HREF="sfldoc.htm#set_uid_gid">set uid gid</A><BR>
   (char *new_uid, char *new_gid);
</LI>
<LI>char * <A HREF="sfldoc.htm#get_login">get login</A><BR>
   (void);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sfluid.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SFLUID_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="get_uid_name">&nbsp;</A>
<H3><A NAME="TOC436"><TT>get_uid_name</TT></A></H3>
<PRE>
#include "sfluid.h"
char *
get_uid_name (uid_t uid)
</PRE>
<H4>Synopsis</H4>
<P> Get user name from passwd file. We optimise by keeping a table
   of uids and names in memory. Note that this will cause problems
   if the program stays running when the passwd file has been
   changed. Returns a string containing the translated user name,
   or "&lt;none&gt;" if the uid could not be translated. Under MS-
   DOS the uid must be zero. The returned string is in a static
   area that is _not_ overwritten with each call, but which should
   be treated as read-only, and unstable: i.e. the value returned
   by one call to get_uid_name may change as a result of a later
   call. If you need persistent strings, use <A HREF="sfldoc.htm#strdupl">strdupl</A>() after
   each call.
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#   if (defined (DOES_UID))
    static struct uids {                /*  Table of cached uids             */
        uid_t id;
        char  *name;
    } cache [UID_CACHE_MAX];
    static int
        cache_size = 0,                 /*  Number of uid's in cache         */
        cache_oldest = 0;               /*  Oldest entry in cache            */
    int
        cache_scan;                     /*  Scan through cache               */
    struct passwd
        *passwd_entry;

    /*  First, look for uid in cache                                         */
    for (cache_scan = 0; cache_scan &lt; cache_size; cache_scan++)
        if (cache [cache_scan].id == uid)
            return (cache [cache_scan].name);

    /*  Add new name to cache: if cache was full, kick-out oldest entry      */
    if (cache_size == UID_CACHE_MAX)
      {
        cache_scan = cache_oldest++;
        cache_oldest %= UID_CACHE_MAX;
        free (cache [cache_scan].name);
      }
    else
        cache_scan = cache_size++;

    cache [cache_scan].id = uid;
#   if (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
    cache [cache_scan].name = "&lt;none&gt;";
#   else
    if ((passwd_entry = getpwuid (uid)) == NULL)
        cache [cache_scan].name = "&lt;none&gt;";
    else
        cache [cache_scan].name = <A HREF="sfldoc.htm#strdupl">strdupl</A> (passwd_entry-&gt; pw_name);
#   endif

    return (cache [cache_scan].name);

#   elif (defined (__MSDOS__))
    return (uid == 0? "user": "&lt;none&gt;");

#   endif
}
</PRE>
<A NAME="get_gid_name">&nbsp;</A>
<H3><A NAME="TOC437"><TT>get_gid_name</TT></A></H3>
<PRE>
#include "sfluid.h"
char *
get_gid_name (gid_t gid)
</PRE>
<H4>Synopsis</H4>
<P> Get group name from group file. We optimise by keeping a table
   of gids and names in memory. Note that this will cause problems
   if the program stays running when the group file has been
   changed. Returns a string containing the translated user name,
   or "&lt;none&gt;" if the gid could not be translated. Under MS-
   DOS the gid must be zero. The returned string is in a static
   area that is _not_ overwritten with each call, but which should
   be treated as read-only, and unstable: i.e. the value returned
   by one call to get_gid_name may change as a result of a later
   call. If you need persistent strings, use <A HREF="sfldoc.htm#strdupl">strdupl</A>() after
   each call.
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#   if (defined (DOES_UID))
    static struct gids {                /*  Table of cache'd gids            */
        gid_t id;
        char  *name;
    } cache [GID_CACHE_MAX];
    static int
        cache_size = 0,                 /*  Number of gid's in cache         */
        cache_oldest = 0;               /*  Oldest entry in cache            */
    int
        cache_scan;                     /*  Scan through cache               */
    struct group
        *group_entry;

    /*  First, look for gid in cache                                         */
    for (cache_scan = 0; cache_scan &lt; cache_size; cache_scan++)
        if (cache [cache_scan].id == gid)
            return (cache [cache_scan].name);

    /*  Add new name to cache: if cache was full, kick-out oldest entry      */
    if (cache_size == GID_CACHE_MAX)
      {
        cache_scan = cache_oldest++;
        cache_oldest %= GID_CACHE_MAX;
        free (cache [cache_scan].name);
      }
    else
        cache_scan = cache_size++;

    cache [cache_scan].id = gid;
#   if (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
        cache [cache_scan].name = "&lt;none&gt;";
#   else
    if ((group_entry = getgrgid (gid)) == NULL)
        cache [cache_scan].name = "&lt;none&gt;";
    else
        cache [cache_scan].name = <A HREF="sfldoc.htm#strdupl">strdupl</A> (group_entry-&gt; gr_name);
#   endif

    return (cache [cache_scan].name);

#   elif (defined (__MSDOS__))
    return (gid == 0? "group": "&lt;none&gt;");

#   endif
}
</PRE>
<A NAME="set_uid_user">&nbsp;</A>
<H3><A NAME="TOC438"><TT>set_uid_user</TT></A></H3>
<PRE>
#include "sfluid.h"
int
set_uid_user (void)
</PRE>
<H4>Synopsis</H4>
<P>This function can be used by 'setuid' programs; i.e. programs
   that run under a fixed uid such as 'root'. Typically such
   programs need to access root resources, but user data files. To
   do this they must switch between the 'root' uid and the 'user'
   uid. This function switches to the real user id. Use
   <A HREF="sfldoc.htm#set_uid_root">set uid root</A>() to switch (back) to the 'root' uid. See
   also: <A HREF="sfldoc.htm#set_gid_user">set gid user</A>() and <A HREF="sfldoc.htm#set_gid_root">set gid root</A>().
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (DOES_UID))
#   if (defined (__UTYPE_HPUX))
    return (setuid (get_uid (REAL_ID)));
#   elif (defined (__OS2__))            /*  OS/2 only supports one UID       */
    return (0);
#   elif (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
    return (0);
#   else
    return (seteuid (get_uid (REAL_ID)));
#   endif
#else
    return (0);
#endif
}
</PRE>
<A NAME="set_uid_root">&nbsp;</A>
<H3><A NAME="TOC439"><TT>set_uid_root</TT></A></H3>
<PRE>
#include "sfluid.h"
int
set_uid_root (void)
</PRE>
<H4>Synopsis</H4>
<P>This function can be used by 'setuid' programs; i.e. programs
   that run under a fixed uid such as 'root'. Typically such
   programs need to access root resources, but user data files. To
   do this they must switch between the 'root' uid and the 'user'
   uid. This function switches back to the root user id. Use
   <A HREF="sfldoc.htm#set_uid_user">set uid user</A>() to switch to the 'user' uid. See also:
   <A HREF="sfldoc.htm#set_gid_user">set gid user</A>() and <A HREF="sfldoc.htm#set_gid_root">set gid root</A>().
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (DOES_UID))
#   if (defined (__UTYPE_HPUX))
    return (setuid (get_uid (EFFECTIVE_ID)));
#   elif (defined (__OS2__))            /*  OS/2 only supports one UID       */
    return (0);
#   elif (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
    return (0);
#   else
    return (seteuid (get_uid (EFFECTIVE_ID)));
#   endif
#else
    return (0);
#endif
}
</PRE>
<A NAME="set_gid_user">&nbsp;</A>
<H3><A NAME="TOC440"><TT>set_gid_user</TT></A></H3>
<PRE>
#include "sfluid.h"
int
set_gid_user (void)
</PRE>
<H4>Synopsis</H4>
<P>This function can be used by 'setgid' programs; i.e. programs
   that run under a fixed gid such as 'root'. Typically such
   programs need to access root resources, but user data files. To
   do this they must switch between the 'root' gid and the 'user'
   gid. This function switches to the real user id. Use
   <A HREF="sfldoc.htm#set_gid_root">set gid root</A>() to switch (back) to the 'root' gid. See
   also: <A HREF="sfldoc.htm#set_uid_user">set uid user</A>() and <A HREF="sfldoc.htm#set_uid_root">set uid root</A>().
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (DOES_UID))
#   if (defined (__UTYPE_HPUX))
    return (setgid (get_gid (REAL_ID)));
#   elif (defined (__OS2__))            /*  OS/2 only supports one UID       */
    return (0);
#   elif (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
    return (0);
#   else
    return (setegid (get_gid (REAL_ID)));
#   endif
#else
    return (0);
#endif
}
</PRE>
<A NAME="set_gid_root">&nbsp;</A>
<H3><A NAME="TOC441"><TT>set_gid_root</TT></A></H3>
<PRE>
#include "sfluid.h"
int
set_gid_root (void)
</PRE>
<H4>Synopsis</H4>
<P>This function can be used by 'setgid' programs; i.e. programs
   that run under a fixed gid such as 'root'. Typically such
   programs need to access root resources, but user data files. To
   do this they must switch between the 'root' gid and the 'user'
   gid. This function switches back to the root user id. Use
   <A HREF="sfldoc.htm#set_gid_user">set gid user</A>() to switch to the 'user' gid. See also:
   <A HREF="sfldoc.htm#set_gid_user">set gid user</A>() and <A HREF="sfldoc.htm#set_gid_root">set gid root</A>().
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (DOES_UID))
#   if (defined (__UTYPE_HPUX))
    return (setgid (get_gid (EFFECTIVE_ID)));
#   elif (defined (__OS2__))            /*  OS/2 only supports one UID       */
    return (0);
#   elif (defined (__VMS__) &amp;&amp; !defined (__VMS_XOPEN))
    return (0);
#   else
    return (setegid (get_gid (EFFECTIVE_ID)));
#   endif
#else
    return (0);
#endif
}
</PRE>
<A NAME="set_uid_gid">&nbsp;</A>
<H3><A NAME="TOC442"><TT>set_uid_gid</TT></A></H3>
<PRE>
#include "sfluid.h"
int
set_uid_gid (char *new_uid, char *new_gid)
</PRE>
<H4>Synopsis</H4>
<P>Sets the program's uid and gid to new values as specified (as
   names). The program must be currently running as 'root'.
   Returns 0 if the new names could be correctly used. Returns -1
   if the specified user id or group id was not valid, or -2 if
   the process was unable to change to the new uid/gid as
   specified.
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (DOES_UID))
    struct passwd
        *pwdbuf;
    struct group
        *grpbuf;
    int
        feedback = 0;

    if (new_gid)
      {
        if ((grpbuf = getgrnam (new_gid)) == NULL)
            return (-1);
        else
        if (setgid (grpbuf-&gt; gr_gid) == -1)
            return (-2);
      }
    if ((pwdbuf = getpwnam (new_uid)) == NULL)
        return (-1);
    else
    if (setuid (pwdbuf-&gt; pw_uid) == -1)
        return (-2);
#endif
    return (0);
}
</PRE>
<A NAME="get_login">&nbsp;</A>
<H3><A NAME="TOC443"><TT>get_login</TT></A></H3>
<PRE>
#include "sfluid.h"
char *
get_login (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the identity of the currently-logged user. The returned
   string is in a static buffer. Returns NULL if no user is
   currently logged-in.
<H4>Source Code - (sfluid.c)</H4>
<PRE>
{
#if (defined (__WINDOWS__))
#   if (defined (WIN32))
    ULONG
        user_name_max = 255;
    static char
        user_name [256];

    WNetGetUser (NULL, user_name, &amp;user_name_max);
    return (user_name);
#   else
    return ("none");
#   endif
#elif (defined (__UNIX__) || defined (__OS2__))
    return (getlogin ());
#endif
}
</PRE>
<H2><A NAME="TOC444">XML (Extensible Markup Language) access functions</A></H2>
<P>Filename: sflxml.h
<BR>Package: Standard Function Library (SFL)
<BR>Written: 98/02/25 iMatix SFL project team <A
   HREF=mailto:"sfl@imatix.com">sfl@imatix.com</A>
<BR>Revised: 98/03/30
<BR>Copyright: Copyright (c) 1998 iMatix
<H3>Synopsis</H3>
<P>Provides functions to read and write XML files, and manipulate
   XML data in memory as list structures. XML is the Extensible
   Markup Language. Accepts this XML syntax: &lt;item
   [attr=["]value["]]...&gt;value [child]&lt;/item&gt;
<H4>List of Functions</H4>
<UL>
<LI>XML_ITEM * <A HREF="sfldoc.htm#xml_new">xml new</A><BR>
   (XML_ITEM *parent, const char *name, const char *value);
</LI>
<LI>void <A HREF="sfldoc.htm#xml_modify_value">xml modify value</A><BR>
   (XML_ITEM *item, const char *value);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_item_name">xml item name</A><BR>
   (XML_ITEM *item);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_item_value">xml item value</A><BR>
   (XML_ITEM *item);
</LI>
<LI>void <A HREF="sfldoc.htm#xml_free">xml free</A><BR>
   (XML_ITEM *item);
</LI>
<LI>XML_ITEM * <A HREF="sfldoc.htm#xml_first_child">xml first child</A><BR>
   (XML_ITEM *item);
</LI>
<LI>XML_ITEM * <A HREF="sfldoc.htm#xml_next_sibling">xml next sibling</A><BR>
   (XML_ITEM *item);
</LI>
<LI>XML_ITEM * <A HREF="sfldoc.htm#xml_parent">xml parent</A><BR>
   (XML_ITEM *item);
</LI>
<LI>int <A HREF="sfldoc.htm#xml_put_attr">xml put attr</A><BR>
   (XML_ITEM *item, const char *name, const char *value);
</LI>
<LI>XML_ATTR * <A HREF="sfldoc.htm#xml_attr">xml attr</A><BR>
   (XML_ITEM *item, const char *name);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_attr_name">xml attr name</A><BR>
   (XML_ATTR *item);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_attr_value">xml attr value</A><BR>
   (XML_ATTR *item);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_get_attr">xml get attr</A><BR>
   (XML_ITEM *item, const char *name, const char *deflt);
</LI>
<LI>void <A HREF="sfldoc.htm#xml_free_attr">xml free attr</A><BR>
   (XML_ATTR *attr);
</LI>
<LI>XML_ATTR * <A HREF="sfldoc.htm#xml_first_attr">xml first attr</A><BR>
   (XML_ITEM *item);
</LI>
<LI>XML_ATTR * <A HREF="sfldoc.htm#xml_next_attr">xml next attr</A><BR>
   (XML_ATTR *attr);
</LI>
<LI>Bool <A HREF="sfldoc.htm#xml_changed">xml changed</A><BR>
   (XML_ITEM *item);
</LI>
<LI>Bool <A HREF="sfldoc.htm#xml_refresh">xml refresh</A><BR>
   (XML_ITEM *item);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflxml.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>FORATTRIBUTES(attr,item)</B>  </TT>
<TD ALIGN="LEFT">for (attr = xml_first_attr (item); <TR><TD ALIGN="LEFT"><TT><B>FORCHILDREN(child,item)</B>  </TT>
<TD ALIGN="LEFT">for (child = xml_first_child (item); <TR><TD ALIGN="LEFT"><TT><B>_SLFXML_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>XML_ATTR</B>  </TT>
<TD ALIGN="LEFT">struct _XML_ATTR
<TR><TD ALIGN="LEFT"><TT><B>XML_ITEM</B>  </TT>
<TD ALIGN="LEFT">struct _XML_ITEM
</TABLE>
<A NAME="xml_new">&nbsp;</A>
<H3><A NAME="TOC445"><TT>xml_new</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ITEM *
xml_new (
    XML_ITEM   *parent,
    const char *name,
    const char *value)
</PRE>
<H4>Synopsis</H4>
<P>Creates and initialises a new XML_ITEM item. The item is set to
   link to itself, and its sublists are initialised to be empty.
   Returns the address of the created XML_ITEM item or NULL if
   there was not enough memory. Sets the new item's (lower-case)
   name and value as specified; either of these arguments may be
   null. If the parent argument is not null, attaches the new item
   to the end of the parent item list.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    XML_ITEM
        *item;

    list_create (item, sizeof (XML_ITEM));
    if (item)
      {
        list_reset (&amp;item-&gt; attrs);
        list_reset (&amp;item-&gt; children);
        item-&gt; parent = parent;
        item-&gt; name   = <A HREF="sfldoc.htm#strlwc">strlwc</A> (mem_strdup (name));
        item-&gt; value  = mem_strdup (value);
        if (parent)
            list_relink_before (item, &amp;parent-&gt; children);

        return (item);
      }
    else
        return (NULL);
}
</PRE>
<A NAME="xml_modify_value">&nbsp;</A>
<H3><A NAME="TOC446"><TT>xml_modify_value</TT></A></H3>
<PRE>
#include "sflxml.h"
void
xml_modify_value  (XML_ITEM *item, const char *value)
</PRE>
<H4>Synopsis</H4>
<P>Modifies an existing XML item's value.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    if (!item-&gt; value)
        item-&gt; value = mem_strdup (value);
    else
    if (!streq (value, item-&gt; value))
      {
	mem_free (item-&gt; value);
        item-&gt; value = mem_strdup (value);
      }
}
</PRE>
<A NAME="xml_item_name">&nbsp;</A>
<H3><A NAME="TOC447"><TT>xml_item_name</TT></A></H3>
<PRE>
#include "sflxml.h"
char *
xml_item_name (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the name of a specified XML item. The returned string
   should NOT be modified. To manipulate it, first make a copy
   first.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    return item-&gt; name;
}
</PRE>
<A NAME="xml_item_value">&nbsp;</A>
<H3><A NAME="TOC448"><TT>xml_item_value</TT></A></H3>
<PRE>
#include "sflxml.h"
char *
xml_item_value (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the value of a specified XML item. The returned string
   should NOT be modified. To manipulate it, first make a copy
   first.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    return item-&gt; value;
}
</PRE>
<A NAME="xml_free">&nbsp;</A>
<H3><A NAME="TOC449"><TT>xml_free</TT></A></H3>
<PRE>
#include "sflxml.h"
void
xml_free (
    XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Frees all memory used by an XML_ITEM item and its children.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    /*  Free attribute nodes for the item                                    */
    while (!list_empty (&amp;item-&gt; attrs))
        <A HREF="sfldoc.htm#xml_free_attr">xml free attr</A> (item-&gt; attrs.next);

    /*  Free child nodes for the item                                        */
    while (!list_empty (&amp;item-&gt; children))
        <A HREF="sfldoc.htm#xml_free">xml free</A> (item-&gt; children.next);

    /*  Now free this item itself                                            */
    <A HREF="sfldoc.htm#list_unlink">list unlink</A> (item);                 /*  Unlink from its parent list      */
    mem_free (item-&gt; name);             /*  Free strings, if not null        */
    mem_free (item-&gt; value);
    mem_free (item);                    /*  And free the item itself         */
}
</PRE>
<A NAME="xml_first_child">&nbsp;</A>
<H3><A NAME="TOC450"><TT>xml_first_child</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ITEM *
xml_first_child (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Returns the first child node of the specified item, or NULL if
   there are none.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    if (!list_empty (&amp;item-&gt; children))
        return item-&gt; children. next;
    else
        return NULL;
}
</PRE>
<A NAME="xml_next_sibling">&nbsp;</A>
<H3><A NAME="TOC451"><TT>xml_next_sibling</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ITEM *
xml_next_sibling (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Returns the next sibling of the specified item, or NULL if
   there if are none.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    if ((LIST *) item-&gt; next != &amp; item-&gt; parent-&gt; children)
        return item-&gt; next;
    else
        return NULL;
}
</PRE>
<A NAME="xml_parent">&nbsp;</A>
<H3><A NAME="TOC452"><TT>xml_parent</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ITEM *
xml_parent (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Returns the parent of the specified item, or NULL if this is
   the root item.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    return (item-&gt; parent);
}
</PRE>
<A NAME="xml_put_attr">&nbsp;</A>
<H3><A NAME="TOC453"><TT>xml_put_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
int
xml_put_attr (
    XML_ITEM   *item,
    const char *name,
    const char *value)
</PRE>
<H4>Synopsis</H4>
<P>Sets, modifies, or deletes an attribute for the specified item.
   The (lower-case) attribute name must be supplied. If the value
   is NULL, any attribute with the specified name is deleted.
   Otherwise the specified attribute is either created or modified
   accordingly. Returns the number of attribute nodes created (-1,
   0, or 1).
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    int
        feedback = 0;
    XML_ATTR
        *attr;

    ASSERT (item);
    ASSERT (name);

    attr = <A HREF="sfldoc.htm#xml_attr">xml attr</A> (item, name);
    if (attr)
        if (value)                      /*  Value specified - update attr    */
          {
            mem_free (attr-&gt; value);
            attr-&gt; value = mem_strdup (value);
          }
        else
          {
            <A HREF="sfldoc.htm#xml_free_attr">xml free attr</A> (attr);       /*  No value - delete attribute      */
            feedback = -1;
          }
    else
        if (value)                      /*  Value specified - update attr    */
          {
            list_create (attr, sizeof (XML_ATTR));
            if (attr)
              {
                attr-&gt; name   = <A HREF="sfldoc.htm#strlwc">strlwc</A> (mem_strdup (name));
                attr-&gt; value  = mem_strdup (value);
		attr-&gt; parent = item;
                list_relink_before (attr, &amp;item-&gt; attrs);
                feedback = 1;
              }
          }
    return (feedback);
}
</PRE>
<A NAME="xml_attr">&nbsp;</A>
<H3><A NAME="TOC454"><TT>xml_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ATTR *
xml_attr (
    XML_ITEM   *item,
    const char *name)
</PRE>
<H4>Synopsis</H4>
<P>Searches for the attribute with the specified (lower-case)
   name; if found, returns the address of the attribute node,
   otherwise returns NULL.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    XML_ATTR
        *attr;

    ASSERT (item);
    ASSERT (name);

    FORLIST (attr, item-&gt; attrs)
        if (<A HREF="sfldoc.htm#lexcmp">lexcmp</A> (attr-&gt; name, name) == 0)
            return (attr);

    return (NULL);
}
</PRE>
<A NAME="xml_attr_name">&nbsp;</A>
<H3><A NAME="TOC455"><TT>xml_attr_name</TT></A></H3>
<PRE>
#include "sflxml.h"
char *
xml_attr_name (XML_ATTR *attr)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the name of a specified XML attr. The returned string
   should NOT be modified. To manipulate it, first make a copy
   first.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (attr);

    return attr-&gt; name;
}
</PRE>
<A NAME="xml_attr_value">&nbsp;</A>
<H3><A NAME="TOC456"><TT>xml_attr_value</TT></A></H3>
<PRE>
#include "sflxml.h"
char *
xml_attr_value (XML_ATTR *attr)
</PRE>
<H4>Synopsis</H4>
<P>Extracts the value of a specified XML attr. The returned string
   should NOT be modified. To manipulate it, first make a copy
   first.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (attr);

    return attr-&gt; value;
}
</PRE>
<A NAME="xml_get_attr">&nbsp;</A>
<H3><A NAME="TOC457"><TT>xml_get_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
char *
xml_get_attr (
    XML_ITEM   *item,
    const char *name,
    const char *deflt)
</PRE>
<H4>Synopsis</H4>
<P>Returns the value for the specified attribute, if it exists.
   Otherwise returns the default value.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    XML_ATTR
        *attr;

    ASSERT (item);
    ASSERT (name);

    attr = <A HREF="sfldoc.htm#xml_attr">xml attr</A> (item, name);
    if (attr)
        return (attr-&gt; value);
    else
        return ((char *) deflt);
}
</PRE>
<A NAME="xml_free_attr">&nbsp;</A>
<H3><A NAME="TOC458"><TT>xml_free_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
void
xml_free_attr (
    XML_ATTR *attr)
</PRE>
<H4>Synopsis</H4>
<P>Frees all memory used by an XML_ATTR node.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (attr);

    <A HREF="sfldoc.htm#list_unlink">list unlink</A> (attr);
    mem_free (attr-&gt; name);
    mem_free (attr-&gt; value);
    mem_free (attr);
}
</PRE>
<A NAME="xml_first_attr">&nbsp;</A>
<H3><A NAME="TOC459"><TT>xml_first_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ATTR *
xml_first_attr (XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Returns the first attribute of a specified XML item, or NULL if
   there are none.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (item);

    if (!list_empty (&amp;item-&gt; attrs))
        return item-&gt; attrs. next;
    else
        return NULL;
}
</PRE>
<A NAME="xml_next_attr">&nbsp;</A>
<H3><A NAME="TOC460"><TT>xml_next_attr</TT></A></H3>
<PRE>
#include "sflxml.h"
XML_ATTR *
xml_next_attr (XML_ATTR *attr)
</PRE>
<H4>Synopsis</H4>
<P>Returns the next attribute following the specified attribute,
   or NULL if there are none.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    ASSERT (attr);

    if ((LIST *) attr-&gt; next != &amp; attr-&gt; parent-&gt; attrs)
        return attr-&gt; next;
    else
        return NULL;
}
</PRE>
<A NAME="xml_changed">&nbsp;</A>
<H3><A NAME="TOC461"><TT>xml_changed</TT></A></H3>
<PRE>
#include "sflxml.h"
Bool
xml_changed (
    XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the XML file loaded into the specified list has
   in the meantime been changed. Returns FALSE if not.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    char
        *filename;

    ASSERT (item);

    /*  Date, time, and name of original XML file are in the list            */
    filename = <A HREF="sfldoc.htm#xml_get_attr">xml get attr</A> (item, "filename", NULL);
    if (filename
    &amp;&amp;  <A HREF="sfldoc.htm#file_has_changed">file has changed</A> (filename,
                          atol (<A HREF="sfldoc.htm#xml_get_attr">xml get attr</A> (item, "filedate", "0")),
                          atol (<A HREF="sfldoc.htm#xml_get_attr">xml get attr</A> (item, "filetime", "0"))))
        return (TRUE);
    else
        return (FALSE);
}
</PRE>
<A NAME="xml_refresh">&nbsp;</A>
<H3><A NAME="TOC462"><TT>xml_refresh</TT></A></H3>
<PRE>
#include "sflxml.h"
Bool
xml_refresh (
    XML_ITEM *item)
</PRE>
<H4>Synopsis</H4>
<P>Refreshes an XML tree created by <A HREF="sfldoc.htm#xml_load">xml load</A> (). If the
   original file (as specified by the 'filename' attribute of the
   root item) has been modified, reloads the whole XML file.
   Returns TRUE if the XML file was actually reloaded, or FALSE if
   the file had not changed or could not be accessed, or if the
   XML tree was incorrectly created.
<H4>Source Code - (sflxml.c)</H4>
<PRE>
{
    char
        *filename,
        *pathsym;

    ASSERT (item);
    if (<A HREF="sfldoc.htm#xml_changed">xml changed</A> (item))
      {
        pathsym  = mem_strdup (<A HREF="sfldoc.htm#xml_get_attr">xml get attr</A> (item, "pathsym",  NULL));
        filename = mem_strdup (<A HREF="sfldoc.htm#xml_get_attr">xml get attr</A> (item, "filename", NULL));
        <A HREF="sfldoc.htm#xml_free">xml free</A> (item);                /*  Delete previous XML tree         */
        <A HREF="sfldoc.htm#xml_load">xml load</A> (pathsym, filename);
        mem_free (pathsym);
        mem_free (filename);
        return (TRUE);
      }
    return (FALSE);
}
</PRE>
<H4>List of Functions</H4>
<UL>
<LI>XML_ITEM * <A HREF="sfldoc.htm#xml_load">xml load</A><BR>
   (const char *path, const char *filename);
</LI>
<LI>int <A HREF="sfldoc.htm#xml_save">xml save</A><BR>
   (XML_ITEM *item, const char *filename);
</LI>
<LI>char * <A HREF="sfldoc.htm#xml_error">xml error</A><BR>
   (void);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>sflxmll.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SLFXMLL_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="xml_save">&nbsp;</A>
<H3><A NAME="TOC463"><TT>xml_save</TT></A></H3>
<PRE>
#include "sflxmll.h"
int
xml_save (
    XML_ITEM   *item,
    const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Saves an XML tree to the specified file. Returns the number of
   items saved, or -1 if there was an error.
<H4>Source Code - (sflxmll.c)</H4>
<PRE>
{
    FILE
        *xmlfile;                       /*  XML output stream                */
    XML_ITEM
        *child;
    int
        count;                          /*  How many symbols did we save?    */

    ASSERT (item);
    ASSERT (filename);
    init_charmaps ();                   /*  Initialise character maps        */

    if ((xmlfile = <A HREF="sfldoc.htm#file_open">file open</A> (filename, 'w')) == NULL)
        return (-1);                    /*  No permission to write file      */

    /*  Write XML file header                                                */
    /* fprintf (xmlfile, "&lt;?XML VERSION=\"1.0\"?&gt;\n"); */

    /*  Output children of XML root                                          */
    count = 0;
    FORCHILDREN (child, item)
        count += xml_save_item (xmlfile, child, 1);

    <A HREF="sfldoc.htm#file_close">file close</A> (xmlfile);
    return (count);
}
</PRE>
<A NAME="xml_error">&nbsp;</A>
<H3><A NAME="TOC464"><TT>xml_error</TT></A></H3>
<PRE>
#include "sflxmll.h"
char *xml_error (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns the last error message generated by xml_load.
<H4>Source Code - (sflxmll.c)</H4>
<PRE>
{
    return error_message;
}
</PRE>
<A NAME="xml_load">&nbsp;</A>
<H3><A NAME="TOC465"><TT>xml_load</TT></A></H3>
<PRE>
#include "sflxmll.h"
XML_ITEM
*xml_load (const char *path,
           const char *filename)
</PRE>
<H4>Synopsis</H4>
<P>Loads the contents of an XML file into a new XML tree. The XML
   data is not checked against a DTD. Returns NULL if there was
   insufficient memory, or the XML file could not be read. The XML
   tree always starts with a top-level item called 'XML' with
   these attributes: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>filename</B>  <TD ALIGN="LEFT">Name of the XML
   input file <TR><TD ALIGN="LEFT"><B>filetime</B>  <TD
   ALIGN="LEFT">Modification time of the file, "HHMMSSCC" <TR><TD
   ALIGN="LEFT"><B>filedate</B>  <TD ALIGN="LEFT">Modification
   date of input file, "YYYYMMDD" </TABLE> Looks for the XML file
   on the specified path symbol, or in the current directory if
   the path argument is null. Adds the specified extension to the
   file name if there is none already included.
<H4>Source Code - (sflxmll.c)</H4>
<PRE>
{
    feedback = NULL;                    /*  Reset return feedback            */

    ASSERT (filename);
    pname = filename;
    ppath = path;

#   include "sflxmll.i"                 /*  Include dialog interpreter       */
}
</PRE>
<HR><TABLE WIDTH=100%><TR><TD ALIGN=LEFT WIDTH=60%>
 | <A HREF="sfldoc.htm">&lt;&lt;</A> | &lt;
 | &gt; | <A HREF="sfldoc.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT NOWRAP>
<A HREF="/index.htm">
<IMG SRC="im0096c.gif" WIDTH=96 HEIGHT=36 ALT="iMatix" BORDER=0 ALIGN=RIGHT>
</A>
<FONT SIZE=2>Copyright &#169; 1996-98 iMatix</TABLE>
</BODY></HTML>
